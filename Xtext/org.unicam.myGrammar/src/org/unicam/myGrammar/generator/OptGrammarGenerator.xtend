/*
 * generated by Xtext 2.19.0
 */
package org.unicam.myGrammar.generator

import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.unicam.myGrammar.optGrammar.Contract
import org.eclipse.emf.ecore.EObject
import org.unicam.myGrammar.optGrammar.FunctionDefinition
import org.unicam.myGrammar.optGrammar.EnumDefinition
import org.unicam.myGrammar.optGrammar.StructDefinition
import org.unicam.myGrammar.optGrammar.Mapping
import org.unicam.myGrammar.optGrammar.Expression
import org.unicam.myGrammar.optGrammar.Literal
import org.unicam.myGrammar.optGrammar.ArithmeticOperations
import org.unicam.myGrammar.optGrammar.StringLiteral
import org.unicam.myGrammar.optGrammar.BooleanConst
import org.unicam.myGrammar.optGrammar.FunctionCall
import org.unicam.myGrammar.optGrammar.SpecialVariablesTypeEnum
import org.unicam.myGrammar.optGrammar.BlockhashFunction
import org.unicam.myGrammar.optGrammar.GasleftFunction
import org.unicam.myGrammar.optGrammar.MathematicalFunction
import org.unicam.myGrammar.optGrammar.HashFunction
import org.unicam.myGrammar.optGrammar.EcrecoverFunction
import org.unicam.myGrammar.optGrammar.IntParameter
import org.unicam.myGrammar.optGrammar.NumericLiteral
import org.unicam.myGrammar.optGrammar.UnitTypes
import org.unicam.myGrammar.optGrammar.SimpleTypeDeclaration
import org.unicam.myGrammar.optGrammar.ElementaryTypeNameEnum
import org.unicam.myGrammar.optGrammar.PrimaryArithmetic

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class OptGrammarGenerator extends AbstractGenerator {
	@Inject extension IQualifiedNameProvider

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		resource.allContents.toIterable.filter(Contract).forEach [ c |
			fsa.generateFile(c.fullyQualifiedName.toString("/") + ".sol", c.compile)
		]
	}

	def compile(Contract c) '''
		pragma solidity ^0.5.2;
		
		contract «c.name» {
		«FOR block : c.blocks»
			«block.compileBlock»
		«ENDFOR»
		}
	'''

	def compileBlock(EObject b) {
		return switch b {
			Declaration: b.compileDeclaration
			FunctionDefinition: b.compileFunctionDefinition
		}
	}

	def String compileDeclaration(Declaration dec) {
		return switch dec {
			MappingDeclaration: dec.compileMapping + ";"
			EnumDeclaration: dec.compileEnum
			StructDeclaration: dec.compileStruct
			PrimaryTypeDefinitionDeclaration: dec.compilePrimaryTypeDefinitionDeclaration + ";"
			ArrayDeclaration: dec.compileArray + ";"
			ConcreteStructureDefinitionDeclaration: dec.compileConcreteStructure + ";"
		}
	}

	// Returns variable name
	def compileDeclarationReference(EObject dec) {
		return switch dec {
			ArrayDeclaration: dec.name
			StructDeclaration: dec.name
			EnumDeclaration: dec.name
			ConcreteStructDeclaration: dec.name
			PrimaryTypeDeclaration: dec.name
			MappingDeclaration: dec.name
		}
	}

	def compileFunctionDefinition(FunctionDefinition funDef) {
		return '''function «funDef.name»(''' + {
			(funDef.parameters !== null)
				? '''«FOR param : funDef.parameters SEPARATOR ', '»
				«param.compileDeclaration»
				«ENDFOR») '''
		} + {
			(funDef.visibility !== null)
				? '''«funDef.visibility.type» ''' : ""
		} + {
			(funDef.payable)
				? '''payable ''' : ""
		} + {
			(funDef.returnType !== null)
				? '''returns («funDef.returnType.compileTypes»)''' : ""
		} + '''{
		«FOR elem : funDef.blocks»
			«elem.compileInternalBlock»
		«ENDFOR»''' + '''«IF funDef.returnVal !== null»return«IF funDef.returnVal.^def !== null»«funDef.returnVal.^def.compileDefinitions»;
	 		«ELSEIF funDef.returnVal.defDec !== null»«funDef.returnVal.defDec.compileDeclaration»
	 		«ELSEIF funDef.returnVal.^val !== null»«funDef.returnVal.^val.compileCondition»;
	 		«ELSEIF funDef.returnVal.call !== null»«funDef.returnVal.call.compileCondition»;«ENDIF»
	 		«ENDIF»''' + '''}'''
	}

	def String compileInternalBlock(InternalBlock fb) {
		return {
			'''
				«IF fb.dec!== null»
					«fb.dec.compileDeclaration»
				«ENDIF»
				«IF fb.loop!== null»
					«fb.loop.compileLoopStructure»
				«ENDIF»
				«IF fb.def!== null»
					«fb.def.compileDefinitions»;
				«ENDIF»
				«IF fb.call!== null»
					«fb.call.compileFunctionCall»;
				«ENDIF»
			'''
		}
	}

	def compileEnum(EnumDefinition en) {
		return '''enum ''' + {
			(en.visibility !== null)
				? '''«en.visibility.type»''' : ""
		} + '''«en.name» {
			«FOR e : en.members»«e.name»
			«IF e != en.members.last», «ENDIF»
			«ENDFOR»
		}'''
	}

	// type location visibility name[][] == ?
	def compileArray(ArrayDeclaration arr) {
		return '''
		«IF arr.strucType !== null »«arr.strucType.name»«ELSE»«arr.type.compileTypes»«ENDIF»
		«FOR s : arr.sizes»
			[«s.value»]
		«ENDFOR»''' + {
			(arr.location !== null)
				? '''«arr.location.type»''' : ""
		} + {
			(arr.visibility !== null)
				? ''' «arr.visibility.type»''' : ""
		} + {
			(arr.constant) ? "constant" : ""
		} + ''' «arr.name»''' + {
			(arr.blocks !== null)
				? ''' = «arr.blocks.compileArrDefinition»''' : ""
		} + {
			(arr.^var !== null)
				? ''' = «arr.^var.compileArrDefinition»''' : ""
		} + {
			(arr.access !== null)
				? ''' = «arr.access.compileArrDefinition»''' : ""
		}
	}

	def compileArrDefinition(EObject arr) {
		return switch arr {
			FilledArray: arr.compileFilledArray
			Declaration: arr.compileDeclarationReference
			default: arr.compileAccess
		}
	}

	def compileFilledArray(FilledArray fa) {
		return '''«FOR set : fa.arrays»
	 	[
	 	«IF set.values !== null»
	 	«FOR value: set.values SEPARATOR ','»
	 	«value.compileExpression»
	 	«ENDFOR»
	 	«ENDIF»
	 	]
	 	«ENDFOR»'''
	}

	def compileAccess(EObject e) {
		return switch e {
			FieldAccess: '''«e.ref.compileDeclarationReference».«e.field»'''
			MappingAccess: '''«e.map.compileDeclarationReference»[«e.index.compileExpression»]'''
			ArrayAccess: '''«e.variable.compileDeclarationReference»«FOR el : e.indexes»[«el.value.compileExpression»]«ENDFOR»«IF e.field !== null».«e.field»«ENDIF»'''
		}
	}

	def compileTypes(EObject type) {
		return switch type {
			ElementaryTypeNameEnum: type.type
			,
			SimpleTypeDeclaration: type.type
		}
	}

	def compileStruct(StructDefinition st) {
		return {
			'''struct''' + {
				(st.visibility !== null)
					? ''' «st.visibility.type»''' : ""
			} + {
				(st.name !== null)
					? ''' «st.name»''' : ""
			} + {
				'''{
	 		«FOR f : st.members SEPARATOR '\n'»«f.compileDeclaration»«ENDFOR»
	 		}'''
			}
		}
	}

	def compileConcreteStructure(ConcreteStructureDefinitionDeclaration cs) {
		return {
			if (cs.ref === null) {
				'''«(cs as ConcreteStructDeclaration).type.name»''' +
					'''«IF ((cs as ConcreteStructDeclaration).location !== null)» «(cs as ConcreteStructDeclaration).location.type» «ENDIF»''' +
					{
						((cs as ConcreteStructDeclaration).constant) ? "constant " : ""
					} + '''«(cs as ConcreteStructDeclaration).name»'''
			} else {
				'''«cs.ref.name»'''
			}
		} + {
			if (cs.couples.length !== 0) {
				''' = «(cs as ConcreteStructDeclaration).type.name» ({«FOR c : cs.couples SEPARATOR ', '»
					«c.field»: «c.values.compileLogicalOrFilled»
				«ENDFOR»})'''
			} else if (cs.existenceRef !== null) {
				''' = «cs.existenceRef.name»'''
			} else if (cs.arrayAccessRef !== null) {
				''' = «cs.arrayAccessRef.compileAccess»'''
			} else {
				''''''
			}
		}
	}

	def compileMapping(MappingDeclaration mp) {
		return {
			(mp.visibility !== null)
				? ''' «mp.visibility.type»''' : ""
		} + '''«mp.Mapping.compileMapping»
		«IF mp.location !== null»
			storage 
		«ENDIF»«mp.name»'''
	}

	def String compileMapping(Mapping dec) {
		return '''mapping («dec.type.compileTypes» =>''' + {
			(dec.secondRef !== null)
				? '''«dec.secondRef.compileDeclarationReference»''' : ""
		} + {
			(dec.second !== null)
				? '''«IF dec.second instanceof Mapping» «Mapping.cast(dec.second).compileMapping» «»«ELSE» «dec.second.compileTypes»«ENDIF»''' : ""
		} + '''«IF (dec.array)»[]«ENDIF»)'''
	}

	def compilePrimaryTypeDefinitionDeclaration(PrimaryTypeDefinitionDeclaration pr) {
		return {
			if (pr.ref !== null) { // reference to existing declaration
				'''«pr.ref.name»«IF pr.value !== null» «pr.operator.value» «Expression.cast(pr.value).compileExpression» «ENDIF»'''
			} else { // inline declaration
				{
					(pr instanceof ArrayableDeclaration)
						? '''«pr.type.compileTypes»''' : ""
				} + {
					(pr instanceof NonArrayableDeclaration)
						? ('''«pr.type.compileTypes»''' + ((pr.location !== null)
						? ''' «pr.location.type»''' : ""))
						: ""
				} + {
					(PrimaryTypeDeclaration.cast(pr).visibility !== null)
						? ''' «PrimaryTypeDeclaration.cast(pr).visibility.type»''' : ""
				} + {
					(PrimaryTypeDeclaration.cast(pr).name !== null)
						? ''' «PrimaryTypeDeclaration.cast(pr).name»''' : ""
				} + {
					(pr.value !== null)
						? ''' «pr.operator.value» «Expression.cast(pr.value).compileExpression»''' : ""
				}
			}
		}
	}

	def compileLoopStructure(LoopStructures loop) {
		return switch loop {
			IfWhileStructure: loop.compileIfWhileStructure
			,
			ForStructure: loop.compileForStructure
		}
	}

	def compileInternalLoop(LoopStructures str) {
		return '''«FOR el : str.blocks»«el.compileInternalBlock»«ENDFOR»'''
	}

	def compileIfWhileStructure(IfWhileStructure str) {
		return '''«str.type»(«str.condition.compileExpression»)''' + ''' {
	 		«str.compileInternalLoop»
	 	}
	 	'''
	}

	def compileForStructure(ForStructure str) {
		return '''«str.type»(«str.initial.compileIntial» «str.condition.compileExpression»; «str.step.compileSingleDefinition»)''' + ''' {
	 		«str.compileInternalLoop»
	 	}
	 	'''
	}

	def String compileExpression(Expression logic) {
		return {
			(logic.negate)
				? '''!«logic.first.compileCondition» «FOR operation : logic.operations»«operation.compileConditionOperation»«ENDFOR»''': (
					logic.ternary
					)
				? '''«logic.first.compileCondition» ? «logic.^true.compileCondition» : «logic.^false.compileCondition»''' : '''«logic.first.compileCondition»«FOR operation : logic.operations» «operation.compileConditionOperation»«ENDFOR»'''
		}
	}

	def compileCondition(Literal cond) {
		return {
			(cond.ref !== null)
				? '''«cond.ref.compileDeclarationReference»'''
				: switch cond {
				ArithmeticOperations:
					cond.compileArithmeticOperations
				StringLiteral: '''"«cond.value»"'''
				BooleanConst:
					cond.value
				FunctionCall:
					cond.compileFunctionCall
				ArrayAccess:
					cond.compileAccess
				MappingAccess:
					cond.compileAccess
				FieldAccess:
					cond.compileAccess
				SpecialVariablesTypeEnum: '''«cond.name»'''
				BlockhashFunction:
					cond.compileBlockhash
				GasleftFunction: '''«cond.name»'''
				MathematicalFunction:
					cond.compileMathematicalFunction
				HashFunction: '''«cond.compileHashFunction»'''
				EcrecoverFunction:
					cond.compileEcrecoverFunction
			}
		}
	}

	def compileBlockhash(BlockhashFunction block) {
		return '''blockhash(«block.parameter.compileIntParameter»)'''
	}

	def compileMathematicalFunction(MathematicalFunction mat) {
		return '''«mat.function»(«FOR param : mat.parameters SEPARATOR ', '»«param.compileIntParameter»«ENDFOR»)'''
	}

	def compileHashFunction(HashFunction hash) {
		return '''«hash.name»(«hash.parameters.compileIntParameter»)'''
	}

	def compileEcrecoverFunction(EcrecoverFunction ecrecover) {
		return '''«ecrecover.function»(«FOR param : ecrecover.parameters SEPARATOR ', '»«param.compileIntParameter»«ENDFOR»)'''
	}

	def compileIntParameter(IntParameter param) {
		return {
			(param.ref !== null)
				? '''«param.ref.compileDeclarationReference»''' : (param.param !== null)
				? '''«param.param.compileArithmeticOperations»''' : (param.fun !== null)
				? '''«param.fun.compileFunctionCall»''' : ""
		}
	}

	def compileConditionOperation(ConditionOperation op) {
		return '''«op.operation» ''' + {
			(op.negateSecond !== null)
				? '''!''' : ""
		} + {
			(op.seconds !== null)
				? '''«op.seconds.compileCondition»''' : ""
		}
	}

	def compileArithmeticOperations(ArithmeticOperations op) {
		return '''«op.first.compilePrimaryArithmetic»''' +
			'''«FOR operation : op.seconds»«operation.operator»«operation.value.compilePrimaryArithmetic»«ENDFOR»'''
	}

	def compilePrimaryArithmetic(PrimaryArithmetic primary) {
		return switch primary {
			NumericLiteral: primary.compileNumericLiteral
			Expression: primary.compileExpression
		}
	}

	def compileNumericLiteral(NumericLiteral num) {
		return {
			(num.hexValue !== null)
				? '''«num.hexValue.value»''' : (num.decimalValue !== null)
				? '''«num.decimalValue.value»''' : '''«num.intValue.value»'''
		} + {
			(num.etherUnit !== null)
				? ''' «num.etherUnit.compileUnitTypes»''' : ""
		}
	}

	def compileUnitTypes(UnitTypes unit) {
		return {
			(unit.units !== null)
				? '''«unit.units.value»''' : (unit.time !== null)
				? '''«unit.time.value»''' : ""
		}
	}

	def compileDefinitions(EObject obj) {
		return switch obj {
			ArrayDefinition: obj.compileArrayDefinition
			MappingAccess: obj.compileMappingDefinition
			SingleDefinition: obj.compileSingleDefinition
			FieldAccess: obj.compileFieldDefinition
		}
	}

	def compileArrayDefinition(ArrayDefinition array) {
		return {
			'''«ArrayDeclaration.cast(array.ref).name»''' +
				'''«IF array.blocks !== null» = «array.blocks.compileFilledArray»«ENDIF»''' +
				'''«IF array.arrayRef !== null» = «array.arrayRef.compileArrDefinition»«ENDIF»''' +
				'''«FOR index : array.indexes» [«index.value.compileExpression»] «ENDFOR»''' +
				'''«IF array.operator!== null»«array.operator.value»«ENDIF»''' +
				'''«IF array.value!== null»«array.value.compileLogicalOrFilled»«ENDIF»'''
		}
	}

	def compileMappingDefinition(MappingAccess map) {
		return '''«map.compileAccess» = «map.sec.compileLogicalOrFilled»'''
	}

	def compileSingleDefinition(SingleDefinition definition) {
		return {
			(definition.first !== null)
				? '''«definition.first»«definition.name.name»''' : (definition.second !== null)
				? '''«definition.name.name»«definition.second»''' : ""
		}
	}

	def compileLogicalOrFilled(EObject obj) {
		return switch obj {
			Expression: obj.compileExpression
			FilledArray: obj.compileFilledArray
		}
	}

	def compileFieldDefinition(FieldAccess field) {
		return '''«field.compileAccess» = «field.value.compileLogicalOrFilled»'''
	}

	def compileIntial(EObject obj) {
		return switch obj {
			ArrayDefinition: obj.compileArrayDefinition
			MappingAccess: obj.compileMappingDefinition
			FieldAccess: obj.compileFieldDefinition
			Declaration: obj.compileDeclaration
		}
	}

	def compileFunctionCall(FunctionCall call) {
		return '''«call.name.name»(«IF call.parameters !== null»
			«FOR param: call.parameters SEPARATOR ', '»
				«param.compileExpression»
			«ENDFOR»
		«ENDIF»)'''
	}
}
