/*
 * Grammar for Solidity 0.5.2
 * 
 * Language name: osol
 */
grammar org.unicam.myGrammar.OptGrammar with org.eclipse.xtext.common.Terminals

generate optGrammar "http://www.unicam.org/myGrammar/OptGrammar"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ---------- TO DO ----------
/*
 * Controllare gli array
 * Finire i validators
 */
// ---------- TO DO ----------
Model:
	operations+=Contract*;

	/*
 * Solidity:
 * (importDirective+=ImportDirective |
 * contract+=Contract |
 * library+=Library)
 * 
 * ImportDirective:
 * "import" importURI=STRING ";" |
 * "import" "*" "as" unitAlias=ID "from" importURI=STRING ";" |
 * "import" "{" symbolAliases+=SymbolAlias ("," symbolAliases+=SymbolAlias)? "}" "from" importURI=STRING ";";
 * 
 * SymbolAlias:
 * symbol=ID "as" alias=I
 * 
 * ContractOrLibrary:
 * Contract |
 * Library;
 */
Contract:
	"contract" name=ID ("is" inheritanceSpecifiers+=InheritanceSpecifier
	("," inheritanceSpecifiers+=InheritanceSpecifier)*)? body=DefinitionBody;

	/*
 * Library:
 * "library" name=ID ("is" inheritanceSpecifiers+=InheritanceSpecifier
 * ("," inheritanceSpecifiers+=InheritanceSpecifier)*)? body=DefinitionBody;
 */
DefinitionBody:
	{DefinitionBody}
	"{"
	(functions+=FunctionDefinition |
	structs+=StructDefinition |
	enums+=EnumDefinition |
	variables+=VariableDeclaration ";" |
	modifiers+=Modifier |
	events+=Event)*
	"}";

InheritanceSpecifier:
	superType=[Contract] (args=FunctionCallListArguments)?;

FunctionCallListArguments:
	"(" {FunctionCallListArguments} (arguments+=Expression ("," arguments+=Expression)*)? ")";

	// call({arg1: 1, arg2: 2})
FunctionCallArguments:
	"(" "{" {FunctionCallArguments} (args+=FunctionCallArg ("," args+=FunctionCallArg)*)? "}" ")" |
	FunctionCallListArguments;

FunctionCallArg:
	name=ID ":" expr=Expression;

	// Anonymous function allowed when "name" is not specified.
FunctionDefinition:
	"function"
	{FunctionDefinition}
	name=ID?
	parameters=ParameterList
	optionalElements+=FunctionDefinitionOptionalElement*
	("returns" returnParameters=ReturnsParameterList)?
	(block=Body | ";");

FunctionDefinitionOptionalElement:
	Const |
	ModifierInvocation |
	VisibilitySpecifier;

Const:
	"constant" {Const};

VisibilitySpecifier:
	visibility=VisibilityEnum;

StructDefinition:
	"struct" name=ID "{" (members+=VariableDeclaration ";")* "}";

EnumDefinition:
	"enum" name=ID "{" (members+=EnumValue ("," members+=EnumValue)*)? "}";

EnumValue:
	name=ID;

Variable:
	name=ID;

	// Variable Declarations
//----------------------------------------------------------------
VariableDeclaration returns Statement:
	StandardVariableDeclaration |
	VarVariableDeclaration |
	VarVariableTupleVariableDeclaration;

StandardVariableDeclaration:
	type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable
	("=" expression=Expression)?;

VarVariableDeclaration:
	varType=VarType variable=Variable ("=" expression=Expression)?;

VarVariableTupleVariableDeclaration:
	varType=VarType tuple=Tuple ("=" expression=Expression)?;

VariableDeclarationOptionalElement:
	VisibilitySpecifier |
	IndexedSpecifer |
	ConstantSpecifier |
	LocationSpecifier;

IndexedSpecifer:
	"indexed" {IndexedSpecifer};

ConstantSpecifier:
	"constant" {ConstantSpecifier};

LocationSpecifier:
	location=LocationSpecifierEnum;

	// Types
//----------------------------------------------------------------
Type:
	StandardType | isVarType?=VarType;

StandardType:
	ElementaryType dimension=ArrayDimensions? |
	Mapping |
	QualifiedIdentifier;

StandardTypeWithoutQualifiedIdentifier:
	ElementaryType dimension=ArrayDimensions? |
	Mapping;

ElementaryType:
	name=ElementaryTypeNameEnum;

Mapping:
	"mapping" "(" keyType=ElementaryTypeNameEnum "=>" valueType=Type ")";

ArrayDimensions:
	"[" {ArrayDimensions} value+=Expression? "]" ("[" value+=Expression? "]")*;

VarType:
	"var";

	// Tuples
//----------------------------------------------------------------
Tuple:
	"(" {Tuple} (members+=Expression? (members+=TupleSeparator members+=Expression?)+)? ")";

TupleSeparator:
	"," {TupleSeparator};

	// SimpleStatement
//----------------------------------------------------------------
//SimpleStatement:
//    SimpleStatement2 ";"
//;
SimpleStatement:
	(StandardTypeWithoutQualifiedIdentifier ({StandardVariableDeclaration.type=current}
	optionalElements+=VariableDeclarationOptionalElement* variable=Variable ("=" expression=Expression)?) | VarType
	(({VarVariableTypeDeclaration} variable=Variable ("=" expression=Expression)) |
	({VarVariableTupleVariableDeclaration} tuple=Tuple ("=" expression=Expression))) | ExpressionStatement)
	semicolon?=";";

SimpleStatement2:
	(StandardTypeWithoutQualifiedIdentifier ({StandardVariableDeclaration.type=current}
	optionalElements+=VariableDeclarationOptionalElement* variable=Variable ("=" expression=Expression)?) | VarType
	(({VarVariableTypeDeclaration} variable=Variable ("=" expression=Expression)) |
	({VarVariableTupleVariableDeclaration} tuple=Tuple ("=" expression=Expression))) | ExpressionStatement);

ExpressionStatement:
	expression=Expression;

QualifiedIdentifier:
	identifier=ID qualifiers+=Qualifier*;

Qualifier:
	Field |
	Index |
	Arguments;

Field:
	"." field=ID;

Index:
	"[" {Index} value=Expression? "]";

Arguments:
	arguments=FunctionCallArguments;

Modifier:
	"modifier" name=ID parameters=ParameterList? block=Body;

Event:
	"event" name=ID parameters=ParameterList? isAnonymous?="anonymous"? ";";

ModifierInvocation:
	name=[Modifier] args=FunctionCallListArguments?;

ParameterList:
	"(" {ParameterList} (parameters+=VariableDeclaration ("," parameters+=VariableDeclaration)*)? ")";

ReturnsParameterList:
	"(" {ReturnsParameterList} (parameters+=ReturnParameterDeclaration ("," parameters+=ReturnParameterDeclaration)*)?
	")";

ReturnParameterDeclaration:
	typeRef=Type variable=Variable?;

Statement:
	IfStatement |
	WhileStatement |
	ForStatement |
	Body |
	PlaceHolderStatement |
	((ContinueStatement |
	BreakStatement |
	ReturnStatement |
	ThrowStatement |
	DeleteStatement |
	SimpleStatement));

DeleteStatement:
	"delete" variable=QualifiedIdentifier ";";

IfStatement:
	"if" "(" condition=Expression ")" trueBody=Statement (=> "else" falseBody=Statement)?;

WhileStatement:
	"while" "(" condition=Expression ")" body=Statement;

ForStatement:
	"for" "(" initExpression=SimpleStatement2? => ";" conditionExpression=Expression? ";"
	loopExpression=ExpressionStatement? ")" body=Statement;

Body:
	"{" {Block} (statements+=Statement (statements+=Statement)*)? "}";

ContinueStatement:
	"continue" {Continue} ";";

BreakStatement:
	"break" {BreakStatement} ";";

ReturnStatement:
	"return" {ReturnStatement} expression=Expression? ";";

ThrowStatement:
	"throw" {ThrowStatement} ";";

	// Only allowed in a Modifier DAF
PlaceHolderStatement:
	"_" {PlaceHolderStatement};

Expression:
	Assignment;

SpecialExpression:
	type=SpecialExpressionTypeEnum fieldOrMethod=Field? qualifiers+=(Index | Arguments)*;

	// Right associative
Assignment returns Expression:
	BinaryExpression (({Assignment.left=current} assignmentOp=AssignmentOpEnum expression=Expression) |
	({VariableDeclarationExpression.type=current} variable=Variable ("=" expression=Expression)?))?;

BinaryExpression returns Expression:
	Or;

	// Precedence: 4, Left associative
Or returns Expression:
	And ({Or.left=current} "||" right=And)*;

	// Precedence: 5, Left associative
And returns Expression:
	Equality ({And.left=current} "&&" right=Equality)*;

	// Precedence: 6, Left associative
Equality returns Expression:
	Comparison ({Equality.left=current} equalityOp=EqualityOpEnum right=Comparison)*;

	// Precedence: 7, Left associative
Comparison returns Expression:
	BitOr ({Comparison.left=current} comparisonOp=ComparisonOpEnum right=BitOr)*;

	// Precedence: 8, Left associative
BitOr returns Expression:
	BitXor ({BitOr.left=current} "|" right=BitXor)*;

	// Precedence: 9, Left associative
BitXor returns Expression:
	BitAnd ({BitXor.left=current} "^" right=BitAnd)*;

	// Precedence: 10, Left associative
BitAnd returns Expression:
	Shift ({BitAnd.left=current} "&" right=Shift)*;

	// Precedence: 11, Left associative
Shift returns Expression:
	AddSub ({Shift.left=current} shiftOp=ShiftOpEnum right=AddSub)*;

	// Precedence: 12, Left associative
AddSub returns Expression:
	MulDivMod => ({AddSub.left=current} additionOp=AdditionOpEnum right=MulDivMod)*;

	// Precedence: 13, Left associative
MulDivMod returns Expression:
	Exponent ({MulDivMod.left=current} multipliciativeOp=MulDivModOpEnum right=Exponent)*;

	// Precedence: 14, Left associative
Exponent returns Expression:
	UnaryExpression ({Exponent.left=current} "**" right=UnaryExpression)*;

UnaryExpression returns Expression:
	NotExpression |
	BinaryNotExpression |
	SignExpression |
	NewExpression |
	PreExpression;

NotExpression:
	"!" expression=UnaryExpression;

PreIncExpression:
	expression=PostIncDecExpression;

PreDecExpression:
	expression=PostIncDecExpression;

BinaryNotExpression:
	"~" expression=UnaryExpression;

SignExpression:
	signOp=("+" | "-") expression=UnaryExpression;

NewExpression:
	"new" contract=[Contract] args=FunctionCallListArguments;

PreExpression returns Expression:
	PostIncDecExpression |
	("++") PostIncDecExpression ({PreIncExpression.expression=current}) |
	("--") PostIncDecExpression ({PreDecExpression.expression=current});

PostIncDecExpression returns Expression:
	PrimaryExpression ({PostIncDecExpression.expression=current} postOp=IncDecOpEnum)*;

PrimaryExpression returns Expression:
	SpecialExpression |
	QualifiedIdentifier |
	Literal |
	TypeCast |
	"(" Expression ({Tuple.members+=current} (members+=TupleSeparator members+=Expression?)+)? ")" |
	"(" TupleSeparator ({Tuple.members+=current} members+=Expression? (members+=TupleSeparator members+=Expression?)*)
	")" |
	"(" ")" {Tuple};

Literal:
	SpecialLiteral |
	BooleanConst |
	NumericLiteral |
	StringLiteral;

SpecialLiteral:
	name=(BLOCK
	| MSG
	| TX
	| NOW);

BooleanConst:
	value=BooleanLiteralEnum;

NumericLiteral:
	(intValue=IntLiteral
	| hexValue=HexLiteral
	| decimalValue=DecimalLiteral) etherUnit=UnitTypes?;

UnitTypes:
	time=TimeUnitsLiteral
	| units=UnitsLiteral;

IntLiteral:
	value=INT;

HexLiteral:
	value=HEX;

DecimalLiteral:
	value=DECIMAL;

terminal HEX:
	"0x" ("0".."9" | "A".."F" | "a".."f")+;

terminal DECIMAL returns ecore::EDouble:
	INT ("." INT);

StringLiteral:
	value=STRING;

TypeCast:
	value=ElementaryTypeNameEnum "(" expression=Expression ")";

ElementaryTypeNameEnum:
	type=(
	//INT
	"int" | "int16" | "int24" | "int32" | "int40" | "int48" | "int56" | "int64" | "int72" | "int80" | "int88" |
	"int96" | "int104" | "int112" | "int120" | "int128" | "int136" | "int144" | "int152" | "int160" | "int168" |
	"int178" | "int184" | "int192" | "int200" | "int208" | "int216" | "int224" | "int232" | "int240" | "int248" |
	"int256") |
	type=(
	// UINT
	"uint" | "uint8" | "uint16" | "uint24" | "uint32" | "uint40" | "uint48" | "uint56" | "uint64" | "uint72" |
	"uint80" | "uint88" | "uint96" | "uint104" | "uint112" | "uint120" | "uint128" | "uint136" | "uint144" | "uint152" |
	"uint160" | "uint168" | "uint178" | "uint184" | "uint192" | "uint200" | "uint208" | "uint216" | "uint224" |
	"uint232" | "uint240" | "uint248" | "uint256") |
	type=(
	// BYTES
	"bytes1" | "bytes2" | "bytes3" | "bytes4" | "bytes5" | "bytes6" | "bytes7" | "bytes8" | "bytes9" | "bytes10" |
	"bytes11" | "bytes12" | "bytes13" | "bytes14" | "bytes15" | "bytes16" | "bytes17" | "bytes18" | "bytes19" |
	"bytes20" | "bytes21" | "bytes22" | "bytes23" | "bytes24" | "bytes25" | "bytes26" | "bytes27" | "bytes28" |
	"bytes29" | "bytes30" | "bytes31" | "bytes32" | "bytes" | "byte") |
	// Other
	type=("address" | "real" | "ureal");

SimpleTypeDeclaration:
	type=("string" | "bool");

MapLocationLiteral:
	"storage";

LocationSpecifierEnum:
	type=("memory" | MapLocationLiteral | "calldata");

VisibilityEnum:
	type=("public" | "internal" | "private" | "external");

UnitsLiteral:
	value=("wei" | "szabo" | "finney" | "ether");

TimeUnitsLiteral:
	value=("seconds" | "minutes" | "hours" | "days" | "weeks" | "years");

terminal BLOCK:
	"block." ("coinbase" | "difficulty" | "gaslimit" | "number" | "timestamp");

terminal MSG:
	"msg." ("data" | "gas" | "sender" | "sig" | "value");

terminal TX:
	"tx." ("gasprice" | "origin");

terminal NOW:
	"now";

	// Enums
enum AssignmentOpEnum:
	ASSIGN="=" | ASSIGN_OR="|=" | ASSIGN_XOR="^=" | ASSIGN_AND="&=" | ASSIGN_SHIFT_LEFT="<<=" | ASSIGN_SHIFT_RIGHT=">>="
	| ASSIGN_SHIFT_RIGHT_ARIMETIC=">>>=" | ASSIGN_ADD="+=" | ASSIGN_SUB="-=" | ASSIGN_MULT="*=" | ASSIGN_DIV="/=" |
	ASSIGN_MOD="%=";

enum EqualityOpEnum:
	EQ="==" | NOTEQ="!=";

enum ComparisonOpEnum:
	LT="<" | GT=">" | LTE="<=" | GTE=">=" | IN="in";

enum ShiftOpEnum:
	LEFT_SHIFT="<<" | RIGHT_SHIFT=">>" | ARITHMETIC_RIGHT_SHIFT=">>>";

enum AdditionOpEnum:
	ADD="+" | SUB="-";

enum MulDivModOpEnum:
	MULT="*" | DIV="/" | MOD="%";

enum IncDecOpEnum:
	INC="++" | DEC="--";

enum BooleanLiteralEnum:
	TRUE="true" | FALSE="false";

	// Also "EOS" DAF
enum SpecialExpressionTypeEnum:
	SUPER="super" | THIS="this";