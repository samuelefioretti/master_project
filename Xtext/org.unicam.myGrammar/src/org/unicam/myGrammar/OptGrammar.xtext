/*
 * Grammar for Solidity ^0.5.2
 * 
 * Language name: osol
 */
grammar org.unicam.myGrammar.OptGrammar with org.eclipse.xtext.common.Terminals
generate optGrammar "http://www.unicam.org/myGrammar/OptGrammar"

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ---------- TO DO ----------
/*
 * Controllare gli array
 * Controllare le strutture
 * Controllare le functionCall
 */
// ---------- TO DO ----------

// ---------- New grammar ----------
Model:
	operations+=Contract*
;

Contract:
	"contract" name=ID "{" (
		blocks+=Declaration ";" |
		blocks+=FunctionDefinition
	)* "}"
;

Declaration:
	FunctionDeclaration |
	StructDeclaration
;

FunctionDeclaration:
	EnumDefinition |
	FunctionParameterDeclaration
;

StructDeclaration:
	visibility=VisibilityEnum? "struct" name=ID "{" (
		members+=Declaration ";"
	)* "}"
;

EnumDefinition:
	visibility=VisibilityEnum? "enum" name=ID "{" members+=EnumValue ("," members+=EnumValue)* "}"
;

EnumValue:
	name=ID
;

FunctionParameterDeclaration:
	ArrayDefinitionDeclaration |
	MappingDeclaration |
	PrimaryTypeDefinitionDeclaration |
	ConcreteStructureDefinitionDeclaration
;

ArrayDefinitionDeclaration:
	ArrayDeclaration ('=' (
		blocks=FilledArray |
		var = [Declaration] |
		access = (
			MappingAccess |
			ArrayAccess |
			FieldAccess
		)
	))?
;

FilledArray:
	arrays+=ValueSets+
;

ValueSets:
	{ValueSets} ("[]" | "[" (
		values+=LogicalOperations ("," values+=LogicalOperations)*
	)? "]" )
;

ArrayDeclaration:
	location=LocationSpecifierEnum? constant?="constant"? visibility=VisibilityEnum? (
		type=NamedType |
		strucType=[StructDeclaration]
	) name=ID ("[" sizes+=IntLiteral? "]")+
;

NamedType:
	SimpleTypeDeclaration |
	ElementaryTypeNameEnum
;

SimpleTypeDeclaration:
	type=('string' | 'bool')
;

MappingAccess:
	map=[MappingDeclaration] '<(' index=LogicalOperations ')>'
;

ArrayAccess:
	variable=[ArrayDefinitionDeclaration] indexes+=ArrayIndex+ ('.' field=ID)?
;

ArrayIndex:
	 '[' value=LogicalOperations ']'
;

FieldAccess:
	ref=[ConcreteStructDeclaration] '.' field=ID
;

MappingDeclaration:
	location=MapLocationLiteral? visibility=VisibilityEnum? unnamedMappingDeclaration=UnnamedMappingDeclaration name=ID
;

UnnamedMappingDeclaration:
	"mapping" "(" type=NamedType "=>" (
		secondRef=[Declaration] |
		second=(
			NamedType |
			UnnamedMappingDeclaration
		)
	) array?="[]"? ")"
;

PrimaryTypeDefinitionDeclaration:
	(
		PrimaryTypeDeclaration |
		ref=[PrimaryTypeDeclaration]
	)(
		operator=OperationAssegnationLiteral value=(
			LogicalOperations |
			SingleDefinition
		)
	)?
;

PrimaryTypeDeclaration:
	ArrayableDeclaration |
	NonArrayableDeclaration
;

OperationAssegnationLiteral:
	value = ("=" | "*=" | "+=" | "-=" | "/=") 
;

SingleDefinition:
	first=("++" | "--") name=[PrimaryTypeDeclaration] |
	name=[PrimaryTypeDeclaration] second=("++" | "--")
;

NonArrayableDeclaration:
	location=LocationSpecifierEnum? constant?='constant'? visibility=VisibilityEnum? type=SimpleTypeDeclaration name=ID
;

ArrayableDeclaration:
	constant?='constant'? visibility=VisibilityEnum? type=ElementaryTypeNameEnum name=ID
;

ConcreteStructureDefinitionDeclaration:
	"struct" (
		ConcreteStructDeclaration | ref=[ConcreteStructDeclaration]
	) ("=" (
		"{" (couples+=StructureFieldValue) ("," couples+=StructureFieldValue)* "}"
 		| existenceRef=[ConcreteStructDeclaration]
 		| arrayAccessRef=ArrayAccess
 	))?
;

ConcreteStructDeclaration:
	location=LocationSpecifierEnum? constant?="constant"? type=[StructDeclaration] name=ID
;

StructureFieldValue:
	field=ID ":" values=(
		LogicalOperations |
		FilledArray
	)
;

InternalBlock:
	def=(
		ArrayDefinition |
		MappingDefinition |
		SingleDefinition |
		FieldDefinition
	) ";"
	| dec=FunctionDeclaration ";"
	| loop=LoopStructures
	| call=FunctionCall ";"
;

ArrayDefinition:
	ref=[ArrayDefinitionDeclaration] (
		'=' (
				blocks=FilledArray
				| arrayRef=[ArrayDefinitionDeclaration]
			)
	 	| indexes+=ArrayIndex+ ('.' field=ID)? operator=OperationAssegnationLiteral value=(LogicalOperations | FilledArray )
	)
;

FieldDefinition:
	FieldAccess '=' value=(LogicalOperations | SingleDefinition) 
;

MappingDefinition:
	MappingAccess '=' sec=(LogicalOperations | FilledArray)
;
// ---------- End New grammar ----------

// Anonymous function allowed when "name" is not specified.
FunctionDefinition:
	payable?="payable"? "function" name=ID "(" (
		parameters+=(FunctionParameterDeclaration)
		("," parameters+=(FunctionParameterDeclaration))*
	)? ")"
	optionalElements+=FunctionDefinitionOptionalElement*
	("returns" "(" returnType=NamedType ")")?
	"{"
	blocks += InternalBlock*
	returnVal=ReturnStatement?
	"}"
;

/*
FunctionCallListArguments:
	"(" {FunctionCallListArguments} (
			arguments+=LogicalOperations ("," arguments+=LogicalOperations)*
		)?
	")"
;

// call({arg1: 1, arg2: 2})
FunctionCallArguments:
	"("
		"{" {FunctionCallArguments} (
				args+=FunctionCallArg ("," args+=FunctionCallArg)*
			)?
		"}"
	")" |
	FunctionCallListArguments
;

FunctionCallArg:
	name=ID ":" expr=LogicalOperations
;*/

FunctionDefinitionOptionalElement:
	Const |
	//ModifierInvocation |
	VisibilitySpecifier
;

Const:
	"constant" {Const}
;

VisibilitySpecifier:
	visibility=VisibilityEnum
;

Variable:
	name=ID
;
/*
// Variable Declarations
VariableDeclaration returns Statement:
	StandardVariableDeclaration |
	VarVariableDeclaration |
	VarVariableTupleVariableDeclaration
;

StandardVariableDeclaration:
	type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable (
		"=" expression=LogicalOperations
	)?
;

VarVariableDeclaration:
	varType=VarType variable=Variable (
		"=" expression=LogicalOperations
	)?
;

VarVariableTupleVariableDeclaration:
	varType=VarType tuple=Tuple (
		"=" expression=LogicalOperations
	)?
;
*/

VariableDeclarationOptionalElement:
	VisibilitySpecifier |
	IndexedSpecifer |
	ConstantSpecifier |
	LocationSpecifier
;

IndexedSpecifer:
	"indexed" {IndexedSpecifer}
;

ConstantSpecifier:
	 "constant" {ConstantSpecifier}
;

LocationSpecifier:
	location=LocationSpecifierEnum
;

// Types
Type:
	StandardType |
	isVarType?=VarType
;

StandardType:
	ElementaryType dimension=ArrayDimensions? |
	MappingDeclaration |
	QualifiedIdentifier
;

StandardTypeWithoutQualifiedIdentifier:
	ElementaryType dimension=ArrayDimensions? |
	MappingDeclaration
;

ElementaryType:
	name=ElementaryTypeNameEnum
;

ArrayDimensions:
	"[" {ArrayDimensions} value+=LogicalOperations? "]" ("[" value+=LogicalOperations? "]")*
;

VarType:
	"var"
;

// Tuples
Tuple:
	"(" {Tuple} (
		members+=LogicalOperations? (
			members+=TupleSeparator members+=LogicalOperations?
		)+
	)? ")"
;

TupleSeparator:
	"," {TupleSeparator}
;

/*
 * SimpleStatement
 * --------------------
 * SimpleStatement:
 * SimpleStatement2 ";"
 * ;
 */
SimpleStatement:
	(
		StandardTypeWithoutQualifiedIdentifier (
			{StandardVariableDeclaration.type=current} ptionalElements+=VariableDeclarationOptionalElement* variable=Variable ("=" expression=LogicalOperations)?
		) |
		VarType (
			(
				{VarVariableTypeDeclaration} variable=Variable ("=" expression=LogicalOperations)
			) |
			(
				{VarVariableTupleVariableDeclaration} tuple=Tuple ("=" expression=LogicalOperations)
			)
		) |
		ExpressionStatement
	) semicolon?=";"
;

SimpleStatement2:
	(
		StandardTypeWithoutQualifiedIdentifier (
			{StandardVariableDeclaration.type=current} optionalElements+=VariableDeclarationOptionalElement* variable=Variable ("=" expression=LogicalOperations)?
		) |
		VarType (
			(
				{VarVariableTypeDeclaration} variable=Variable ("=" expression=LogicalOperations)
			) |
			(
				{VarVariableTupleVariableDeclaration} tuple=Tuple ("=" expression=LogicalOperations)
			)
		) |
		ExpressionStatement
	)
;

ExpressionStatement:
	expression=LogicalOperations
;

QualifiedIdentifier:
	identifier=ID qualifiers+=Qualifier*
;

Qualifier:
	Field |
	Index |
	Arguments
;

Field:
	"." field=ID
;

Index:
	"[" {Index} value=LogicalOperations? "]"
;

Arguments:
	arguments=FunctionCallArguments
;
/*
 * Modifier:
 "modifier" name=ID parameters=ParameterList? block=Body
;

Event:
	"event" name=ID parameters=ParameterList? ";"
;
*

ModifierInvocation:
	name=[Modifier] args=FunctionCallListArguments?
;*/
/*
ParameterList:
	"("
		{ParameterList} (parameters+=VariableDeclaration (
			"," parameters+=VariableDeclaration)*
		)?
	")"
;
*/
ReturnsParameterList:
	"("
		{ReturnsParameterList} (parameters+=ReturnParameterDeclaration (
			"," parameters+=ReturnParameterDeclaration)*
		)?
	")"
;

ReturnParameterDeclaration:
	typeRef=Type variable=Variable?
;

LoopStructures:
	IfStatement |
	WhileStatement |
	ForStatement
;

Statement:
	LoopStructures |
	Body |
	PlaceHolderStatement |
	(
		(
			ContinueStatement |
			BreakStatement |
			ReturnStatement |
			ThrowStatement |
			DeleteStatement |
			SimpleStatement
		)
	)
;

DeleteStatement:
	"delete" variable=QualifiedIdentifier ";"
;

IfStatement:
	"if" "(" condition=LogicalOperations ")"
	trueBody=Statement (
		=> "else" falseBody=Statement
	)?
;

WhileStatement:
	"while" "(" condition=LogicalOperations ")"
	body=Statement
;

ForStatement:
	"for" "(" initExpression=SimpleStatement2? => ";" conditionExpression=LogicalOperations? ";" loopExpression=ExpressionStatement? ")"
	body=Statement
;

Body:
	"{" {Body} (
		statements+=Statement (statements+=Statement)*
	)? "}"
;

ContinueStatement:
	"continue" {Continue} ";"
;

BreakStatement:
	"break" {BreakStatement} ";"
;

ReturnStatement:
	"return" {ReturnStatement} expression=LogicalOperations? ";"
;

ThrowStatement:
	"throw" {ThrowStatement} ";"
;

// Only allowed in a Modifier DAF
PlaceHolderStatement:
	"_" {PlaceHolderStatement} ";"?
;

LogicalOperations:
	first=Literal operations+=ConditionOperation* |
	negate?="NOT" first=Literal operations+=ConditionOperation* |
	ternary?="TERNARY" first=Literal "?" true=Literal ":" false=Literal
;

ConditionOperation:
	operation=LogicalOperationLiteral negateSecond="NOT"? seconds=Literal
;

Literal:
	SpecialVariables |
	BooleanConst |
	NumericLiteral |
	StringLiteral |
	GasleftFunction |
	BlockhashFunction |
	MathematicalFunction |
	HashFunction |
	EcrecoverFunction
;

GasleftFunction:
	name="gasleft" "(" ")"
;

BlockhashFunction:
	"blockhash" "(" parameter=IntParameter ")"
;

MathematicalFunction:
	function=("addmod" | "mulmod") "("
		parameters+=IntParameter ","
		parameters+=IntParameter ","
		parameters+=IntParameter
	")"
;

EcrecoverFunction:
	function="ecrecover" "("
		parameters+=IntParameter ","
		parameters+=IntParameter ","
		parameters+=IntParameter ","
		parameters+=IntParameter
	")"
;

HashFunction:
	name=("keccak256" | "sha256" | "ripemd160") "(" parameters=IntParameter ")"
;

IntParameter:
	param=ArithmeticOperations |
	fun=FunctionCall
;

FunctionCall:
	name=[FunctionDefinition] "(" (
		parameters+=LogicalOperations ("," parameters+=LogicalOperations)*
	)? ")"
;

ArithmeticOperations:
	first=PrimaryArithmetic seconds+=(SecondOperators)*;

PrimaryArithmetic:
	NumericLiteral |
	"(" LogicalOperations ")"
;

SecondOperators:
	operator=("+" | "-" | "/" | "*") value=PrimaryArithmetic
;
	
BooleanConst:
	value=BooleanLiteralEnum
;

NumericLiteral:
	(
		intValue=NumberDimensionless |
		hexValue=HexLiteral |
		decimalValue=DecimalLiteral |
		now=Now
	) etherUnit=UnitTypes?
;

Now:
	{Now} "now"
;

UnitTypes:
	time=Time |
	units=Ether
;

NumberDimensionless:
	value=INT
;

Ether:
	value=INT ether=EtherSubDenominationEnum
;

Time:
	value=INT time=TimeSubdenominationEnum
;

StringLiteral:
	value=STRING
;

IntLiteral:
	value=INT
;

HexLiteral:
	value=HEX
;

DecimalLiteral:
	value=DECIMAL
;

TypeCast:
	value=ElementaryTypeNameEnum "("
		expression=LogicalOperations
	")"
;

SpecialVariables:
	type=SpecialVariablesTypeEnum "." field=ID qualifiers+=Qualifier*
;

terminal HEX:
	"0x" ("0".."9"|"A".."F"|"a".."f")+
;

terminal DECIMAL returns ecore::EDouble:
	INT("." INT)
;

ElementaryTypeNameEnum:
	type=(
	"int" |
	"int16" |
	"int24" |
	"int32" |
	"int40" |
	"int48" |
	"int56" |
	"int64" |
	"int72" |
	"int80" |
	"int88" |
	"int96" |
	"int104" |
	"int112" |
	"int120" |
	"int128" |
	"int136" |
	"int144" |
	"int152" |
	"int160" |
	"int168" |
	"int178" |
	"int184" |
	"int192" |
	"int200" |
	"int208" |
	"int216" |
	"int224" |
	"int232" |
	"int240" |
	"int248" |
	"int256" |
	// UINT
	"uint" |
	"uint8" |
	"uint16" |
	"uint24" |
	"uint32" |
	"uint40" |
	"uint48" |
	"uint56" |
	"uint64" |
	"uint72" |
	"uint80" |
	"uint88" |
	"uint96" |
	"uint104" |
	"uint112" |
	"uint120" |
	"uint128" |
	"uint136" |
	"uint144" |
	"uint152" |
	"uint160" |
	"uint168" |
	"uint178" |
	"uint184" |
	"uint192" |
	"uint200" |
	"uint208" |
	"uint216" |
	"uint224" |
	"uint232" |
	"uint240" |
	"uint248" |
	"uint256" |
	// BYTE
	"byte" |
	"bytes" |
	"bytes1" |
	"bytes2" |
	"bytes3" |
	"bytes4" |
	"bytes5" |
	"bytes6" |
	"bytes7" |
	"bytes8" |
	"bytes9" |
	"bytes10" |
	"bytes11" |
	"bytes12" |
	"bytes13" |
	"bytes14" |
	"bytes15" |
	"bytes16" |
	"bytes17" |
	"bytes18" |
	"bytes19" |
	"bytes20" |
	"bytes21" |
	"bytes22" |
	"bytes23" |
	"bytes24" |
	"bytes25" |
	"bytes26" |
	"bytes27" |
	"bytes28" |
	"bytes29" |
	"bytes30" |
	"bytes31" |
	"bytes32" |
	// Other
	"string" |
	"address" |
	"bool" |
	"real" |
	"ureal"
	)
;

MapLocationLiteral:
	"storage"
;

LocationSpecifierEnum:
	type= ("memory" | MapLocationLiteral | "calldata")
;

VisibilityEnum:
	type=("public" | "internal" | "private" | "external")
;

// Enums
enum LogicalOperationLiteral:
	NOTEQUAL="!=" |
	EQUAL="==" |
	AND="&&" |
	OR="||" |
	GTE=">=" |
	LTE="<=" |
	GT=">" |
	LT="<"
;

enum AssignmentOpEnum:
	ASSIGN="=" |
	ASSIGN_OR="|=" |
	ASSIGN_XOR="^=" |
	ASSIGN_AND="&=" |
	ASSIGN_SHIFT_LEFT="<<=" |
	ASSIGN_SHIFT_RIGHT=">>=" |
	ASSIGN_SHIFT_RIGHT_ARIMETIC=">>>=" |
	ASSIGN_ADD="+=" |
	ASSIGN_SUB="-=" |
	ASSIGN_MULT="*=" |
	ASSIGN_DIV="/=" |
	ASSIGN_MOD="%="
;

enum EqualityOpEnum:
	EQ="==" |
	NOTEQ="!="
;

enum ComparisonOpEnum:
	LT="<" |
	GT=">" |
	LTE="<=" |
	GTE=">=" |
	IN="in"
;

enum ShiftOpEnum:
	LEFT_SHIFT="<<" |
	RIGHT_SHIFT=">>" |
	ARITHMETIC_RIGHT_SHIFT=">>>"
;

enum AdditionOpEnum:
	ADD="+" |
	SUB="-"
;

enum MulDivModOpEnum:
	MULT="*" |
	DIV="/" |
	MOD="%"
;

enum IncDecOpEnum:
	INC="++" |
	DEC="--"
;

enum BooleanLiteralEnum:
	TRUE="true" |
	FALSE="false"
;

enum EtherSubDenominationEnum:
	WEI="wei" |
	SZABO="szabo" |
	FINNEY="finney" |
	ETHER="ether"
;

enum TimeSubdenominationEnum:
	SECONDS="seconds" |
	MINUTES="minutes" |
	HOURS="hours" |
	DAYS="days" |
	WEEKS="weeks" |
	YEARS="years"
;

// Also "EOS" DAF
SpecialVariablesTypeEnum:
	name=(
		BLOCK |
		MSG |
		TX
	)
;

terminal BLOCK:
	"block." (
		"coinbase" |
		"difficulty" |
		"gaslimit" |
		"number" |
		"timestamp"
	)
;

terminal MSG:
	"msg." (
		"data" |
		"gas" |
		"sender" |
		"sig" |
		"value"
	)
;

terminal TX:
	"tx." (
		"gasprice" |
		"origin"
	)
;

enum SpecialExpressionTypeEnum:
	SUPER="super" |
	THIS="this"
;

enum ReservedWordsEnum:
	AS="as" |
	CASE="case" |
	CATCH="catch" |
	FINAL="final" |
	LET="let" |
	MATCH="match" |
	OF="of" |
	RELOCATABLE="relocatable" |
	SWITCH="switch" |
	TRY="try" |
	TYPE="type" |
	TYPEOF="typeof" |
	USING="using" |
	ILLEGAL="ILLEGAL"
;