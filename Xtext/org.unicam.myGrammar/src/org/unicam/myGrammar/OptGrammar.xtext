/*
 * Grammar for Solidity 0.5.2
 * 
 * Language name: osol
 */
grammar org.unicam.myGrammar.OptGrammar with org.eclipse.xtext.common.Terminals

generate optGrammar "http://www.unicam.org/myGrammar/OptGrammar"
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

// ---------- TO DO ----------
/*
 * Controllare gli array
 * Controllare le strutture
 */
Solidity:
	(importDirective+=ImportDirective |
	contract+=Contract)*;

ImportDirective:
	"import" importURI=STRING ";" |
	"import" "*" "as" unitAlias=ID "from" importURI=STRING ";" |
	"import" "{" symbolAliases+=SymbolAlias ("," symbolAliases+=SymbolAlias)? "}" "from" importURI=STRING ";";

SymbolAlias:
	symbol=ID "as" alias=ID;

Contract:
	"contract" name=ID (inheritanceSpecifiers+=InheritanceSpecifier
	("," inheritanceSpecifiers+=InheritanceSpecifier)*)?
	body=DefinitionBody;

InheritanceSpecifier:
	SuperType=Contract (args=FunctionCallListArguments)?;

DefinitionBody:
	{DefinitionBody} "{" (functions+=FunctionDefinition |
	structs+=StructDefinition |
	enums+=EnumDefinition |
	variables+=VariableDeclaration ";" |
	modifiers+=Modifier |
	events+=Event)* "}";

	// Anonymous function allowed when "name" is not specified.
FunctionDefinition:
	payable?='payable'? "function" name=ID parameters=ParameterList optionalElements+=FunctionDefinitionOptionalElement*
	("returns" returnParameters=ReturnsParameterList)?
	(block=Body |
	";");

FunctionCallListArguments:
	"(" {FunctionCallListArguments} (arguments+=Expression ("," arguments+=Expression)*)?
	")";

	// call({arg1: 1, arg2: 2})
FunctionCallArguments:
	"("
	"{" {FunctionCallArguments} (args+=FunctionCallArg ("," args+=FunctionCallArg)*)?
	"}"
	")" |
	FunctionCallListArguments;

FunctionCallArg:
	name=ID ":" expr=Expression;

FunctionDefinitionOptionalElement:
	Const |
	ModifierInvocation |
	VisibilitySpecifier;

Const:
	"constant" {Const};

VisibilitySpecifier:
	visibility=VisibilityEnum;

StructDefinition:
	visibility=VisibilityEnum? "struct" name=ID "{"
	(members+=VariableDeclaration ";")*
	"}";

EnumDefinition:
	visibility=VisibilityEnum? "enum" name=ID "{"
	(members+=EnumValue ("," members+=EnumValue)*)?
	"}";

EnumValue:
	name=ID;

Variable:
	name=ID;

	// Variable Declarations
VariableDeclaration returns Statement:
	StandardVariableDeclaration |
	VarVariableDeclaration |
	VarVariableTupleVariableDeclaration;

StandardVariableDeclaration:
	type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable ("="
	expression=Expression)?;

VarVariableDeclaration:
	varType=VarType variable=Variable ("=" expression=Expression)?;

VarVariableTupleVariableDeclaration:
	varType=VarType tuple=Tuple ("=" expression=Expression)?;

VariableDeclarationOptionalElement:
	VisibilitySpecifier |
	IndexedSpecifer |
	ConstantSpecifier |
	LocationSpecifier;

IndexedSpecifer:
	"indexed" {IndexedSpecifer};

ConstantSpecifier:
	"constant" {ConstantSpecifier};

LocationSpecifier:
	location=LocationSpecifierEnum;

	// Types
Type:
	StandardType | isVarType?=VarType;

StandardType:
	ElementaryType dimension=ArrayDimensions? |
	Mapping |
	QualifiedIdentifier;

StandardTypeWithoutQualifiedIdentifier:
	ElementaryType dimension=ArrayDimensions? |
	Mapping;

ElementaryType:
	name=ElementaryTypeNameEnum;

Mapping:
	"mapping" "("
	keyType=ElementaryTypeNameEnum "=>" valueType=Type
	")";

ArrayDimensions:
	"[" {ArrayDimensions} value+=Expression? "]" ("[" value+=Expression? "]")*;

VarType:
	"var";

	// Tuples
Tuple:
	"("
	{Tuple} (members+=Expression? (members+=TupleSeparator members+=Expression?)+)?
	")";

TupleSeparator:
	"," {TupleSeparator};

	// SimpleStatement
// ---------------------
// SimpleStatement:
// SimpleStatement2 ";"
// ;
SimpleStatement:
	(StandardTypeWithoutQualifiedIdentifier ({StandardVariableDeclaration.type=current}
	ptionalElements+=VariableDeclarationOptionalElement* variable=Variable ("=" expression=Expression)?) |
	VarType (({VarVariableTypeDeclaration} variable=Variable ("=" expression=Expression)) |
	({VarVariableTupleVariableDeclaration} tuple=Tuple ("=" expression=Expression))) |
	ExpressionStatement) semicolon?=";";

SimpleStatement2:
	(StandardTypeWithoutQualifiedIdentifier ({StandardVariableDeclaration.type=current}
	optionalElements+=VariableDeclarationOptionalElement* variable=Variable ("=" expression=Expression)?) |
	VarType (({VarVariableTypeDeclaration} variable=Variable ("=" expression=Expression)) |
	({VarVariableTupleVariableDeclaration} tuple=Tuple ("=" expression=Expression))) |
	ExpressionStatement);

ExpressionStatement:
	expression=Expression;

QualifiedIdentifier:
	identifier=ID qualifiers+=Qualifier*;

Qualifier:
	Field |
	Index |
	Arguments;

Field:
	"." field=ID;

Index:
	"[" {Index} value=Expression? "]";

Arguments:
	arguments=FunctionCallArguments;

Modifier:
	"modifier" name=ID parameters=ParameterList? block=Body;

Event:
	"event" name=ID parameters=ParameterList? ";";

ModifierInvocation:
	name=[Modifier] args=FunctionCallListArguments?;

ParameterList:
	"("
	{ParameterList} (parameters+=VariableDeclaration ("," parameters+=VariableDeclaration)*)?
	")";

ReturnsParameterList:
	"("
	{ReturnsParameterList} (parameters+=ReturnParameterDeclaration ("," parameters+=ReturnParameterDeclaration)*)?
	")";

ReturnParameterDeclaration:
	typeRef=Type variable=Variable?;

Statement:
	IfStatement |
	WhileStatement |
	ForStatement |
	Body |
	PlaceHolderStatement |
	((ContinueStatement |
	BreakStatement |
	ReturnStatement |
	ThrowStatement |
	DeleteStatement |
	SimpleStatement));

DeleteStatement:
	"delete" variable=QualifiedIdentifier ";";

IfStatement:
	"if" "(" condition=Expression ")"
	trueBody=Statement (=> "else" falseBody=Statement)?;

WhileStatement:
	"while" "(" condition=Expression ")"
	body=Statement;

ForStatement:
	"for" "(" initExpression=SimpleStatement2? => ";" conditionExpression=Expression? ";"
	loopExpression=ExpressionStatement? ")"
	body=Statement;

Body:
	"{"
	{Block} (statements+=Statement (statements+=Statement)*)?
	"}";

ContinueStatement:
	"continue" {Continue} ";";

BreakStatement:
	"break" {BreakStatement} ";";

ReturnStatement:
	"return" {ReturnStatement} expression=Expression? ";";

ThrowStatement:
	"throw" {ThrowStatement} ";";

	// Only allowed in a Modifier DAF
PlaceHolderStatement:
	"_" {PlaceHolderStatement};

Expression:
	first=Literal operations+=ConditionOperation*
	| negate?='NOT' first=Literal operations+=ConditionOperation*
	| ternary?='TERNARY' first=Literal '?' true=Literal ':' false=Literal
;

ConditionOperation:
	operation=LogicalOperationLiteral negateSecond='NOT'? seconds=Literal
;

enum LogicalOperationLiteral:
	NOTEQUAL=	'!='
	| EQUAL=	'=='
	| AND=		'&&'
	| OR=		'||'
	| GTE=		'>='
	| LTE=		'<='
	| GT=		'>'
	| LT=		'<'
;

Literal:
	SpecialVariables |
	BooleanConst |
	NumericLiteral |
	StringLiteral |
	GasleftFunction |
	BlockhashFunction |
	MathematicalFunction |
	HashFunction |
	EcrecoverFunction;

GasleftFunction:
	name='gasleft' '(' ')';

BlockhashFunction:
	'blockhash' '(' parameter=IntParameter ')';

MathematicalFunction:
	function=('addmod' | 'mulmod') '('
	parameters+=IntParameter ','
	parameters+=IntParameter ','
	parameters+=IntParameter
	')';

EcrecoverFunction:
	function='ecrecover' '('
	parameters+=IntParameter ','
	parameters+=IntParameter ','
	parameters+=IntParameter ','
	parameters+=IntParameter
	')';

HashFunction:
	name=('keccak256' | 'sha256' | 'ripemd160') '(' parameters=IntParameter ')';

IntParameter:
	param=ArithmeticOperations |
	fun=FunctionCall;

FunctionCall:
	name=[FunctionDefinition] '(' (parameters+=Expression (',' parameters+=Expression)*)? ')';

ArithmeticOperations:
	first=PrimaryArithmetic seconds+=(SecondOperators)*;

PrimaryArithmetic:
	NumericLiteral |
	'(' Expression ')';

SecondOperators:
	operator=('+' | '-' | '/' | '*') value=PrimaryArithmetic;

BooleanConst:
	value=BooleanLiteralEnum;

NumericLiteral:
	(intValue=NumberDimensionless |
	hexValue=HexLiteral |
	decimalValue=DecimalLiteral |
	now=Now) etherUnit=UnitTypes?;

Now:
	{Now} "now";

UnitTypes:
	time=Time |
	units=Ether;

NumberDimensionless:
	value=INT;

Ether:
	value=INT ether=EtherSubDenominationEnum;

Time:
	value=INT time=TimeSubdenominationEnum;

StringLiteral:
	value=STRING;

HexLiteral:
	value=HEX;

DecimalLiteral:
	value=DECIMAL;

TypeCast:
	value=ElementaryTypeNameEnum "("
	expression=Expression
	")";

SpecialVariables:
	type=SpecialVariablesTypeEnum "." field=ID qualifiers+=Qualifier*;

terminal HEX:
	'0x' ('0'..'9' | 'A'..'F' | 'a'..'f')+;

terminal DECIMAL returns ecore::EDouble:
	INT ('.' INT);

	// Enums
ElementaryTypeNameEnum:
	type=("int" | "int16" | "int24" | "int32" | "int40" | "int48" | "int56" | "int64" |
	"int72" |
	"int80" |
	"int88" |
	"int96" |
	"int104" |
	"int112" |
	"int120" |
	"int128" |
	"int136" |
	"int144" |
	"int152" |
	"int160" |
	"int168" |
	"int178" |
	"int184" |
	"int192" |
	"int200" |
	"int208" |
	"int216" |
	"int224" |
	"int232" |
	"int240" |
	"int248" |
	"int256") | type=(
	// UINT
	"uint" |
	"uint8" |
	"uint16" |
	"uint24" |
	"uint32" |
	"uint40" |
	"uint48" |
	"uint56" |
	"uint64" |
	"uint72" |
	"uint80" |
	"uint88" |
	"uint96" |
	"uint104" |
	"uint112" |
	"uint120" |
	"uint128" |
	"uint136" |
	"uint144" |
	"uint152" |
	"uint160" |
	"uint168" |
	"uint178" |
	"uint184" |
	"uint192" |
	"uint200" |
	"uint208" |
	"uint216" |
	"uint224" |
	"uint232" |
	"uint240" |
	"uint248" |
	"uint256") | type=(
	// BYTE
	"byte" |
	"bytes" |
	"bytes1" |
	"bytes2" |
	"bytes3" |
	"bytes4" |
	"bytes5" |
	"bytes6" |
	"bytes7" |
	"bytes8" |
	"bytes9" |
	"bytes10" |
	"bytes11" |
	"bytes12" |
	"bytes13" |
	"bytes14" |
	"bytes15" |
	"bytes16" |
	"bytes17" |
	"bytes18" |
	"bytes19" |
	"bytes20" |
	"bytes21" |
	"bytes22" |
	"bytes23" |
	"bytes24" |
	"bytes25" |
	"bytes26" |
	"bytes27" |
	"bytes28" |
	"bytes29" |
	"bytes30" |
	"bytes31" |
	"bytes32") | type=(
	// Other
	"string" |
	"address" |
	"bool" |
	"real" |
	"ureal"
	)
;
enum LocationSpecifierEnum:
	MEMORY="memory" |
	STORAGE="storage" |
	CALLDATA="calldata";
enum VisibilityEnum:
	PUBLIC="public" |
	INTERNAL="internal" |
	PRIVATE="private" |
	EXTERNAL="external";
enum AssignmentOpEnum:
	ASSIGN="=" |
	ASSIGN_OR="|=" |
	ASSIGN_XOR="^=" |
	ASSIGN_AND="&=" |
	ASSIGN_SHIFT_LEFT="<<=" |
	ASSIGN_SHIFT_RIGHT=">>=" |
	ASSIGN_SHIFT_RIGHT_ARIMETIC=">>>=" |
	ASSIGN_ADD="+=" |
	ASSIGN_SUB="-=" |
	ASSIGN_MULT="*=" |
	ASSIGN_DIV="/=" |
	ASSIGN_MOD="%=";
enum EqualityOpEnum:
	EQ="==" |
	NOTEQ="!=";
enum ComparisonOpEnum:
	LT="<" |
	GT=">" |
	LTE="<=" |
	GTE=">=" |
	IN="in";
enum ShiftOpEnum:
	LEFT_SHIFT="<<" |
	RIGHT_SHIFT=">>" |
	ARITHMETIC_RIGHT_SHIFT=">>>";
enum AdditionOpEnum:
	ADD="+" |
	SUB="-";
enum MulDivModOpEnum:
	MULT="*" |
	DIV="/" |
	MOD="%";
enum IncDecOpEnum:
	INC="++" |
	DEC="--";
enum BooleanLiteralEnum:
	TRUE="true" |
	FALSE="false";
enum EtherSubDenominationEnum:
	WEI="wei" |
	SZABO="szabo" |
	FINNEY="finney" |
	ETHER="ether";
enum TimeSubdenominationEnum:
	SECONDS="seconds" |
	MINUTES="minutes" |
	HOURS="hours" |
	DAYS="days" |
	WEEKS="weeks" |
	YEARS="years";

	// Also "EOS" DAF
SpecialVariablesTypeEnum:
	name=(BLOCK |
	MSG |
	TX);
terminal BLOCK:
	'block.' ('coinbase' |
	'difficulty' |
	'gaslimit' |
	'number' |
	'timestamp');
terminal MSG:
	'msg.' ('data' |
	'gas' |
	'sender' |
	'sig' |
	'value');
terminal TX:
	'tx.' ('gasprice' |
	'origin');
enum SpecialExpressionTypeEnum:
	SUPER="super" |
	THIS="this";
enum ReservedWordsEnum:
	AS="as" |
	CASE="case" |
	CATCH="catch" |
	FINAL="final" |
	LET="let" |
	MATCH="match" |
	OF="of" |
	RELOCATABLE="relocatable" |
	SWITCH="switch" |
	TRY="try" |
	TYPE="type" |
	TYPEOF="typeof" |
	USING="using" |
	ILLEGAL="ILLEGAL";