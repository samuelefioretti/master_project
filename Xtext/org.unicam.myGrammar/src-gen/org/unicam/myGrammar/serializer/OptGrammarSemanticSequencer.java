/*
 * generated by Xtext 2.19.0
 */
package org.unicam.myGrammar.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unicam.myGrammar.optGrammar.Arguments;
import org.unicam.myGrammar.optGrammar.ArithmeticOperations;
import org.unicam.myGrammar.optGrammar.ArrayDimensions;
import org.unicam.myGrammar.optGrammar.BlockhashFunction;
import org.unicam.myGrammar.optGrammar.Body;
import org.unicam.myGrammar.optGrammar.BooleanConst;
import org.unicam.myGrammar.optGrammar.BreakStatement;
import org.unicam.myGrammar.optGrammar.ConditionOperation;
import org.unicam.myGrammar.optGrammar.Const;
import org.unicam.myGrammar.optGrammar.ConstantSpecifier;
import org.unicam.myGrammar.optGrammar.Continue;
import org.unicam.myGrammar.optGrammar.Contract;
import org.unicam.myGrammar.optGrammar.DecimalLiteral;
import org.unicam.myGrammar.optGrammar.DeleteStatement;
import org.unicam.myGrammar.optGrammar.EcrecoverFunction;
import org.unicam.myGrammar.optGrammar.ElementaryType;
import org.unicam.myGrammar.optGrammar.ElementaryTypeNameEnum;
import org.unicam.myGrammar.optGrammar.EnumDefinition;
import org.unicam.myGrammar.optGrammar.EnumValue;
import org.unicam.myGrammar.optGrammar.Ether;
import org.unicam.myGrammar.optGrammar.Event;
import org.unicam.myGrammar.optGrammar.Expression;
import org.unicam.myGrammar.optGrammar.ExpressionStatement;
import org.unicam.myGrammar.optGrammar.Field;
import org.unicam.myGrammar.optGrammar.ForStatement;
import org.unicam.myGrammar.optGrammar.FunctionCall;
import org.unicam.myGrammar.optGrammar.FunctionCallArg;
import org.unicam.myGrammar.optGrammar.FunctionCallArguments;
import org.unicam.myGrammar.optGrammar.FunctionCallListArguments;
import org.unicam.myGrammar.optGrammar.FunctionDefinition;
import org.unicam.myGrammar.optGrammar.GasleftFunction;
import org.unicam.myGrammar.optGrammar.HashFunction;
import org.unicam.myGrammar.optGrammar.HexLiteral;
import org.unicam.myGrammar.optGrammar.IfStatement;
import org.unicam.myGrammar.optGrammar.Index;
import org.unicam.myGrammar.optGrammar.IndexedSpecifer;
import org.unicam.myGrammar.optGrammar.IntParameter;
import org.unicam.myGrammar.optGrammar.LocationSpecifier;
import org.unicam.myGrammar.optGrammar.LocationSpecifierEnum;
import org.unicam.myGrammar.optGrammar.Mapping;
import org.unicam.myGrammar.optGrammar.MathematicalFunction;
import org.unicam.myGrammar.optGrammar.Model;
import org.unicam.myGrammar.optGrammar.Modifier;
import org.unicam.myGrammar.optGrammar.ModifierInvocation;
import org.unicam.myGrammar.optGrammar.Now;
import org.unicam.myGrammar.optGrammar.NumberDimensionless;
import org.unicam.myGrammar.optGrammar.NumericLiteral;
import org.unicam.myGrammar.optGrammar.OptGrammarPackage;
import org.unicam.myGrammar.optGrammar.ParameterList;
import org.unicam.myGrammar.optGrammar.PlaceHolderStatement;
import org.unicam.myGrammar.optGrammar.QualifiedIdentifier;
import org.unicam.myGrammar.optGrammar.ReturnParameterDeclaration;
import org.unicam.myGrammar.optGrammar.ReturnStatement;
import org.unicam.myGrammar.optGrammar.ReturnsParameterList;
import org.unicam.myGrammar.optGrammar.SecondOperators;
import org.unicam.myGrammar.optGrammar.SpecialVariables;
import org.unicam.myGrammar.optGrammar.SpecialVariablesTypeEnum;
import org.unicam.myGrammar.optGrammar.StandardVariableDeclaration;
import org.unicam.myGrammar.optGrammar.StringLiteral;
import org.unicam.myGrammar.optGrammar.StructDefinition;
import org.unicam.myGrammar.optGrammar.ThrowStatement;
import org.unicam.myGrammar.optGrammar.Time;
import org.unicam.myGrammar.optGrammar.Tuple;
import org.unicam.myGrammar.optGrammar.TupleSeparator;
import org.unicam.myGrammar.optGrammar.Type;
import org.unicam.myGrammar.optGrammar.TypeCast;
import org.unicam.myGrammar.optGrammar.UnitTypes;
import org.unicam.myGrammar.optGrammar.VarVariableDeclaration;
import org.unicam.myGrammar.optGrammar.VarVariableTupleVariableDeclaration;
import org.unicam.myGrammar.optGrammar.VarVariableTypeDeclaration;
import org.unicam.myGrammar.optGrammar.Variable;
import org.unicam.myGrammar.optGrammar.VisibilityEnum;
import org.unicam.myGrammar.optGrammar.VisibilitySpecifier;
import org.unicam.myGrammar.optGrammar.WhileStatement;
import org.unicam.myGrammar.services.OptGrammarGrammarAccess;

@SuppressWarnings("all")
public class OptGrammarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OptGrammarGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OptGrammarPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OptGrammarPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case OptGrammarPackage.ARITHMETIC_OPERATIONS:
				sequence_ArithmeticOperations(context, (ArithmeticOperations) semanticObject); 
				return; 
			case OptGrammarPackage.ARRAY_DIMENSIONS:
				sequence_ArrayDimensions(context, (ArrayDimensions) semanticObject); 
				return; 
			case OptGrammarPackage.BLOCKHASH_FUNCTION:
				sequence_BlockhashFunction(context, (BlockhashFunction) semanticObject); 
				return; 
			case OptGrammarPackage.BODY:
				sequence_Body(context, (Body) semanticObject); 
				return; 
			case OptGrammarPackage.BOOLEAN_CONST:
				sequence_BooleanConst(context, (BooleanConst) semanticObject); 
				return; 
			case OptGrammarPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case OptGrammarPackage.CONDITION_OPERATION:
				sequence_ConditionOperation(context, (ConditionOperation) semanticObject); 
				return; 
			case OptGrammarPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case OptGrammarPackage.CONSTANT_SPECIFIER:
				sequence_ConstantSpecifier(context, (ConstantSpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.CONTINUE:
				sequence_ContinueStatement(context, (Continue) semanticObject); 
				return; 
			case OptGrammarPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case OptGrammarPackage.DECIMAL_LITERAL:
				sequence_DecimalLiteral(context, (DecimalLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.DELETE_STATEMENT:
				sequence_DeleteStatement(context, (DeleteStatement) semanticObject); 
				return; 
			case OptGrammarPackage.ECRECOVER_FUNCTION:
				sequence_EcrecoverFunction(context, (EcrecoverFunction) semanticObject); 
				return; 
			case OptGrammarPackage.ELEMENTARY_TYPE:
				if (rule == grammarAccess.getElementaryTypeRule()) {
					sequence_ElementaryType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStandardTypeWithoutQualifiedIdentifierRule()
						|| action == grammarAccess.getSimpleStatementAccess().getStandardVariableDeclarationTypeAction_0_0_1_0()
						|| action == grammarAccess.getSimpleStatement2Access().getStandardVariableDeclarationTypeAction_0_1_0()) {
					sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getStandardTypeRule()) {
					sequence_ElementaryType_StandardType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.ELEMENTARY_TYPE_NAME_ENUM:
				sequence_ElementaryTypeNameEnum(context, (ElementaryTypeNameEnum) semanticObject); 
				return; 
			case OptGrammarPackage.ENUM_DEFINITION:
				sequence_EnumDefinition(context, (EnumDefinition) semanticObject); 
				return; 
			case OptGrammarPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case OptGrammarPackage.ETHER:
				sequence_Ether(context, (Ether) semanticObject); 
				return; 
			case OptGrammarPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case OptGrammarPackage.EXPRESSION:
				sequence_Expression(context, (Expression) semanticObject); 
				return; 
			case OptGrammarPackage.EXPRESSION_STATEMENT:
				if (rule == grammarAccess.getSimpleStatement2Rule()
						|| rule == grammarAccess.getExpressionStatementRule()) {
					sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ExpressionStatement_SimpleStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case OptGrammarPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL_ARG:
				sequence_FunctionCallArg(context, (FunctionCallArg) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL_ARGUMENTS:
				sequence_FunctionCallArguments(context, (FunctionCallArguments) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL_LIST_ARGUMENTS:
				sequence_FunctionCallListArguments(context, (FunctionCallListArguments) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case OptGrammarPackage.GASLEFT_FUNCTION:
				sequence_GasleftFunction(context, (GasleftFunction) semanticObject); 
				return; 
			case OptGrammarPackage.HASH_FUNCTION:
				sequence_HashFunction(context, (HashFunction) semanticObject); 
				return; 
			case OptGrammarPackage.HEX_LITERAL:
				sequence_HexLiteral(context, (HexLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case OptGrammarPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case OptGrammarPackage.INDEXED_SPECIFER:
				sequence_IndexedSpecifer(context, (IndexedSpecifer) semanticObject); 
				return; 
			case OptGrammarPackage.INT_PARAMETER:
				sequence_IntParameter(context, (IntParameter) semanticObject); 
				return; 
			case OptGrammarPackage.LOCATION_SPECIFIER:
				sequence_LocationSpecifier(context, (LocationSpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.LOCATION_SPECIFIER_ENUM:
				sequence_LocationSpecifierEnum(context, (LocationSpecifierEnum) semanticObject); 
				return; 
			case OptGrammarPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case OptGrammarPackage.MATHEMATICAL_FUNCTION:
				sequence_MathematicalFunction(context, (MathematicalFunction) semanticObject); 
				return; 
			case OptGrammarPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case OptGrammarPackage.MODIFIER:
				sequence_Modifier(context, (Modifier) semanticObject); 
				return; 
			case OptGrammarPackage.MODIFIER_INVOCATION:
				sequence_ModifierInvocation(context, (ModifierInvocation) semanticObject); 
				return; 
			case OptGrammarPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case OptGrammarPackage.NUMBER_DIMENSIONLESS:
				sequence_NumberDimensionless(context, (NumberDimensionless) semanticObject); 
				return; 
			case OptGrammarPackage.NUMERIC_LITERAL:
				sequence_NumericLiteral(context, (NumericLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case OptGrammarPackage.PLACE_HOLDER_STATEMENT:
				sequence_PlaceHolderStatement(context, (PlaceHolderStatement) semanticObject); 
				return; 
			case OptGrammarPackage.QUALIFIED_IDENTIFIER:
				sequence_QualifiedIdentifier(context, (QualifiedIdentifier) semanticObject); 
				return; 
			case OptGrammarPackage.RETURN_PARAMETER_DECLARATION:
				sequence_ReturnParameterDeclaration(context, (ReturnParameterDeclaration) semanticObject); 
				return; 
			case OptGrammarPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case OptGrammarPackage.RETURNS_PARAMETER_LIST:
				sequence_ReturnsParameterList(context, (ReturnsParameterList) semanticObject); 
				return; 
			case OptGrammarPackage.SECOND_OPERATORS:
				sequence_SecondOperators(context, (SecondOperators) semanticObject); 
				return; 
			case OptGrammarPackage.SPECIAL_VARIABLES:
				sequence_SpecialVariables(context, (SpecialVariables) semanticObject); 
				return; 
			case OptGrammarPackage.SPECIAL_VARIABLES_TYPE_ENUM:
				sequence_SpecialVariablesTypeEnum(context, (SpecialVariablesTypeEnum) semanticObject); 
				return; 
			case OptGrammarPackage.STANDARD_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getStandardVariableDeclarationRule()) {
					sequence_StandardVariableDeclaration(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.STRUCT_DEFINITION:
				sequence_StructDefinition(context, (StructDefinition) semanticObject); 
				return; 
			case OptGrammarPackage.THROW_STATEMENT:
				sequence_ThrowStatement(context, (ThrowStatement) semanticObject); 
				return; 
			case OptGrammarPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case OptGrammarPackage.TUPLE:
				sequence_Tuple(context, (Tuple) semanticObject); 
				return; 
			case OptGrammarPackage.TUPLE_SEPARATOR:
				sequence_TupleSeparator(context, (TupleSeparator) semanticObject); 
				return; 
			case OptGrammarPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case OptGrammarPackage.TYPE_CAST:
				sequence_TypeCast(context, (TypeCast) semanticObject); 
				return; 
			case OptGrammarPackage.UNIT_TYPES:
				sequence_UnitTypes(context, (UnitTypes) semanticObject); 
				return; 
			case OptGrammarPackage.VAR_VARIABLE_DECLARATION:
				sequence_VarVariableDeclaration(context, (VarVariableDeclaration) semanticObject); 
				return; 
			case OptGrammarPackage.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getVarVariableTupleVariableDeclarationRule()) {
					sequence_VarVariableTupleVariableDeclaration(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.VAR_VARIABLE_TYPE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case OptGrammarPackage.VISIBILITY_ENUM:
				sequence_VisibilityEnum(context, (VisibilityEnum) semanticObject); 
				return; 
			case OptGrammarPackage.VISIBILITY_SPECIFIER:
				sequence_VisibilitySpecifier(context, (VisibilitySpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Qualifier returns Arguments
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     arguments=FunctionCallArguments
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ARGUMENTS__ARGUMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ARGUMENTS__ARGUMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentsAccess().getArgumentsFunctionCallArgumentsParserRuleCall_0(), semanticObject.getArguments());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticOperations returns ArithmeticOperations
	 *
	 * Constraint:
	 *     (first=PrimaryArithmetic seconds+=SecondOperators*)
	 */
	protected void sequence_ArithmeticOperations(ISerializationContext context, ArithmeticOperations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayDimensions returns ArrayDimensions
	 *
	 * Constraint:
	 *     (value+=Expression? value+=Expression*)
	 */
	protected void sequence_ArrayDimensions(ISerializationContext context, ArrayDimensions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns BlockhashFunction
	 *     BlockhashFunction returns BlockhashFunction
	 *
	 * Constraint:
	 *     parameter=IntParameter
	 */
	protected void sequence_BlockhashFunction(ISerializationContext context, BlockhashFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BLOCKHASH_FUNCTION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BLOCKHASH_FUNCTION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlockhashFunctionAccess().getParameterIntParameterParserRuleCall_2_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Body
	 *     Body returns Body
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)?
	 */
	protected void sequence_Body(ISerializationContext context, Body semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns BooleanConst
	 *     BooleanConst returns BooleanConst
	 *
	 * Constraint:
	 *     value=BooleanLiteralEnum
	 */
	protected void sequence_BooleanConst(ISerializationContext context, BooleanConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BOOLEAN_CONST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BOOLEAN_CONST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanConstAccess().getValueBooleanLiteralEnumEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConditionOperation returns ConditionOperation
	 *
	 * Constraint:
	 *     (operation=LogicalOperationLiteral negateSecond='NOT'? seconds=Literal)
	 */
	protected void sequence_ConditionOperation(ISerializationContext context, ConditionOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     {Const}
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns ConstantSpecifier
	 *     ConstantSpecifier returns ConstantSpecifier
	 *
	 * Constraint:
	 *     {ConstantSpecifier}
	 */
	protected void sequence_ConstantSpecifier(ISerializationContext context, ConstantSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Continue
	 *     ContinueStatement returns Continue
	 *
	 * Constraint:
	 *     {Continue}
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, Continue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID (blocks+=Declaration | blocks+=FunctionDefinition)*)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DecimalLiteral returns DecimalLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_DecimalLiteral(ISerializationContext context, DecimalLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.DECIMAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.DECIMAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalLiteralAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteStatement
	 *     DeleteStatement returns DeleteStatement
	 *
	 * Constraint:
	 *     variable=QualifiedIdentifier
	 */
	protected void sequence_DeleteStatement(ISerializationContext context, DeleteStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.DELETE_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.DELETE_STATEMENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteStatementAccess().getVariableQualifiedIdentifierParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns EcrecoverFunction
	 *     EcrecoverFunction returns EcrecoverFunction
	 *
	 * Constraint:
	 *     (function='ecrecover' parameters+=IntParameter parameters+=IntParameter parameters+=IntParameter parameters+=IntParameter)
	 */
	protected void sequence_EcrecoverFunction(ISerializationContext context, EcrecoverFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementaryTypeNameEnum returns ElementaryTypeNameEnum
	 *
	 * Constraint:
	 *     (
	 *         type='int' | 
	 *         type='int16' | 
	 *         type='int24' | 
	 *         type='int32' | 
	 *         type='int40' | 
	 *         type='int48' | 
	 *         type='int56' | 
	 *         type='int64' | 
	 *         type='int72' | 
	 *         type='int80' | 
	 *         type='int88' | 
	 *         type='int96' | 
	 *         type='int104' | 
	 *         type='int112' | 
	 *         type='int120' | 
	 *         type='int128' | 
	 *         type='int136' | 
	 *         type='int144' | 
	 *         type='int152' | 
	 *         type='int160' | 
	 *         type='int168' | 
	 *         type='int178' | 
	 *         type='int184' | 
	 *         type='int192' | 
	 *         type='int200' | 
	 *         type='int208' | 
	 *         type='int216' | 
	 *         type='int224' | 
	 *         type='int232' | 
	 *         type='int240' | 
	 *         type='int248' | 
	 *         type='int256' | 
	 *         type='uint' | 
	 *         type='uint8' | 
	 *         type='uint16' | 
	 *         type='uint24' | 
	 *         type='uint32' | 
	 *         type='uint40' | 
	 *         type='uint48' | 
	 *         type='uint56' | 
	 *         type='uint64' | 
	 *         type='uint72' | 
	 *         type='uint80' | 
	 *         type='uint88' | 
	 *         type='uint96' | 
	 *         type='uint104' | 
	 *         type='uint112' | 
	 *         type='uint120' | 
	 *         type='uint128' | 
	 *         type='uint136' | 
	 *         type='uint144' | 
	 *         type='uint152' | 
	 *         type='uint160' | 
	 *         type='uint168' | 
	 *         type='uint178' | 
	 *         type='uint184' | 
	 *         type='uint192' | 
	 *         type='uint200' | 
	 *         type='uint208' | 
	 *         type='uint216' | 
	 *         type='uint224' | 
	 *         type='uint232' | 
	 *         type='uint240' | 
	 *         type='uint248' | 
	 *         type='uint256' | 
	 *         type='byte' | 
	 *         type='bytes' | 
	 *         type='bytes1' | 
	 *         type='bytes2' | 
	 *         type='bytes3' | 
	 *         type='bytes4' | 
	 *         type='bytes5' | 
	 *         type='bytes6' | 
	 *         type='bytes7' | 
	 *         type='bytes8' | 
	 *         type='bytes9' | 
	 *         type='bytes10' | 
	 *         type='bytes11' | 
	 *         type='bytes12' | 
	 *         type='bytes13' | 
	 *         type='bytes14' | 
	 *         type='bytes15' | 
	 *         type='bytes16' | 
	 *         type='bytes17' | 
	 *         type='bytes18' | 
	 *         type='bytes19' | 
	 *         type='bytes20' | 
	 *         type='bytes21' | 
	 *         type='bytes22' | 
	 *         type='bytes23' | 
	 *         type='bytes24' | 
	 *         type='bytes25' | 
	 *         type='bytes26' | 
	 *         type='bytes27' | 
	 *         type='bytes28' | 
	 *         type='bytes29' | 
	 *         type='bytes30' | 
	 *         type='bytes31' | 
	 *         type='bytes32' | 
	 *         type='string' | 
	 *         type='address' | 
	 *         type='bool' | 
	 *         type='real' | 
	 *         type='ureal'
	 *     )
	 */
	protected void sequence_ElementaryTypeNameEnum(ISerializationContext context, ElementaryTypeNameEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementaryType returns ElementaryType
	 *
	 * Constraint:
	 *     name=ElementaryTypeNameEnum
	 */
	protected void sequence_ElementaryType(ISerializationContext context, ElementaryType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ELEMENTARY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ELEMENTARY_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementaryTypeAccess().getNameElementaryTypeNameEnumParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StandardTypeWithoutQualifiedIdentifier returns ElementaryType
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns ElementaryType
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ElementaryType
	 *     StandardType returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardType(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns EnumDefinition
	 *     FunctionDeclaration returns EnumDefinition
	 *     EnumDefinition returns EnumDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilityEnum? name=ID members+=EnumValue members+=EnumValue*)
	 */
	protected void sequence_EnumDefinition(ISerializationContext context, EnumDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ENUM_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ENUM_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ether returns Ether
	 *
	 * Constraint:
	 *     (value=INT ether=EtherSubDenominationEnum)
	 */
	protected void sequence_Ether(ISerializationContext context, Ether semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ETHER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ETHER__VALUE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ETHER__ETHER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ETHER__ETHER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEtherAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEtherAccess().getEtherEtherSubDenominationEnumEnumRuleCall_1_0(), semanticObject.getEther());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns ExpressionStatement
	 *     Statement returns ExpressionStatement
	 *
	 * Constraint:
	 *     (expression=Expression semicolon?=';')
	 */
	protected void sequence_ExpressionStatement_SimpleStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Expression
	 *     PrimaryArithmetic returns Expression
	 *
	 * Constraint:
	 *     (
	 *         (first=Literal operations+=ConditionOperation*) | 
	 *         (negate?='NOT' first=Literal operations+=ConditionOperation*) | 
	 *         (ternary?='TERNARY' first=Literal true=Literal false=Literal)
	 *     )
	 */
	protected void sequence_Expression(ISerializationContext context, Expression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     field=ID
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.FIELD__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.FIELD__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getFieldIDTerminalRuleCall_1_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoopStructures returns ForStatement
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (initExpression=SimpleStatement2? conditionExpression=Expression? loopExpression=ExpressionStatement? body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArg returns FunctionCallArg
	 *
	 * Constraint:
	 *     (name=ID expr=Expression)
	 */
	protected void sequence_FunctionCallArg(ISerializationContext context, FunctionCallArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__NAME));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArguments returns FunctionCallArguments
	 *
	 * Constraint:
	 *     (args+=FunctionCallArg args+=FunctionCallArg*)?
	 */
	protected void sequence_FunctionCallArguments(ISerializationContext context, FunctionCallArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallListArguments returns FunctionCallListArguments
	 *     FunctionCallArguments returns FunctionCallListArguments
	 *
	 * Constraint:
	 *     (arguments+=Expression arguments+=Expression*)?
	 */
	protected void sequence_FunctionCallListArguments(ISerializationContext context, FunctionCallListArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (name=[FunctionDefinition|ID] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (
	 *         payable?='payable'? 
	 *         name=ID 
	 *         parameters=ParameterList 
	 *         optionalElements+=FunctionDefinitionOptionalElement* 
	 *         returnParameters=ReturnsParameterList? 
	 *         block=Body?
	 *     )
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns GasleftFunction
	 *     GasleftFunction returns GasleftFunction
	 *
	 * Constraint:
	 *     name='gasleft'
	 */
	protected void sequence_GasleftFunction(ISerializationContext context, GasleftFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.GASLEFT_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.GASLEFT_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGasleftFunctionAccess().getNameGasleftKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns HashFunction
	 *     HashFunction returns HashFunction
	 *
	 * Constraint:
	 *     ((name='keccak256' | name='sha256' | name='ripemd160') parameters=IntParameter)
	 */
	protected void sequence_HashFunction(ISerializationContext context, HashFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HexLiteral returns HexLiteral
	 *
	 * Constraint:
	 *     value=HEX
	 */
	protected void sequence_HexLiteral(ISerializationContext context, HexLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.HEX_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.HEX_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHexLiteralAccess().getValueHEXTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoopStructures returns IfStatement
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression trueBody=Statement falseBody=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Index
	 *     Index returns Index
	 *
	 * Constraint:
	 *     value=Expression?
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns IndexedSpecifer
	 *     IndexedSpecifer returns IndexedSpecifer
	 *
	 * Constraint:
	 *     {IndexedSpecifer}
	 */
	protected void sequence_IndexedSpecifer(ISerializationContext context, IndexedSpecifer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntParameter returns IntParameter
	 *
	 * Constraint:
	 *     (param=ArithmeticOperations | fun=FunctionCall)
	 */
	protected void sequence_IntParameter(ISerializationContext context, IntParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationSpecifierEnum returns LocationSpecifierEnum
	 *
	 * Constraint:
	 *     (type='memory' | type=MapLocationLiteral | type='calldata')
	 */
	protected void sequence_LocationSpecifierEnum(ISerializationContext context, LocationSpecifierEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns LocationSpecifier
	 *     LocationSpecifier returns LocationSpecifier
	 *
	 * Constraint:
	 *     location=LocationSpecifierEnum
	 */
	protected void sequence_LocationSpecifier(ISerializationContext context, LocationSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.LOCATION_SPECIFIER__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.LOCATION_SPECIFIER__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationSpecifierAccess().getLocationLocationSpecifierEnumParserRuleCall_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Mapping
	 *     StandardType returns Mapping
	 *     StandardTypeWithoutQualifiedIdentifier returns Mapping
	 *     Mapping returns Mapping
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns Mapping
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns Mapping
	 *
	 * Constraint:
	 *     (keyType=ElementaryTypeNameEnum valueType=Type)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.MAPPING__KEY_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.MAPPING__KEY_TYPE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.MAPPING__VALUE_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.MAPPING__VALUE_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingAccess().getKeyTypeElementaryTypeNameEnumParserRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMappingAccess().getValueTypeTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns MathematicalFunction
	 *     MathematicalFunction returns MathematicalFunction
	 *
	 * Constraint:
	 *     ((function='addmod' | function='mulmod') parameters+=IntParameter parameters+=IntParameter parameters+=IntParameter)
	 */
	protected void sequence_MathematicalFunction(ISerializationContext context, MathematicalFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     operations+=Contract+
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns ModifierInvocation
	 *     ModifierInvocation returns ModifierInvocation
	 *
	 * Constraint:
	 *     (name=[Modifier|ID] args=FunctionCallListArguments?)
	 */
	protected void sequence_ModifierInvocation(ISerializationContext context, ModifierInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList? block=Body)
	 */
	protected void sequence_Modifier(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Now returns Now
	 *
	 * Constraint:
	 *     {Now}
	 */
	protected void sequence_Now(ISerializationContext context, Now semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumberDimensionless returns NumberDimensionless
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberDimensionless(ISerializationContext context, NumberDimensionless semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.NUMBER_DIMENSIONLESS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.NUMBER_DIMENSIONLESS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberDimensionlessAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns NumericLiteral
	 *     PrimaryArithmetic returns NumericLiteral
	 *     NumericLiteral returns NumericLiteral
	 *
	 * Constraint:
	 *     ((intValue=NumberDimensionless | hexValue=HexLiteral | decimalValue=DecimalLiteral | now=Now) etherUnit=UnitTypes?)
	 */
	protected void sequence_NumericLiteral(ISerializationContext context, NumericLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=VariableDeclaration parameters+=VariableDeclaration*)?
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlaceHolderStatement
	 *     PlaceHolderStatement returns PlaceHolderStatement
	 *
	 * Constraint:
	 *     {PlaceHolderStatement}
	 */
	protected void sequence_PlaceHolderStatement(ISerializationContext context, PlaceHolderStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns QualifiedIdentifier
	 *     StandardType returns QualifiedIdentifier
	 *     QualifiedIdentifier returns QualifiedIdentifier
	 *
	 * Constraint:
	 *     (identifier=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_QualifiedIdentifier(ISerializationContext context, QualifiedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnParameterDeclaration returns ReturnParameterDeclaration
	 *
	 * Constraint:
	 *     (typeRef=Type variable=Variable?)
	 */
	protected void sequence_ReturnParameterDeclaration(ISerializationContext context, ReturnParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnsParameterList returns ReturnsParameterList
	 *
	 * Constraint:
	 *     (parameters+=ReturnParameterDeclaration parameters+=ReturnParameterDeclaration*)?
	 */
	protected void sequence_ReturnsParameterList(ISerializationContext context, ReturnsParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecondOperators returns SecondOperators
	 *
	 * Constraint:
	 *     ((operator='+' | operator='-' | operator='/' | operator='*') value=PrimaryArithmetic)
	 */
	protected void sequence_SecondOperators(ISerializationContext context, SecondOperators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement2_StandardVariableDeclaration_0_1_0 
	 *         optionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression?
	 *     )
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getTupleTupleParserRuleCall_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getVariableVariableParserRuleCall_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns StandardVariableDeclaration
	 *     Statement returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement_StandardVariableDeclaration_0_0_1_0 
	 *         ptionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression? 
	 *         semicolon?=';'
	 *     )
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTupleVariableDeclaration
	 *     Statement returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getTupleTupleParserRuleCall_0_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTypeDeclaration
	 *     Statement returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getVariableVariableParserRuleCall_0_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SpecialVariablesTypeEnum returns SpecialVariablesTypeEnum
	 *
	 * Constraint:
	 *     (name=BLOCK | name=MSG | name=TX)
	 */
	protected void sequence_SpecialVariablesTypeEnum(ISerializationContext context, SpecialVariablesTypeEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns SpecialVariables
	 *     SpecialVariables returns SpecialVariables
	 *
	 * Constraint:
	 *     (type=SpecialVariablesTypeEnum field=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_SpecialVariables(ISerializationContext context, SpecialVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns StandardVariableDeclaration
	 *     StandardVariableDeclaration returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable expression=Expression?)
	 */
	protected void sequence_StandardVariableDeclaration(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns StructDefinition
	 *     StructDefinition returns StructDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilityEnum? name=ID members+=VariableDeclaration*)
	 */
	protected void sequence_StructDefinition(ISerializationContext context, StructDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ThrowStatement
	 *     ThrowStatement returns ThrowStatement
	 *
	 * Constraint:
	 *     {ThrowStatement}
	 */
	protected void sequence_ThrowStatement(ISerializationContext context, ThrowStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     (value=INT time=TimeSubdenominationEnum)
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TIME__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TIME__VALUE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TIME__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TIME__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeAccess().getTimeTimeSubdenominationEnumEnumRuleCall_1_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TupleSeparator returns TupleSeparator
	 *
	 * Constraint:
	 *     {TupleSeparator}
	 */
	protected void sequence_TupleSeparator(ISerializationContext context, TupleSeparator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tuple returns Tuple
	 *
	 * Constraint:
	 *     (members+=Expression? (members+=TupleSeparator members+=Expression?)+)?
	 */
	protected void sequence_Tuple(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeCast returns TypeCast
	 *
	 * Constraint:
	 *     (value=ElementaryTypeNameEnum expression=Expression)
	 */
	protected void sequence_TypeCast(ISerializationContext context, TypeCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__VALUE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeCastAccess().getValueElementaryTypeNameEnumParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTypeCastAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     isVarType?=VarType
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TYPE__IS_VAR_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TYPE__IS_VAR_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getIsVarTypeVarTypeParserRuleCall_1_0(), semanticObject.isIsVarType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitTypes returns UnitTypes
	 *
	 * Constraint:
	 *     (time=Time | units=Ether)
	 */
	protected void sequence_UnitTypes(ISerializationContext context, UnitTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableDeclaration
	 *     VarVariableDeclaration returns VarVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType variable=Variable expression=Expression?)
	 */
	protected void sequence_VarVariableDeclaration(ISerializationContext context, VarVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableTupleVariableDeclaration
	 *     VarVariableTupleVariableDeclaration returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType tuple=Tuple expression=Expression?)
	 */
	protected void sequence_VarVariableTupleVariableDeclaration(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VisibilityEnum returns VisibilityEnum
	 *
	 * Constraint:
	 *     (type='public' | type='internal' | type='private' | type='external')
	 */
	protected void sequence_VisibilityEnum(ISerializationContext context, VisibilityEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns VisibilitySpecifier
	 *     VisibilitySpecifier returns VisibilitySpecifier
	 *     VariableDeclarationOptionalElement returns VisibilitySpecifier
	 *
	 * Constraint:
	 *     visibility=VisibilityEnum
	 */
	protected void sequence_VisibilitySpecifier(ISerializationContext context, VisibilitySpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VISIBILITY_SPECIFIER__VISIBILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VISIBILITY_SPECIFIER__VISIBILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVisibilitySpecifierAccess().getVisibilityVisibilityEnumParserRuleCall_0(), semanticObject.getVisibility());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LoopStructures returns WhileStatement
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
