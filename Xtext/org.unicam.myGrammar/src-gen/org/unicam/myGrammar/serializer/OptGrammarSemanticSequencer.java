/*
 * generated by Xtext 2.19.0
 */
package org.unicam.myGrammar.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unicam.myGrammar.optGrammar.AddSub;
import org.unicam.myGrammar.optGrammar.And;
import org.unicam.myGrammar.optGrammar.Arguments;
import org.unicam.myGrammar.optGrammar.ArithmeticOperations;
import org.unicam.myGrammar.optGrammar.ArrayDimensions;
import org.unicam.myGrammar.optGrammar.Assignment;
import org.unicam.myGrammar.optGrammar.BinaryNotExpression;
import org.unicam.myGrammar.optGrammar.BitAnd;
import org.unicam.myGrammar.optGrammar.BitOr;
import org.unicam.myGrammar.optGrammar.BitXor;
import org.unicam.myGrammar.optGrammar.Block;
import org.unicam.myGrammar.optGrammar.BlockhashFunction;
import org.unicam.myGrammar.optGrammar.BooleanConst;
import org.unicam.myGrammar.optGrammar.BreakStatement;
import org.unicam.myGrammar.optGrammar.Comparison;
import org.unicam.myGrammar.optGrammar.Const;
import org.unicam.myGrammar.optGrammar.ConstantSpecifier;
import org.unicam.myGrammar.optGrammar.Continue;
import org.unicam.myGrammar.optGrammar.Contract;
import org.unicam.myGrammar.optGrammar.DecimalLiteral;
import org.unicam.myGrammar.optGrammar.DefinitionBody;
import org.unicam.myGrammar.optGrammar.DeleteStatement;
import org.unicam.myGrammar.optGrammar.EcrecoverFunction;
import org.unicam.myGrammar.optGrammar.ElementaryType;
import org.unicam.myGrammar.optGrammar.ElementaryTypeNameEnum;
import org.unicam.myGrammar.optGrammar.EnumDefinition;
import org.unicam.myGrammar.optGrammar.EnumValue;
import org.unicam.myGrammar.optGrammar.Equality;
import org.unicam.myGrammar.optGrammar.Ether;
import org.unicam.myGrammar.optGrammar.Event;
import org.unicam.myGrammar.optGrammar.Exponent;
import org.unicam.myGrammar.optGrammar.ExpressionStatement;
import org.unicam.myGrammar.optGrammar.Field;
import org.unicam.myGrammar.optGrammar.ForStatement;
import org.unicam.myGrammar.optGrammar.FunctionCall;
import org.unicam.myGrammar.optGrammar.FunctionCallArg;
import org.unicam.myGrammar.optGrammar.FunctionCallArguments;
import org.unicam.myGrammar.optGrammar.FunctionCallListArguments;
import org.unicam.myGrammar.optGrammar.FunctionDefinition;
import org.unicam.myGrammar.optGrammar.GasleftFunction;
import org.unicam.myGrammar.optGrammar.HashFunction;
import org.unicam.myGrammar.optGrammar.HexLiteral;
import org.unicam.myGrammar.optGrammar.IfStatement;
import org.unicam.myGrammar.optGrammar.ImportDirective;
import org.unicam.myGrammar.optGrammar.Index;
import org.unicam.myGrammar.optGrammar.IndexedSpecifer;
import org.unicam.myGrammar.optGrammar.InheritanceSpecifier;
import org.unicam.myGrammar.optGrammar.IntParameter;
import org.unicam.myGrammar.optGrammar.LocationSpecifier;
import org.unicam.myGrammar.optGrammar.LocationSpecifierEnum;
import org.unicam.myGrammar.optGrammar.Mapping;
import org.unicam.myGrammar.optGrammar.MathematicalFunction;
import org.unicam.myGrammar.optGrammar.Modifier;
import org.unicam.myGrammar.optGrammar.ModifierInvocation;
import org.unicam.myGrammar.optGrammar.MulDivMod;
import org.unicam.myGrammar.optGrammar.NewExpression;
import org.unicam.myGrammar.optGrammar.NotExpression;
import org.unicam.myGrammar.optGrammar.Now;
import org.unicam.myGrammar.optGrammar.NumberDimensionless;
import org.unicam.myGrammar.optGrammar.NumericLiteral;
import org.unicam.myGrammar.optGrammar.OptGrammarPackage;
import org.unicam.myGrammar.optGrammar.Or;
import org.unicam.myGrammar.optGrammar.ParameterList;
import org.unicam.myGrammar.optGrammar.PlaceHolderStatement;
import org.unicam.myGrammar.optGrammar.PostIncDecExpression;
import org.unicam.myGrammar.optGrammar.PreDecExpression;
import org.unicam.myGrammar.optGrammar.PreIncExpression;
import org.unicam.myGrammar.optGrammar.QualifiedIdentifier;
import org.unicam.myGrammar.optGrammar.ReturnParameterDeclaration;
import org.unicam.myGrammar.optGrammar.ReturnStatement;
import org.unicam.myGrammar.optGrammar.ReturnsParameterList;
import org.unicam.myGrammar.optGrammar.SecondOperators;
import org.unicam.myGrammar.optGrammar.Shift;
import org.unicam.myGrammar.optGrammar.SignExpression;
import org.unicam.myGrammar.optGrammar.Solidity;
import org.unicam.myGrammar.optGrammar.SpecialExpression;
import org.unicam.myGrammar.optGrammar.SpecialVariables;
import org.unicam.myGrammar.optGrammar.SpecialVariablesTypeEnum;
import org.unicam.myGrammar.optGrammar.StandardVariableDeclaration;
import org.unicam.myGrammar.optGrammar.StringLiteral;
import org.unicam.myGrammar.optGrammar.StructDefinition;
import org.unicam.myGrammar.optGrammar.SymbolAlias;
import org.unicam.myGrammar.optGrammar.ThrowStatement;
import org.unicam.myGrammar.optGrammar.Time;
import org.unicam.myGrammar.optGrammar.Tuple;
import org.unicam.myGrammar.optGrammar.TupleSeparator;
import org.unicam.myGrammar.optGrammar.Type;
import org.unicam.myGrammar.optGrammar.TypeCast;
import org.unicam.myGrammar.optGrammar.UnitTypes;
import org.unicam.myGrammar.optGrammar.VarVariableDeclaration;
import org.unicam.myGrammar.optGrammar.VarVariableTupleVariableDeclaration;
import org.unicam.myGrammar.optGrammar.VarVariableTypeDeclaration;
import org.unicam.myGrammar.optGrammar.Variable;
import org.unicam.myGrammar.optGrammar.VariableDeclarationExpression;
import org.unicam.myGrammar.optGrammar.VisibilityEnum;
import org.unicam.myGrammar.optGrammar.VisibilitySpecifier;
import org.unicam.myGrammar.optGrammar.WhileStatement;
import org.unicam.myGrammar.services.OptGrammarGrammarAccess;

@SuppressWarnings("all")
public class OptGrammarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OptGrammarGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OptGrammarPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OptGrammarPackage.ADD_SUB:
				sequence_AddSub(context, (AddSub) semanticObject); 
				return; 
			case OptGrammarPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case OptGrammarPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case OptGrammarPackage.ARITHMETIC_OPERATIONS:
				sequence_ArithmeticOperations(context, (ArithmeticOperations) semanticObject); 
				return; 
			case OptGrammarPackage.ARRAY_DIMENSIONS:
				sequence_ArrayDimensions(context, (ArrayDimensions) semanticObject); 
				return; 
			case OptGrammarPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case OptGrammarPackage.BINARY_NOT_EXPRESSION:
				sequence_BinaryNotExpression(context, (BinaryNotExpression) semanticObject); 
				return; 
			case OptGrammarPackage.BIT_AND:
				sequence_BitAnd(context, (BitAnd) semanticObject); 
				return; 
			case OptGrammarPackage.BIT_OR:
				sequence_BitOr(context, (BitOr) semanticObject); 
				return; 
			case OptGrammarPackage.BIT_XOR:
				sequence_BitXor(context, (BitXor) semanticObject); 
				return; 
			case OptGrammarPackage.BLOCK:
				sequence_Body(context, (Block) semanticObject); 
				return; 
			case OptGrammarPackage.BLOCKHASH_FUNCTION:
				sequence_BlockhashFunction(context, (BlockhashFunction) semanticObject); 
				return; 
			case OptGrammarPackage.BOOLEAN_CONST:
				sequence_BooleanConst(context, (BooleanConst) semanticObject); 
				return; 
			case OptGrammarPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case OptGrammarPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case OptGrammarPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case OptGrammarPackage.CONSTANT_SPECIFIER:
				sequence_ConstantSpecifier(context, (ConstantSpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.CONTINUE:
				sequence_ContinueStatement(context, (Continue) semanticObject); 
				return; 
			case OptGrammarPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case OptGrammarPackage.DECIMAL_LITERAL:
				sequence_DecimalLiteral(context, (DecimalLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.DEFINITION_BODY:
				sequence_DefinitionBody(context, (DefinitionBody) semanticObject); 
				return; 
			case OptGrammarPackage.DELETE_STATEMENT:
				sequence_DeleteStatement(context, (DeleteStatement) semanticObject); 
				return; 
			case OptGrammarPackage.ECRECOVER_FUNCTION:
				sequence_EcrecoverFunction(context, (EcrecoverFunction) semanticObject); 
				return; 
			case OptGrammarPackage.ELEMENTARY_TYPE:
				if (rule == grammarAccess.getElementaryTypeRule()) {
					sequence_ElementaryType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStandardTypeWithoutQualifiedIdentifierRule()
						|| action == grammarAccess.getSimpleStatementAccess().getStandardVariableDeclarationTypeAction_0_0_1_0()
						|| action == grammarAccess.getSimpleStatement2Access().getStandardVariableDeclarationTypeAction_0_1_0()) {
					sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getStandardTypeRule()) {
					sequence_ElementaryType_StandardType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.ELEMENTARY_TYPE_NAME_ENUM:
				sequence_ElementaryTypeNameEnum(context, (ElementaryTypeNameEnum) semanticObject); 
				return; 
			case OptGrammarPackage.ENUM_DEFINITION:
				sequence_EnumDefinition(context, (EnumDefinition) semanticObject); 
				return; 
			case OptGrammarPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case OptGrammarPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case OptGrammarPackage.ETHER:
				sequence_Ether(context, (Ether) semanticObject); 
				return; 
			case OptGrammarPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case OptGrammarPackage.EXPONENT:
				sequence_Exponent(context, (Exponent) semanticObject); 
				return; 
			case OptGrammarPackage.EXPRESSION_STATEMENT:
				if (rule == grammarAccess.getSimpleStatement2Rule()
						|| rule == grammarAccess.getExpressionStatementRule()) {
					sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ExpressionStatement_SimpleStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case OptGrammarPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL:
				sequence_FunctionCall(context, (FunctionCall) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL_ARG:
				sequence_FunctionCallArg(context, (FunctionCallArg) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL_ARGUMENTS:
				sequence_FunctionCallArguments(context, (FunctionCallArguments) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_CALL_LIST_ARGUMENTS:
				sequence_FunctionCallListArguments(context, (FunctionCallListArguments) semanticObject); 
				return; 
			case OptGrammarPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case OptGrammarPackage.GASLEFT_FUNCTION:
				sequence_GasleftFunction(context, (GasleftFunction) semanticObject); 
				return; 
			case OptGrammarPackage.HASH_FUNCTION:
				sequence_HashFunction(context, (HashFunction) semanticObject); 
				return; 
			case OptGrammarPackage.HEX_LITERAL:
				sequence_HexLiteral(context, (HexLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case OptGrammarPackage.IMPORT_DIRECTIVE:
				sequence_ImportDirective(context, (ImportDirective) semanticObject); 
				return; 
			case OptGrammarPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case OptGrammarPackage.INDEXED_SPECIFER:
				sequence_IndexedSpecifer(context, (IndexedSpecifer) semanticObject); 
				return; 
			case OptGrammarPackage.INHERITANCE_SPECIFIER:
				sequence_InheritanceSpecifier(context, (InheritanceSpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.INT_PARAMETER:
				sequence_IntParameter(context, (IntParameter) semanticObject); 
				return; 
			case OptGrammarPackage.LOCATION_SPECIFIER:
				sequence_LocationSpecifier(context, (LocationSpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.LOCATION_SPECIFIER_ENUM:
				sequence_LocationSpecifierEnum(context, (LocationSpecifierEnum) semanticObject); 
				return; 
			case OptGrammarPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case OptGrammarPackage.MATHEMATICAL_FUNCTION:
				sequence_MathematicalFunction(context, (MathematicalFunction) semanticObject); 
				return; 
			case OptGrammarPackage.MODIFIER:
				sequence_Modifier(context, (Modifier) semanticObject); 
				return; 
			case OptGrammarPackage.MODIFIER_INVOCATION:
				sequence_ModifierInvocation(context, (ModifierInvocation) semanticObject); 
				return; 
			case OptGrammarPackage.MUL_DIV_MOD:
				sequence_MulDivMod(context, (MulDivMod) semanticObject); 
				return; 
			case OptGrammarPackage.NEW_EXPRESSION:
				sequence_NewExpression(context, (NewExpression) semanticObject); 
				return; 
			case OptGrammarPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case OptGrammarPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case OptGrammarPackage.NUMBER_DIMENSIONLESS:
				sequence_NumberDimensionless(context, (NumberDimensionless) semanticObject); 
				return; 
			case OptGrammarPackage.NUMERIC_LITERAL:
				sequence_NumericLiteral(context, (NumericLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case OptGrammarPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case OptGrammarPackage.PLACE_HOLDER_STATEMENT:
				sequence_PlaceHolderStatement(context, (PlaceHolderStatement) semanticObject); 
				return; 
			case OptGrammarPackage.POST_INC_DEC_EXPRESSION:
				sequence_PostIncDecExpression(context, (PostIncDecExpression) semanticObject); 
				return; 
			case OptGrammarPackage.PRE_DEC_EXPRESSION:
				if (rule == grammarAccess.getPreDecExpressionRule()) {
					sequence_PreDecExpression(context, (PreDecExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()
						|| rule == grammarAccess.getPrimaryArithmeticRule()) {
					sequence_PreExpression(context, (PreDecExpression) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.PRE_INC_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()
						|| rule == grammarAccess.getPrimaryArithmeticRule()) {
					sequence_PreExpression(context, (PreIncExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPreIncExpressionRule()) {
					sequence_PreIncExpression(context, (PreIncExpression) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.QUALIFIED_IDENTIFIER:
				sequence_QualifiedIdentifier(context, (QualifiedIdentifier) semanticObject); 
				return; 
			case OptGrammarPackage.RETURN_PARAMETER_DECLARATION:
				sequence_ReturnParameterDeclaration(context, (ReturnParameterDeclaration) semanticObject); 
				return; 
			case OptGrammarPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case OptGrammarPackage.RETURNS_PARAMETER_LIST:
				sequence_ReturnsParameterList(context, (ReturnsParameterList) semanticObject); 
				return; 
			case OptGrammarPackage.SECOND_OPERATORS:
				sequence_SecondOperators(context, (SecondOperators) semanticObject); 
				return; 
			case OptGrammarPackage.SHIFT:
				sequence_Shift(context, (Shift) semanticObject); 
				return; 
			case OptGrammarPackage.SIGN_EXPRESSION:
				sequence_SignExpression(context, (SignExpression) semanticObject); 
				return; 
			case OptGrammarPackage.SOLIDITY:
				sequence_Solidity(context, (Solidity) semanticObject); 
				return; 
			case OptGrammarPackage.SPECIAL_EXPRESSION:
				sequence_SpecialExpression(context, (SpecialExpression) semanticObject); 
				return; 
			case OptGrammarPackage.SPECIAL_VARIABLES:
				sequence_SpecialVariables(context, (SpecialVariables) semanticObject); 
				return; 
			case OptGrammarPackage.SPECIAL_VARIABLES_TYPE_ENUM:
				sequence_SpecialVariablesTypeEnum(context, (SpecialVariablesTypeEnum) semanticObject); 
				return; 
			case OptGrammarPackage.STANDARD_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getStandardVariableDeclarationRule()) {
					sequence_StandardVariableDeclaration(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case OptGrammarPackage.STRUCT_DEFINITION:
				sequence_StructDefinition(context, (StructDefinition) semanticObject); 
				return; 
			case OptGrammarPackage.SYMBOL_ALIAS:
				sequence_SymbolAlias(context, (SymbolAlias) semanticObject); 
				return; 
			case OptGrammarPackage.THROW_STATEMENT:
				sequence_ThrowStatement(context, (ThrowStatement) semanticObject); 
				return; 
			case OptGrammarPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case OptGrammarPackage.TUPLE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()
						|| rule == grammarAccess.getPrimaryArithmeticRule()) {
					sequence_PrimaryExpression(context, (Tuple) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTupleRule()) {
					sequence_Tuple(context, (Tuple) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.TUPLE_SEPARATOR:
				sequence_TupleSeparator(context, (TupleSeparator) semanticObject); 
				return; 
			case OptGrammarPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case OptGrammarPackage.TYPE_CAST:
				sequence_TypeCast(context, (TypeCast) semanticObject); 
				return; 
			case OptGrammarPackage.UNIT_TYPES:
				sequence_UnitTypes(context, (UnitTypes) semanticObject); 
				return; 
			case OptGrammarPackage.VAR_VARIABLE_DECLARATION:
				sequence_VarVariableDeclaration(context, (VarVariableDeclaration) semanticObject); 
				return; 
			case OptGrammarPackage.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getVarVariableTupleVariableDeclarationRule()) {
					sequence_VarVariableTupleVariableDeclaration(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.VAR_VARIABLE_TYPE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else break;
			case OptGrammarPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case OptGrammarPackage.VARIABLE_DECLARATION_EXPRESSION:
				sequence_Assignment(context, (VariableDeclarationExpression) semanticObject); 
				return; 
			case OptGrammarPackage.VISIBILITY_ENUM:
				sequence_VisibilityEnum(context, (VisibilityEnum) semanticObject); 
				return; 
			case OptGrammarPackage.VISIBILITY_SPECIFIER:
				sequence_VisibilitySpecifier(context, (VisibilitySpecifier) semanticObject); 
				return; 
			case OptGrammarPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddSub
	 *     Assignment returns AddSub
	 *     Assignment.Assignment_1_0_0 returns AddSub
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns AddSub
	 *     BinaryExpression returns AddSub
	 *     Or returns AddSub
	 *     Or.Or_1_0 returns AddSub
	 *     And returns AddSub
	 *     And.And_1_0 returns AddSub
	 *     Equality returns AddSub
	 *     Equality.Equality_1_0 returns AddSub
	 *     Comparison returns AddSub
	 *     Comparison.Comparison_1_0 returns AddSub
	 *     BitOr returns AddSub
	 *     BitOr.BitOr_1_0 returns AddSub
	 *     BitXor returns AddSub
	 *     BitXor.BitXor_1_0 returns AddSub
	 *     BitAnd returns AddSub
	 *     BitAnd.BitAnd_1_0 returns AddSub
	 *     Shift returns AddSub
	 *     Shift.Shift_1_0 returns AddSub
	 *     AddSub returns AddSub
	 *     AddSub.AddSub_1_0_0 returns AddSub
	 *     MulDivMod returns AddSub
	 *     MulDivMod.MulDivMod_1_0 returns AddSub
	 *     Exponent returns AddSub
	 *     Exponent.Exponent_1_0 returns AddSub
	 *     UnaryExpression returns AddSub
	 *     PreExpression returns AddSub
	 *     PreExpression.PreIncExpression_1_2 returns AddSub
	 *     PreExpression.PreDecExpression_2_2 returns AddSub
	 *     PostIncDecExpression returns AddSub
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns AddSub
	 *     PrimaryExpression returns AddSub
	 *     PrimaryExpression.Tuple_4_2_0 returns AddSub
	 *     PrimaryArithmetic returns AddSub
	 *
	 * Constraint:
	 *     (left=AddSub_AddSub_1_0_0 additionOp=AdditionOpEnum right=MulDivMod)
	 */
	protected void sequence_AddSub(ISerializationContext context, AddSub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ADD_SUB__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ADD_SUB__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ADD_SUB__ADDITION_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ADD_SUB__ADDITION_OP));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ADD_SUB__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ADD_SUB__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddSubAccess().getAdditionOpAdditionOpEnumEnumRuleCall_1_0_1_0(), semanticObject.getAdditionOp());
		feeder.accept(grammarAccess.getAddSubAccess().getRightMulDivModParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Assignment returns And
	 *     Assignment.Assignment_1_0_0 returns And
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns And
	 *     BinaryExpression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     BitOr returns And
	 *     BitOr.BitOr_1_0 returns And
	 *     BitXor returns And
	 *     BitXor.BitXor_1_0 returns And
	 *     BitAnd returns And
	 *     BitAnd.BitAnd_1_0 returns And
	 *     Shift returns And
	 *     Shift.Shift_1_0 returns And
	 *     AddSub returns And
	 *     AddSub.AddSub_1_0_0 returns And
	 *     MulDivMod returns And
	 *     MulDivMod.MulDivMod_1_0 returns And
	 *     Exponent returns And
	 *     Exponent.Exponent_1_0 returns And
	 *     UnaryExpression returns And
	 *     PreExpression returns And
	 *     PreExpression.PreIncExpression_1_2 returns And
	 *     PreExpression.PreDecExpression_2_2 returns And
	 *     PostIncDecExpression returns And
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns And
	 *     PrimaryExpression returns And
	 *     PrimaryExpression.Tuple_4_2_0 returns And
	 *     PrimaryArithmetic returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Arguments
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     arguments=FunctionCallArguments
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ARGUMENTS__ARGUMENTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ARGUMENTS__ARGUMENTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentsAccess().getArgumentsFunctionCallArgumentsParserRuleCall_0(), semanticObject.getArguments());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArithmeticOperations returns ArithmeticOperations
	 *
	 * Constraint:
	 *     (first=PrimaryArithmetic seconds+=SecondOperators*)
	 */
	protected void sequence_ArithmeticOperations(ISerializationContext context, ArithmeticOperations semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ArrayDimensions returns ArrayDimensions
	 *
	 * Constraint:
	 *     (value+=Expression? value+=Expression*)
	 */
	protected void sequence_ArrayDimensions(ISerializationContext context, ArrayDimensions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *     Assignment.Assignment_1_0_0 returns Assignment
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Assignment
	 *     BinaryExpression returns Assignment
	 *     Or returns Assignment
	 *     Or.Or_1_0 returns Assignment
	 *     And returns Assignment
	 *     And.And_1_0 returns Assignment
	 *     Equality returns Assignment
	 *     Equality.Equality_1_0 returns Assignment
	 *     Comparison returns Assignment
	 *     Comparison.Comparison_1_0 returns Assignment
	 *     BitOr returns Assignment
	 *     BitOr.BitOr_1_0 returns Assignment
	 *     BitXor returns Assignment
	 *     BitXor.BitXor_1_0 returns Assignment
	 *     BitAnd returns Assignment
	 *     BitAnd.BitAnd_1_0 returns Assignment
	 *     Shift returns Assignment
	 *     Shift.Shift_1_0 returns Assignment
	 *     AddSub returns Assignment
	 *     AddSub.AddSub_1_0_0 returns Assignment
	 *     MulDivMod returns Assignment
	 *     MulDivMod.MulDivMod_1_0 returns Assignment
	 *     Exponent returns Assignment
	 *     Exponent.Exponent_1_0 returns Assignment
	 *     UnaryExpression returns Assignment
	 *     PreExpression returns Assignment
	 *     PreExpression.PreIncExpression_1_2 returns Assignment
	 *     PreExpression.PreDecExpression_2_2 returns Assignment
	 *     PostIncDecExpression returns Assignment
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Assignment
	 *     PrimaryExpression returns Assignment
	 *     PrimaryExpression.Tuple_4_2_0 returns Assignment
	 *     PrimaryArithmetic returns Assignment
	 *
	 * Constraint:
	 *     (left=Assignment_Assignment_1_0_0 assignmentOp=AssignmentOpEnum expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ASSIGNMENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ASSIGNMENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ASSIGNMENT__ASSIGNMENT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ASSIGNMENT__ASSIGNMENT_OP));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ASSIGNMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ASSIGNMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentOpAssignmentOpEnumEnumRuleCall_1_0_1_0(), semanticObject.getAssignmentOp());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_1_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableDeclarationExpression
	 *     Assignment returns VariableDeclarationExpression
	 *     Assignment.Assignment_1_0_0 returns VariableDeclarationExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns VariableDeclarationExpression
	 *     BinaryExpression returns VariableDeclarationExpression
	 *     Or returns VariableDeclarationExpression
	 *     Or.Or_1_0 returns VariableDeclarationExpression
	 *     And returns VariableDeclarationExpression
	 *     And.And_1_0 returns VariableDeclarationExpression
	 *     Equality returns VariableDeclarationExpression
	 *     Equality.Equality_1_0 returns VariableDeclarationExpression
	 *     Comparison returns VariableDeclarationExpression
	 *     Comparison.Comparison_1_0 returns VariableDeclarationExpression
	 *     BitOr returns VariableDeclarationExpression
	 *     BitOr.BitOr_1_0 returns VariableDeclarationExpression
	 *     BitXor returns VariableDeclarationExpression
	 *     BitXor.BitXor_1_0 returns VariableDeclarationExpression
	 *     BitAnd returns VariableDeclarationExpression
	 *     BitAnd.BitAnd_1_0 returns VariableDeclarationExpression
	 *     Shift returns VariableDeclarationExpression
	 *     Shift.Shift_1_0 returns VariableDeclarationExpression
	 *     AddSub returns VariableDeclarationExpression
	 *     AddSub.AddSub_1_0_0 returns VariableDeclarationExpression
	 *     MulDivMod returns VariableDeclarationExpression
	 *     MulDivMod.MulDivMod_1_0 returns VariableDeclarationExpression
	 *     Exponent returns VariableDeclarationExpression
	 *     Exponent.Exponent_1_0 returns VariableDeclarationExpression
	 *     UnaryExpression returns VariableDeclarationExpression
	 *     PreExpression returns VariableDeclarationExpression
	 *     PreExpression.PreIncExpression_1_2 returns VariableDeclarationExpression
	 *     PreExpression.PreDecExpression_2_2 returns VariableDeclarationExpression
	 *     PostIncDecExpression returns VariableDeclarationExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns VariableDeclarationExpression
	 *     PrimaryExpression returns VariableDeclarationExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns VariableDeclarationExpression
	 *     PrimaryArithmetic returns VariableDeclarationExpression
	 *
	 * Constraint:
	 *     (type=Assignment_VariableDeclarationExpression_1_1_0 variable=Variable expression=Expression?)
	 */
	protected void sequence_Assignment(ISerializationContext context, VariableDeclarationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinaryNotExpression
	 *     Assignment returns BinaryNotExpression
	 *     Assignment.Assignment_1_0_0 returns BinaryNotExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BinaryNotExpression
	 *     BinaryExpression returns BinaryNotExpression
	 *     Or returns BinaryNotExpression
	 *     Or.Or_1_0 returns BinaryNotExpression
	 *     And returns BinaryNotExpression
	 *     And.And_1_0 returns BinaryNotExpression
	 *     Equality returns BinaryNotExpression
	 *     Equality.Equality_1_0 returns BinaryNotExpression
	 *     Comparison returns BinaryNotExpression
	 *     Comparison.Comparison_1_0 returns BinaryNotExpression
	 *     BitOr returns BinaryNotExpression
	 *     BitOr.BitOr_1_0 returns BinaryNotExpression
	 *     BitXor returns BinaryNotExpression
	 *     BitXor.BitXor_1_0 returns BinaryNotExpression
	 *     BitAnd returns BinaryNotExpression
	 *     BitAnd.BitAnd_1_0 returns BinaryNotExpression
	 *     Shift returns BinaryNotExpression
	 *     Shift.Shift_1_0 returns BinaryNotExpression
	 *     AddSub returns BinaryNotExpression
	 *     AddSub.AddSub_1_0_0 returns BinaryNotExpression
	 *     MulDivMod returns BinaryNotExpression
	 *     MulDivMod.MulDivMod_1_0 returns BinaryNotExpression
	 *     Exponent returns BinaryNotExpression
	 *     Exponent.Exponent_1_0 returns BinaryNotExpression
	 *     UnaryExpression returns BinaryNotExpression
	 *     BinaryNotExpression returns BinaryNotExpression
	 *     PreExpression returns BinaryNotExpression
	 *     PreExpression.PreIncExpression_1_2 returns BinaryNotExpression
	 *     PreExpression.PreDecExpression_2_2 returns BinaryNotExpression
	 *     PostIncDecExpression returns BinaryNotExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BinaryNotExpression
	 *     PrimaryExpression returns BinaryNotExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns BinaryNotExpression
	 *     PrimaryArithmetic returns BinaryNotExpression
	 *
	 * Constraint:
	 *     expression=UnaryExpression
	 */
	protected void sequence_BinaryNotExpression(ISerializationContext context, BinaryNotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BINARY_NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BINARY_NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryNotExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitAnd
	 *     Assignment returns BitAnd
	 *     Assignment.Assignment_1_0_0 returns BitAnd
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitAnd
	 *     BinaryExpression returns BitAnd
	 *     Or returns BitAnd
	 *     Or.Or_1_0 returns BitAnd
	 *     And returns BitAnd
	 *     And.And_1_0 returns BitAnd
	 *     Equality returns BitAnd
	 *     Equality.Equality_1_0 returns BitAnd
	 *     Comparison returns BitAnd
	 *     Comparison.Comparison_1_0 returns BitAnd
	 *     BitOr returns BitAnd
	 *     BitOr.BitOr_1_0 returns BitAnd
	 *     BitXor returns BitAnd
	 *     BitXor.BitXor_1_0 returns BitAnd
	 *     BitAnd returns BitAnd
	 *     BitAnd.BitAnd_1_0 returns BitAnd
	 *     Shift returns BitAnd
	 *     Shift.Shift_1_0 returns BitAnd
	 *     AddSub returns BitAnd
	 *     AddSub.AddSub_1_0_0 returns BitAnd
	 *     MulDivMod returns BitAnd
	 *     MulDivMod.MulDivMod_1_0 returns BitAnd
	 *     Exponent returns BitAnd
	 *     Exponent.Exponent_1_0 returns BitAnd
	 *     UnaryExpression returns BitAnd
	 *     PreExpression returns BitAnd
	 *     PreExpression.PreIncExpression_1_2 returns BitAnd
	 *     PreExpression.PreDecExpression_2_2 returns BitAnd
	 *     PostIncDecExpression returns BitAnd
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitAnd
	 *     PrimaryExpression returns BitAnd
	 *     PrimaryExpression.Tuple_4_2_0 returns BitAnd
	 *     PrimaryArithmetic returns BitAnd
	 *
	 * Constraint:
	 *     (left=BitAnd_BitAnd_1_0 right=Shift)
	 */
	protected void sequence_BitAnd(ISerializationContext context, BitAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BIT_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BIT_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BIT_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BIT_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitAndAccess().getRightShiftParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitOr
	 *     Assignment returns BitOr
	 *     Assignment.Assignment_1_0_0 returns BitOr
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitOr
	 *     BinaryExpression returns BitOr
	 *     Or returns BitOr
	 *     Or.Or_1_0 returns BitOr
	 *     And returns BitOr
	 *     And.And_1_0 returns BitOr
	 *     Equality returns BitOr
	 *     Equality.Equality_1_0 returns BitOr
	 *     Comparison returns BitOr
	 *     Comparison.Comparison_1_0 returns BitOr
	 *     BitOr returns BitOr
	 *     BitOr.BitOr_1_0 returns BitOr
	 *     BitXor returns BitOr
	 *     BitXor.BitXor_1_0 returns BitOr
	 *     BitAnd returns BitOr
	 *     BitAnd.BitAnd_1_0 returns BitOr
	 *     Shift returns BitOr
	 *     Shift.Shift_1_0 returns BitOr
	 *     AddSub returns BitOr
	 *     AddSub.AddSub_1_0_0 returns BitOr
	 *     MulDivMod returns BitOr
	 *     MulDivMod.MulDivMod_1_0 returns BitOr
	 *     Exponent returns BitOr
	 *     Exponent.Exponent_1_0 returns BitOr
	 *     UnaryExpression returns BitOr
	 *     PreExpression returns BitOr
	 *     PreExpression.PreIncExpression_1_2 returns BitOr
	 *     PreExpression.PreDecExpression_2_2 returns BitOr
	 *     PostIncDecExpression returns BitOr
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitOr
	 *     PrimaryExpression returns BitOr
	 *     PrimaryExpression.Tuple_4_2_0 returns BitOr
	 *     PrimaryArithmetic returns BitOr
	 *
	 * Constraint:
	 *     (left=BitOr_BitOr_1_0 right=BitXor)
	 */
	protected void sequence_BitOr(ISerializationContext context, BitOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BIT_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BIT_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BIT_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BIT_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitOrAccess().getRightBitXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitXor
	 *     Assignment returns BitXor
	 *     Assignment.Assignment_1_0_0 returns BitXor
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitXor
	 *     BinaryExpression returns BitXor
	 *     Or returns BitXor
	 *     Or.Or_1_0 returns BitXor
	 *     And returns BitXor
	 *     And.And_1_0 returns BitXor
	 *     Equality returns BitXor
	 *     Equality.Equality_1_0 returns BitXor
	 *     Comparison returns BitXor
	 *     Comparison.Comparison_1_0 returns BitXor
	 *     BitOr returns BitXor
	 *     BitOr.BitOr_1_0 returns BitXor
	 *     BitXor returns BitXor
	 *     BitXor.BitXor_1_0 returns BitXor
	 *     BitAnd returns BitXor
	 *     BitAnd.BitAnd_1_0 returns BitXor
	 *     Shift returns BitXor
	 *     Shift.Shift_1_0 returns BitXor
	 *     AddSub returns BitXor
	 *     AddSub.AddSub_1_0_0 returns BitXor
	 *     MulDivMod returns BitXor
	 *     MulDivMod.MulDivMod_1_0 returns BitXor
	 *     Exponent returns BitXor
	 *     Exponent.Exponent_1_0 returns BitXor
	 *     UnaryExpression returns BitXor
	 *     PreExpression returns BitXor
	 *     PreExpression.PreIncExpression_1_2 returns BitXor
	 *     PreExpression.PreDecExpression_2_2 returns BitXor
	 *     PostIncDecExpression returns BitXor
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitXor
	 *     PrimaryExpression returns BitXor
	 *     PrimaryExpression.Tuple_4_2_0 returns BitXor
	 *     PrimaryArithmetic returns BitXor
	 *
	 * Constraint:
	 *     (left=BitXor_BitXor_1_0 right=BitAnd)
	 */
	protected void sequence_BitXor(ISerializationContext context, BitXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BIT_XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BIT_XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BIT_XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BIT_XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitXorAccess().getRightBitAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BlockhashFunction
	 *     Assignment returns BlockhashFunction
	 *     Assignment.Assignment_1_0_0 returns BlockhashFunction
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BlockhashFunction
	 *     BinaryExpression returns BlockhashFunction
	 *     Or returns BlockhashFunction
	 *     Or.Or_1_0 returns BlockhashFunction
	 *     And returns BlockhashFunction
	 *     And.And_1_0 returns BlockhashFunction
	 *     Equality returns BlockhashFunction
	 *     Equality.Equality_1_0 returns BlockhashFunction
	 *     Comparison returns BlockhashFunction
	 *     Comparison.Comparison_1_0 returns BlockhashFunction
	 *     BitOr returns BlockhashFunction
	 *     BitOr.BitOr_1_0 returns BlockhashFunction
	 *     BitXor returns BlockhashFunction
	 *     BitXor.BitXor_1_0 returns BlockhashFunction
	 *     BitAnd returns BlockhashFunction
	 *     BitAnd.BitAnd_1_0 returns BlockhashFunction
	 *     Shift returns BlockhashFunction
	 *     Shift.Shift_1_0 returns BlockhashFunction
	 *     AddSub returns BlockhashFunction
	 *     AddSub.AddSub_1_0_0 returns BlockhashFunction
	 *     MulDivMod returns BlockhashFunction
	 *     MulDivMod.MulDivMod_1_0 returns BlockhashFunction
	 *     Exponent returns BlockhashFunction
	 *     Exponent.Exponent_1_0 returns BlockhashFunction
	 *     UnaryExpression returns BlockhashFunction
	 *     PreExpression returns BlockhashFunction
	 *     PreExpression.PreIncExpression_1_2 returns BlockhashFunction
	 *     PreExpression.PreDecExpression_2_2 returns BlockhashFunction
	 *     PostIncDecExpression returns BlockhashFunction
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BlockhashFunction
	 *     PrimaryExpression returns BlockhashFunction
	 *     PrimaryExpression.Tuple_4_2_0 returns BlockhashFunction
	 *     Literal returns BlockhashFunction
	 *     BlockhashFunction returns BlockhashFunction
	 *     PrimaryArithmetic returns BlockhashFunction
	 *
	 * Constraint:
	 *     parameter=IntParameter
	 */
	protected void sequence_BlockhashFunction(ISerializationContext context, BlockhashFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BLOCKHASH_FUNCTION__PARAMETER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BLOCKHASH_FUNCTION__PARAMETER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBlockhashFunctionAccess().getParameterIntParameterParserRuleCall_2_0(), semanticObject.getParameter());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Block
	 *     Body returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)?
	 */
	protected void sequence_Body(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanConst
	 *     Assignment returns BooleanConst
	 *     Assignment.Assignment_1_0_0 returns BooleanConst
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BooleanConst
	 *     BinaryExpression returns BooleanConst
	 *     Or returns BooleanConst
	 *     Or.Or_1_0 returns BooleanConst
	 *     And returns BooleanConst
	 *     And.And_1_0 returns BooleanConst
	 *     Equality returns BooleanConst
	 *     Equality.Equality_1_0 returns BooleanConst
	 *     Comparison returns BooleanConst
	 *     Comparison.Comparison_1_0 returns BooleanConst
	 *     BitOr returns BooleanConst
	 *     BitOr.BitOr_1_0 returns BooleanConst
	 *     BitXor returns BooleanConst
	 *     BitXor.BitXor_1_0 returns BooleanConst
	 *     BitAnd returns BooleanConst
	 *     BitAnd.BitAnd_1_0 returns BooleanConst
	 *     Shift returns BooleanConst
	 *     Shift.Shift_1_0 returns BooleanConst
	 *     AddSub returns BooleanConst
	 *     AddSub.AddSub_1_0_0 returns BooleanConst
	 *     MulDivMod returns BooleanConst
	 *     MulDivMod.MulDivMod_1_0 returns BooleanConst
	 *     Exponent returns BooleanConst
	 *     Exponent.Exponent_1_0 returns BooleanConst
	 *     UnaryExpression returns BooleanConst
	 *     PreExpression returns BooleanConst
	 *     PreExpression.PreIncExpression_1_2 returns BooleanConst
	 *     PreExpression.PreDecExpression_2_2 returns BooleanConst
	 *     PostIncDecExpression returns BooleanConst
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BooleanConst
	 *     PrimaryExpression returns BooleanConst
	 *     PrimaryExpression.Tuple_4_2_0 returns BooleanConst
	 *     Literal returns BooleanConst
	 *     PrimaryArithmetic returns BooleanConst
	 *     BooleanConst returns BooleanConst
	 *
	 * Constraint:
	 *     value=BooleanLiteralEnum
	 */
	protected void sequence_BooleanConst(ISerializationContext context, BooleanConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.BOOLEAN_CONST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.BOOLEAN_CONST__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanConstAccess().getValueBooleanLiteralEnumEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Assignment returns Comparison
	 *     Assignment.Assignment_1_0_0 returns Comparison
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Comparison
	 *     BinaryExpression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     BitOr returns Comparison
	 *     BitOr.BitOr_1_0 returns Comparison
	 *     BitXor returns Comparison
	 *     BitXor.BitXor_1_0 returns Comparison
	 *     BitAnd returns Comparison
	 *     BitAnd.BitAnd_1_0 returns Comparison
	 *     Shift returns Comparison
	 *     Shift.Shift_1_0 returns Comparison
	 *     AddSub returns Comparison
	 *     AddSub.AddSub_1_0_0 returns Comparison
	 *     MulDivMod returns Comparison
	 *     MulDivMod.MulDivMod_1_0 returns Comparison
	 *     Exponent returns Comparison
	 *     Exponent.Exponent_1_0 returns Comparison
	 *     UnaryExpression returns Comparison
	 *     PreExpression returns Comparison
	 *     PreExpression.PreIncExpression_1_2 returns Comparison
	 *     PreExpression.PreDecExpression_2_2 returns Comparison
	 *     PostIncDecExpression returns Comparison
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Comparison
	 *     PrimaryExpression returns Comparison
	 *     PrimaryExpression.Tuple_4_2_0 returns Comparison
	 *     PrimaryArithmetic returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 comparisonOp=ComparisonOpEnum right=BitOr)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.COMPARISON__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.COMPARISON__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.COMPARISON__COMPARISON_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.COMPARISON__COMPARISON_OP));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.COMPARISON__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.COMPARISON__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonOpComparisonOpEnumEnumRuleCall_1_1_0(), semanticObject.getComparisonOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRightBitOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     {Const}
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns ConstantSpecifier
	 *     ConstantSpecifier returns ConstantSpecifier
	 *
	 * Constraint:
	 *     {ConstantSpecifier}
	 */
	protected void sequence_ConstantSpecifier(ISerializationContext context, ConstantSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Continue
	 *     ContinueStatement returns Continue
	 *
	 * Constraint:
	 *     {Continue}
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, Continue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID (inheritanceSpecifiers+=InheritanceSpecifier inheritanceSpecifiers+=InheritanceSpecifier*)? body=DefinitionBody)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DecimalLiteral returns DecimalLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_DecimalLiteral(ISerializationContext context, DecimalLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.DECIMAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.DECIMAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalLiteralAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionBody returns DefinitionBody
	 *
	 * Constraint:
	 *     (
	 *         functions+=FunctionDefinition | 
	 *         structs+=StructDefinition | 
	 *         enums+=EnumDefinition | 
	 *         variables+=VariableDeclaration | 
	 *         modifiers+=Modifier | 
	 *         events+=Event
	 *     )*
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, DefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteStatement
	 *     DeleteStatement returns DeleteStatement
	 *
	 * Constraint:
	 *     variable=QualifiedIdentifier
	 */
	protected void sequence_DeleteStatement(ISerializationContext context, DeleteStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.DELETE_STATEMENT__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.DELETE_STATEMENT__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteStatementAccess().getVariableQualifiedIdentifierParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EcrecoverFunction
	 *     Assignment returns EcrecoverFunction
	 *     Assignment.Assignment_1_0_0 returns EcrecoverFunction
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns EcrecoverFunction
	 *     BinaryExpression returns EcrecoverFunction
	 *     Or returns EcrecoverFunction
	 *     Or.Or_1_0 returns EcrecoverFunction
	 *     And returns EcrecoverFunction
	 *     And.And_1_0 returns EcrecoverFunction
	 *     Equality returns EcrecoverFunction
	 *     Equality.Equality_1_0 returns EcrecoverFunction
	 *     Comparison returns EcrecoverFunction
	 *     Comparison.Comparison_1_0 returns EcrecoverFunction
	 *     BitOr returns EcrecoverFunction
	 *     BitOr.BitOr_1_0 returns EcrecoverFunction
	 *     BitXor returns EcrecoverFunction
	 *     BitXor.BitXor_1_0 returns EcrecoverFunction
	 *     BitAnd returns EcrecoverFunction
	 *     BitAnd.BitAnd_1_0 returns EcrecoverFunction
	 *     Shift returns EcrecoverFunction
	 *     Shift.Shift_1_0 returns EcrecoverFunction
	 *     AddSub returns EcrecoverFunction
	 *     AddSub.AddSub_1_0_0 returns EcrecoverFunction
	 *     MulDivMod returns EcrecoverFunction
	 *     MulDivMod.MulDivMod_1_0 returns EcrecoverFunction
	 *     Exponent returns EcrecoverFunction
	 *     Exponent.Exponent_1_0 returns EcrecoverFunction
	 *     UnaryExpression returns EcrecoverFunction
	 *     PreExpression returns EcrecoverFunction
	 *     PreExpression.PreIncExpression_1_2 returns EcrecoverFunction
	 *     PreExpression.PreDecExpression_2_2 returns EcrecoverFunction
	 *     PostIncDecExpression returns EcrecoverFunction
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns EcrecoverFunction
	 *     PrimaryExpression returns EcrecoverFunction
	 *     PrimaryExpression.Tuple_4_2_0 returns EcrecoverFunction
	 *     Literal returns EcrecoverFunction
	 *     EcrecoverFunction returns EcrecoverFunction
	 *     PrimaryArithmetic returns EcrecoverFunction
	 *
	 * Constraint:
	 *     (function='ecrecover' parameters+=IntParameter parameters+=IntParameter parameters+=IntParameter parameters+=IntParameter)
	 */
	protected void sequence_EcrecoverFunction(ISerializationContext context, EcrecoverFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementaryTypeNameEnum returns ElementaryTypeNameEnum
	 *
	 * Constraint:
	 *     (
	 *         type='int' | 
	 *         type='int16' | 
	 *         type='int24' | 
	 *         type='int32' | 
	 *         type='int40' | 
	 *         type='int48' | 
	 *         type='int56' | 
	 *         type='int64' | 
	 *         type='int72' | 
	 *         type='int80' | 
	 *         type='int88' | 
	 *         type='int96' | 
	 *         type='int104' | 
	 *         type='int112' | 
	 *         type='int120' | 
	 *         type='int128' | 
	 *         type='int136' | 
	 *         type='int144' | 
	 *         type='int152' | 
	 *         type='int160' | 
	 *         type='int168' | 
	 *         type='int178' | 
	 *         type='int184' | 
	 *         type='int192' | 
	 *         type='int200' | 
	 *         type='int208' | 
	 *         type='int216' | 
	 *         type='int224' | 
	 *         type='int232' | 
	 *         type='int240' | 
	 *         type='int248' | 
	 *         type='int256' | 
	 *         type='uint' | 
	 *         type='uint8' | 
	 *         type='uint16' | 
	 *         type='uint24' | 
	 *         type='uint32' | 
	 *         type='uint40' | 
	 *         type='uint48' | 
	 *         type='uint56' | 
	 *         type='uint64' | 
	 *         type='uint72' | 
	 *         type='uint80' | 
	 *         type='uint88' | 
	 *         type='uint96' | 
	 *         type='uint104' | 
	 *         type='uint112' | 
	 *         type='uint120' | 
	 *         type='uint128' | 
	 *         type='uint136' | 
	 *         type='uint144' | 
	 *         type='uint152' | 
	 *         type='uint160' | 
	 *         type='uint168' | 
	 *         type='uint178' | 
	 *         type='uint184' | 
	 *         type='uint192' | 
	 *         type='uint200' | 
	 *         type='uint208' | 
	 *         type='uint216' | 
	 *         type='uint224' | 
	 *         type='uint232' | 
	 *         type='uint240' | 
	 *         type='uint248' | 
	 *         type='uint256' | 
	 *         type='byte' | 
	 *         type='bytes' | 
	 *         type='bytes1' | 
	 *         type='bytes2' | 
	 *         type='bytes3' | 
	 *         type='bytes4' | 
	 *         type='bytes5' | 
	 *         type='bytes6' | 
	 *         type='bytes7' | 
	 *         type='bytes8' | 
	 *         type='bytes9' | 
	 *         type='bytes10' | 
	 *         type='bytes11' | 
	 *         type='bytes12' | 
	 *         type='bytes13' | 
	 *         type='bytes14' | 
	 *         type='bytes15' | 
	 *         type='bytes16' | 
	 *         type='bytes17' | 
	 *         type='bytes18' | 
	 *         type='bytes19' | 
	 *         type='bytes20' | 
	 *         type='bytes21' | 
	 *         type='bytes22' | 
	 *         type='bytes23' | 
	 *         type='bytes24' | 
	 *         type='bytes25' | 
	 *         type='bytes26' | 
	 *         type='bytes27' | 
	 *         type='bytes28' | 
	 *         type='bytes29' | 
	 *         type='bytes30' | 
	 *         type='bytes31' | 
	 *         type='bytes32' | 
	 *         type='string' | 
	 *         type='address' | 
	 *         type='bool' | 
	 *         type='real' | 
	 *         type='ureal'
	 *     )
	 */
	protected void sequence_ElementaryTypeNameEnum(ISerializationContext context, ElementaryTypeNameEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ElementaryType returns ElementaryType
	 *
	 * Constraint:
	 *     name=ElementaryTypeNameEnum
	 */
	protected void sequence_ElementaryType(ISerializationContext context, ElementaryType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ELEMENTARY_TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ELEMENTARY_TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementaryTypeAccess().getNameElementaryTypeNameEnumParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StandardTypeWithoutQualifiedIdentifier returns ElementaryType
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns ElementaryType
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ElementaryType
	 *     StandardType returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardType(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumDefinition returns EnumDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilityEnum? name=ID (members+=EnumValue members+=EnumValue*)?)
	 */
	protected void sequence_EnumDefinition(ISerializationContext context, EnumDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ENUM_VALUE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ENUM_VALUE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Assignment returns Equality
	 *     Assignment.Assignment_1_0_0 returns Equality
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Equality
	 *     BinaryExpression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     BitOr returns Equality
	 *     BitOr.BitOr_1_0 returns Equality
	 *     BitXor returns Equality
	 *     BitXor.BitXor_1_0 returns Equality
	 *     BitAnd returns Equality
	 *     BitAnd.BitAnd_1_0 returns Equality
	 *     Shift returns Equality
	 *     Shift.Shift_1_0 returns Equality
	 *     AddSub returns Equality
	 *     AddSub.AddSub_1_0_0 returns Equality
	 *     MulDivMod returns Equality
	 *     MulDivMod.MulDivMod_1_0 returns Equality
	 *     Exponent returns Equality
	 *     Exponent.Exponent_1_0 returns Equality
	 *     UnaryExpression returns Equality
	 *     PreExpression returns Equality
	 *     PreExpression.PreIncExpression_1_2 returns Equality
	 *     PreExpression.PreDecExpression_2_2 returns Equality
	 *     PostIncDecExpression returns Equality
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Equality
	 *     PrimaryExpression returns Equality
	 *     PrimaryExpression.Tuple_4_2_0 returns Equality
	 *     PrimaryArithmetic returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 equalityOp=EqualityOpEnum right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EQUALITY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EQUALITY__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EQUALITY__EQUALITY_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EQUALITY__EQUALITY_OP));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EQUALITY__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EQUALITY__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityOpEqualityOpEnumEnumRuleCall_1_1_0(), semanticObject.getEqualityOp());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ether returns Ether
	 *
	 * Constraint:
	 *     (value=INT ether=EtherSubDenominationEnum)
	 */
	protected void sequence_Ether(ISerializationContext context, Ether semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ETHER__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ETHER__VALUE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.ETHER__ETHER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.ETHER__ETHER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEtherAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEtherAccess().getEtherEtherSubDenominationEnumEnumRuleCall_1_0(), semanticObject.getEther());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Exponent
	 *     Assignment returns Exponent
	 *     Assignment.Assignment_1_0_0 returns Exponent
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Exponent
	 *     BinaryExpression returns Exponent
	 *     Or returns Exponent
	 *     Or.Or_1_0 returns Exponent
	 *     And returns Exponent
	 *     And.And_1_0 returns Exponent
	 *     Equality returns Exponent
	 *     Equality.Equality_1_0 returns Exponent
	 *     Comparison returns Exponent
	 *     Comparison.Comparison_1_0 returns Exponent
	 *     BitOr returns Exponent
	 *     BitOr.BitOr_1_0 returns Exponent
	 *     BitXor returns Exponent
	 *     BitXor.BitXor_1_0 returns Exponent
	 *     BitAnd returns Exponent
	 *     BitAnd.BitAnd_1_0 returns Exponent
	 *     Shift returns Exponent
	 *     Shift.Shift_1_0 returns Exponent
	 *     AddSub returns Exponent
	 *     AddSub.AddSub_1_0_0 returns Exponent
	 *     MulDivMod returns Exponent
	 *     MulDivMod.MulDivMod_1_0 returns Exponent
	 *     Exponent returns Exponent
	 *     Exponent.Exponent_1_0 returns Exponent
	 *     UnaryExpression returns Exponent
	 *     PreExpression returns Exponent
	 *     PreExpression.PreIncExpression_1_2 returns Exponent
	 *     PreExpression.PreDecExpression_2_2 returns Exponent
	 *     PostIncDecExpression returns Exponent
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Exponent
	 *     PrimaryExpression returns Exponent
	 *     PrimaryExpression.Tuple_4_2_0 returns Exponent
	 *     PrimaryArithmetic returns Exponent
	 *
	 * Constraint:
	 *     (left=Exponent_Exponent_1_0 right=UnaryExpression)
	 */
	protected void sequence_Exponent(ISerializationContext context, Exponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPONENT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPONENT__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPONENT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPONENT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExponentAccess().getExponentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExponentAccess().getRightUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns ExpressionStatement
	 *     Statement returns ExpressionStatement
	 *
	 * Constraint:
	 *     (expression=Expression semicolon?=';')
	 */
	protected void sequence_ExpressionStatement_SimpleStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.EXPRESSION_STATEMENT__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     field=ID
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.FIELD__FIELD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.FIELD__FIELD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getFieldIDTerminalRuleCall_1_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (initExpression=SimpleStatement2? conditionExpression=Expression? loopExpression=ExpressionStatement? body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArg returns FunctionCallArg
	 *
	 * Constraint:
	 *     (name=ID expr=Expression)
	 */
	protected void sequence_FunctionCallArg(ISerializationContext context, FunctionCallArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__NAME));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__EXPR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.FUNCTION_CALL_ARG__EXPR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArguments returns FunctionCallArguments
	 *
	 * Constraint:
	 *     (args+=FunctionCallArg args+=FunctionCallArg*)?
	 */
	protected void sequence_FunctionCallArguments(ISerializationContext context, FunctionCallArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallListArguments returns FunctionCallListArguments
	 *     FunctionCallArguments returns FunctionCallListArguments
	 *
	 * Constraint:
	 *     (arguments+=Expression arguments+=Expression*)?
	 */
	protected void sequence_FunctionCallListArguments(ISerializationContext context, FunctionCallListArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCall returns FunctionCall
	 *
	 * Constraint:
	 *     (name=[FunctionDefinition|ID] (parameters+=Expression parameters+=Expression*)?)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, FunctionCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (
	 *         payable?='payable'? 
	 *         name=ID 
	 *         parameters=ParameterList 
	 *         visibility=VisibilityEnum 
	 *         optionalElements+=FunctionDefinitionOptionalElement* 
	 *         returnParameters=ReturnsParameterList? 
	 *         block=Body?
	 *     )
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GasleftFunction
	 *     Assignment returns GasleftFunction
	 *     Assignment.Assignment_1_0_0 returns GasleftFunction
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns GasleftFunction
	 *     BinaryExpression returns GasleftFunction
	 *     Or returns GasleftFunction
	 *     Or.Or_1_0 returns GasleftFunction
	 *     And returns GasleftFunction
	 *     And.And_1_0 returns GasleftFunction
	 *     Equality returns GasleftFunction
	 *     Equality.Equality_1_0 returns GasleftFunction
	 *     Comparison returns GasleftFunction
	 *     Comparison.Comparison_1_0 returns GasleftFunction
	 *     BitOr returns GasleftFunction
	 *     BitOr.BitOr_1_0 returns GasleftFunction
	 *     BitXor returns GasleftFunction
	 *     BitXor.BitXor_1_0 returns GasleftFunction
	 *     BitAnd returns GasleftFunction
	 *     BitAnd.BitAnd_1_0 returns GasleftFunction
	 *     Shift returns GasleftFunction
	 *     Shift.Shift_1_0 returns GasleftFunction
	 *     AddSub returns GasleftFunction
	 *     AddSub.AddSub_1_0_0 returns GasleftFunction
	 *     MulDivMod returns GasleftFunction
	 *     MulDivMod.MulDivMod_1_0 returns GasleftFunction
	 *     Exponent returns GasleftFunction
	 *     Exponent.Exponent_1_0 returns GasleftFunction
	 *     UnaryExpression returns GasleftFunction
	 *     PreExpression returns GasleftFunction
	 *     PreExpression.PreIncExpression_1_2 returns GasleftFunction
	 *     PreExpression.PreDecExpression_2_2 returns GasleftFunction
	 *     PostIncDecExpression returns GasleftFunction
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns GasleftFunction
	 *     PrimaryExpression returns GasleftFunction
	 *     PrimaryExpression.Tuple_4_2_0 returns GasleftFunction
	 *     Literal returns GasleftFunction
	 *     GasleftFunction returns GasleftFunction
	 *     PrimaryArithmetic returns GasleftFunction
	 *
	 * Constraint:
	 *     name='gasleft'
	 */
	protected void sequence_GasleftFunction(ISerializationContext context, GasleftFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.GASLEFT_FUNCTION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.GASLEFT_FUNCTION__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGasleftFunctionAccess().getNameGasleftKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HashFunction
	 *     Assignment returns HashFunction
	 *     Assignment.Assignment_1_0_0 returns HashFunction
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns HashFunction
	 *     BinaryExpression returns HashFunction
	 *     Or returns HashFunction
	 *     Or.Or_1_0 returns HashFunction
	 *     And returns HashFunction
	 *     And.And_1_0 returns HashFunction
	 *     Equality returns HashFunction
	 *     Equality.Equality_1_0 returns HashFunction
	 *     Comparison returns HashFunction
	 *     Comparison.Comparison_1_0 returns HashFunction
	 *     BitOr returns HashFunction
	 *     BitOr.BitOr_1_0 returns HashFunction
	 *     BitXor returns HashFunction
	 *     BitXor.BitXor_1_0 returns HashFunction
	 *     BitAnd returns HashFunction
	 *     BitAnd.BitAnd_1_0 returns HashFunction
	 *     Shift returns HashFunction
	 *     Shift.Shift_1_0 returns HashFunction
	 *     AddSub returns HashFunction
	 *     AddSub.AddSub_1_0_0 returns HashFunction
	 *     MulDivMod returns HashFunction
	 *     MulDivMod.MulDivMod_1_0 returns HashFunction
	 *     Exponent returns HashFunction
	 *     Exponent.Exponent_1_0 returns HashFunction
	 *     UnaryExpression returns HashFunction
	 *     PreExpression returns HashFunction
	 *     PreExpression.PreIncExpression_1_2 returns HashFunction
	 *     PreExpression.PreDecExpression_2_2 returns HashFunction
	 *     PostIncDecExpression returns HashFunction
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns HashFunction
	 *     PrimaryExpression returns HashFunction
	 *     PrimaryExpression.Tuple_4_2_0 returns HashFunction
	 *     Literal returns HashFunction
	 *     HashFunction returns HashFunction
	 *     PrimaryArithmetic returns HashFunction
	 *
	 * Constraint:
	 *     ((name='keccak256' | name='sha256' | name='ripemd160') parameters=IntParameter)
	 */
	protected void sequence_HashFunction(ISerializationContext context, HashFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     HexLiteral returns HexLiteral
	 *
	 * Constraint:
	 *     value=HEX
	 */
	protected void sequence_HexLiteral(ISerializationContext context, HexLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.HEX_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.HEX_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHexLiteralAccess().getValueHEXTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression trueBody=Statement falseBody=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDirective returns ImportDirective
	 *
	 * Constraint:
	 *     (importURI=STRING | (unitAlias=ID importURI=STRING) | (symbolAliases+=SymbolAlias symbolAliases+=SymbolAlias? importURI=STRING))
	 */
	protected void sequence_ImportDirective(ISerializationContext context, ImportDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Index
	 *     Index returns Index
	 *
	 * Constraint:
	 *     value=Expression?
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns IndexedSpecifer
	 *     IndexedSpecifer returns IndexedSpecifer
	 *
	 * Constraint:
	 *     {IndexedSpecifer}
	 */
	protected void sequence_IndexedSpecifer(ISerializationContext context, IndexedSpecifer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InheritanceSpecifier returns InheritanceSpecifier
	 *
	 * Constraint:
	 *     (SuperType=Contract args=FunctionCallListArguments?)
	 */
	protected void sequence_InheritanceSpecifier(ISerializationContext context, InheritanceSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IntParameter returns IntParameter
	 *
	 * Constraint:
	 *     (param=ArithmeticOperations | fun=FunctionCall)
	 */
	protected void sequence_IntParameter(ISerializationContext context, IntParameter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LocationSpecifierEnum returns LocationSpecifierEnum
	 *
	 * Constraint:
	 *     (type='memory' | type='storage' | type='calldata')
	 */
	protected void sequence_LocationSpecifierEnum(ISerializationContext context, LocationSpecifierEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns LocationSpecifier
	 *     LocationSpecifier returns LocationSpecifier
	 *
	 * Constraint:
	 *     location=LocationSpecifierEnum
	 */
	protected void sequence_LocationSpecifier(ISerializationContext context, LocationSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.LOCATION_SPECIFIER__LOCATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.LOCATION_SPECIFIER__LOCATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationSpecifierAccess().getLocationLocationSpecifierEnumParserRuleCall_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Mapping
	 *     StandardType returns Mapping
	 *     StandardTypeWithoutQualifiedIdentifier returns Mapping
	 *     Mapping returns Mapping
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns Mapping
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns Mapping
	 *
	 * Constraint:
	 *     (location='storage'? visibility=VisibilityEnum? keyType=ElementaryTypeNameEnum valueType=Type name=ID)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MathematicalFunction
	 *     Assignment returns MathematicalFunction
	 *     Assignment.Assignment_1_0_0 returns MathematicalFunction
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns MathematicalFunction
	 *     BinaryExpression returns MathematicalFunction
	 *     Or returns MathematicalFunction
	 *     Or.Or_1_0 returns MathematicalFunction
	 *     And returns MathematicalFunction
	 *     And.And_1_0 returns MathematicalFunction
	 *     Equality returns MathematicalFunction
	 *     Equality.Equality_1_0 returns MathematicalFunction
	 *     Comparison returns MathematicalFunction
	 *     Comparison.Comparison_1_0 returns MathematicalFunction
	 *     BitOr returns MathematicalFunction
	 *     BitOr.BitOr_1_0 returns MathematicalFunction
	 *     BitXor returns MathematicalFunction
	 *     BitXor.BitXor_1_0 returns MathematicalFunction
	 *     BitAnd returns MathematicalFunction
	 *     BitAnd.BitAnd_1_0 returns MathematicalFunction
	 *     Shift returns MathematicalFunction
	 *     Shift.Shift_1_0 returns MathematicalFunction
	 *     AddSub returns MathematicalFunction
	 *     AddSub.AddSub_1_0_0 returns MathematicalFunction
	 *     MulDivMod returns MathematicalFunction
	 *     MulDivMod.MulDivMod_1_0 returns MathematicalFunction
	 *     Exponent returns MathematicalFunction
	 *     Exponent.Exponent_1_0 returns MathematicalFunction
	 *     UnaryExpression returns MathematicalFunction
	 *     PreExpression returns MathematicalFunction
	 *     PreExpression.PreIncExpression_1_2 returns MathematicalFunction
	 *     PreExpression.PreDecExpression_2_2 returns MathematicalFunction
	 *     PostIncDecExpression returns MathematicalFunction
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns MathematicalFunction
	 *     PrimaryExpression returns MathematicalFunction
	 *     PrimaryExpression.Tuple_4_2_0 returns MathematicalFunction
	 *     Literal returns MathematicalFunction
	 *     MathematicalFunction returns MathematicalFunction
	 *     PrimaryArithmetic returns MathematicalFunction
	 *
	 * Constraint:
	 *     ((function='addmod' | function='mulmod') parameters+=IntParameter parameters+=IntParameter parameters+=IntParameter)
	 */
	protected void sequence_MathematicalFunction(ISerializationContext context, MathematicalFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns ModifierInvocation
	 *     ModifierInvocation returns ModifierInvocation
	 *
	 * Constraint:
	 *     (name=[Modifier|ID] args=FunctionCallListArguments?)
	 */
	protected void sequence_ModifierInvocation(ISerializationContext context, ModifierInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList? block=Body)
	 */
	protected void sequence_Modifier(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulDivMod
	 *     Assignment returns MulDivMod
	 *     Assignment.Assignment_1_0_0 returns MulDivMod
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns MulDivMod
	 *     BinaryExpression returns MulDivMod
	 *     Or returns MulDivMod
	 *     Or.Or_1_0 returns MulDivMod
	 *     And returns MulDivMod
	 *     And.And_1_0 returns MulDivMod
	 *     Equality returns MulDivMod
	 *     Equality.Equality_1_0 returns MulDivMod
	 *     Comparison returns MulDivMod
	 *     Comparison.Comparison_1_0 returns MulDivMod
	 *     BitOr returns MulDivMod
	 *     BitOr.BitOr_1_0 returns MulDivMod
	 *     BitXor returns MulDivMod
	 *     BitXor.BitXor_1_0 returns MulDivMod
	 *     BitAnd returns MulDivMod
	 *     BitAnd.BitAnd_1_0 returns MulDivMod
	 *     Shift returns MulDivMod
	 *     Shift.Shift_1_0 returns MulDivMod
	 *     AddSub returns MulDivMod
	 *     AddSub.AddSub_1_0_0 returns MulDivMod
	 *     MulDivMod returns MulDivMod
	 *     MulDivMod.MulDivMod_1_0 returns MulDivMod
	 *     Exponent returns MulDivMod
	 *     Exponent.Exponent_1_0 returns MulDivMod
	 *     UnaryExpression returns MulDivMod
	 *     PreExpression returns MulDivMod
	 *     PreExpression.PreIncExpression_1_2 returns MulDivMod
	 *     PreExpression.PreDecExpression_2_2 returns MulDivMod
	 *     PostIncDecExpression returns MulDivMod
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns MulDivMod
	 *     PrimaryExpression returns MulDivMod
	 *     PrimaryExpression.Tuple_4_2_0 returns MulDivMod
	 *     PrimaryArithmetic returns MulDivMod
	 *
	 * Constraint:
	 *     (left=MulDivMod_MulDivMod_1_0 multipliciativeOp=MulDivModOpEnum right=Exponent)
	 */
	protected void sequence_MulDivMod(ISerializationContext context, MulDivMod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.MUL_DIV_MOD__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.MUL_DIV_MOD__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.MUL_DIV_MOD__MULTIPLICIATIVE_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.MUL_DIV_MOD__MULTIPLICIATIVE_OP));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.MUL_DIV_MOD__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.MUL_DIV_MOD__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivModAccess().getMultipliciativeOpMulDivModOpEnumEnumRuleCall_1_1_0(), semanticObject.getMultipliciativeOp());
		feeder.accept(grammarAccess.getMulDivModAccess().getRightExponentParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NewExpression
	 *     Assignment returns NewExpression
	 *     Assignment.Assignment_1_0_0 returns NewExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NewExpression
	 *     BinaryExpression returns NewExpression
	 *     Or returns NewExpression
	 *     Or.Or_1_0 returns NewExpression
	 *     And returns NewExpression
	 *     And.And_1_0 returns NewExpression
	 *     Equality returns NewExpression
	 *     Equality.Equality_1_0 returns NewExpression
	 *     Comparison returns NewExpression
	 *     Comparison.Comparison_1_0 returns NewExpression
	 *     BitOr returns NewExpression
	 *     BitOr.BitOr_1_0 returns NewExpression
	 *     BitXor returns NewExpression
	 *     BitXor.BitXor_1_0 returns NewExpression
	 *     BitAnd returns NewExpression
	 *     BitAnd.BitAnd_1_0 returns NewExpression
	 *     Shift returns NewExpression
	 *     Shift.Shift_1_0 returns NewExpression
	 *     AddSub returns NewExpression
	 *     AddSub.AddSub_1_0_0 returns NewExpression
	 *     MulDivMod returns NewExpression
	 *     MulDivMod.MulDivMod_1_0 returns NewExpression
	 *     Exponent returns NewExpression
	 *     Exponent.Exponent_1_0 returns NewExpression
	 *     UnaryExpression returns NewExpression
	 *     NewExpression returns NewExpression
	 *     PreExpression returns NewExpression
	 *     PreExpression.PreIncExpression_1_2 returns NewExpression
	 *     PreExpression.PreDecExpression_2_2 returns NewExpression
	 *     PostIncDecExpression returns NewExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NewExpression
	 *     PrimaryExpression returns NewExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns NewExpression
	 *     PrimaryArithmetic returns NewExpression
	 *
	 * Constraint:
	 *     (contract=[Contract|ID] args=FunctionCallListArguments)
	 */
	protected void sequence_NewExpression(ISerializationContext context, NewExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.NEW_EXPRESSION__CONTRACT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.NEW_EXPRESSION__CONTRACT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.NEW_EXPRESSION__ARGS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.NEW_EXPRESSION__ARGS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNewExpressionAccess().getContractContractIDTerminalRuleCall_1_0_1(), semanticObject.eGet(OptGrammarPackage.Literals.NEW_EXPRESSION__CONTRACT, false));
		feeder.accept(grammarAccess.getNewExpressionAccess().getArgsFunctionCallListArgumentsParserRuleCall_2_0(), semanticObject.getArgs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     Assignment returns NotExpression
	 *     Assignment.Assignment_1_0_0 returns NotExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NotExpression
	 *     BinaryExpression returns NotExpression
	 *     Or returns NotExpression
	 *     Or.Or_1_0 returns NotExpression
	 *     And returns NotExpression
	 *     And.And_1_0 returns NotExpression
	 *     Equality returns NotExpression
	 *     Equality.Equality_1_0 returns NotExpression
	 *     Comparison returns NotExpression
	 *     Comparison.Comparison_1_0 returns NotExpression
	 *     BitOr returns NotExpression
	 *     BitOr.BitOr_1_0 returns NotExpression
	 *     BitXor returns NotExpression
	 *     BitXor.BitXor_1_0 returns NotExpression
	 *     BitAnd returns NotExpression
	 *     BitAnd.BitAnd_1_0 returns NotExpression
	 *     Shift returns NotExpression
	 *     Shift.Shift_1_0 returns NotExpression
	 *     AddSub returns NotExpression
	 *     AddSub.AddSub_1_0_0 returns NotExpression
	 *     MulDivMod returns NotExpression
	 *     MulDivMod.MulDivMod_1_0 returns NotExpression
	 *     Exponent returns NotExpression
	 *     Exponent.Exponent_1_0 returns NotExpression
	 *     UnaryExpression returns NotExpression
	 *     NotExpression returns NotExpression
	 *     PreExpression returns NotExpression
	 *     PreExpression.PreIncExpression_1_2 returns NotExpression
	 *     PreExpression.PreDecExpression_2_2 returns NotExpression
	 *     PostIncDecExpression returns NotExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NotExpression
	 *     PrimaryExpression returns NotExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns NotExpression
	 *     PrimaryArithmetic returns NotExpression
	 *
	 * Constraint:
	 *     expression=UnaryExpression
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.NOT_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.NOT_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Now returns Now
	 *
	 * Constraint:
	 *     {Now}
	 */
	protected void sequence_Now(ISerializationContext context, Now semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     NumberDimensionless returns NumberDimensionless
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberDimensionless(ISerializationContext context, NumberDimensionless semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.NUMBER_DIMENSIONLESS__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.NUMBER_DIMENSIONLESS__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberDimensionlessAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumericLiteral
	 *     Assignment returns NumericLiteral
	 *     Assignment.Assignment_1_0_0 returns NumericLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NumericLiteral
	 *     BinaryExpression returns NumericLiteral
	 *     Or returns NumericLiteral
	 *     Or.Or_1_0 returns NumericLiteral
	 *     And returns NumericLiteral
	 *     And.And_1_0 returns NumericLiteral
	 *     Equality returns NumericLiteral
	 *     Equality.Equality_1_0 returns NumericLiteral
	 *     Comparison returns NumericLiteral
	 *     Comparison.Comparison_1_0 returns NumericLiteral
	 *     BitOr returns NumericLiteral
	 *     BitOr.BitOr_1_0 returns NumericLiteral
	 *     BitXor returns NumericLiteral
	 *     BitXor.BitXor_1_0 returns NumericLiteral
	 *     BitAnd returns NumericLiteral
	 *     BitAnd.BitAnd_1_0 returns NumericLiteral
	 *     Shift returns NumericLiteral
	 *     Shift.Shift_1_0 returns NumericLiteral
	 *     AddSub returns NumericLiteral
	 *     AddSub.AddSub_1_0_0 returns NumericLiteral
	 *     MulDivMod returns NumericLiteral
	 *     MulDivMod.MulDivMod_1_0 returns NumericLiteral
	 *     Exponent returns NumericLiteral
	 *     Exponent.Exponent_1_0 returns NumericLiteral
	 *     UnaryExpression returns NumericLiteral
	 *     PreExpression returns NumericLiteral
	 *     PreExpression.PreIncExpression_1_2 returns NumericLiteral
	 *     PreExpression.PreDecExpression_2_2 returns NumericLiteral
	 *     PostIncDecExpression returns NumericLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NumericLiteral
	 *     PrimaryExpression returns NumericLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns NumericLiteral
	 *     Literal returns NumericLiteral
	 *     PrimaryArithmetic returns NumericLiteral
	 *     NumericLiteral returns NumericLiteral
	 *
	 * Constraint:
	 *     ((intValue=NumberDimensionless | hexValue=HexLiteral | decimalValue=DecimalLiteral | now=Now) etherUnit=UnitTypes?)
	 */
	protected void sequence_NumericLiteral(ISerializationContext context, NumericLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Assignment returns Or
	 *     Assignment.Assignment_1_0_0 returns Or
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Or
	 *     BinaryExpression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     BitOr returns Or
	 *     BitOr.BitOr_1_0 returns Or
	 *     BitXor returns Or
	 *     BitXor.BitXor_1_0 returns Or
	 *     BitAnd returns Or
	 *     BitAnd.BitAnd_1_0 returns Or
	 *     Shift returns Or
	 *     Shift.Shift_1_0 returns Or
	 *     AddSub returns Or
	 *     AddSub.AddSub_1_0_0 returns Or
	 *     MulDivMod returns Or
	 *     MulDivMod.MulDivMod_1_0 returns Or
	 *     Exponent returns Or
	 *     Exponent.Exponent_1_0 returns Or
	 *     UnaryExpression returns Or
	 *     PreExpression returns Or
	 *     PreExpression.PreIncExpression_1_2 returns Or
	 *     PreExpression.PreDecExpression_2_2 returns Or
	 *     PostIncDecExpression returns Or
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Or
	 *     PrimaryExpression returns Or
	 *     PrimaryExpression.Tuple_4_2_0 returns Or
	 *     PrimaryArithmetic returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=VariableDeclaration parameters+=VariableDeclaration*)?
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlaceHolderStatement
	 *     PlaceHolderStatement returns PlaceHolderStatement
	 *
	 * Constraint:
	 *     {PlaceHolderStatement}
	 */
	protected void sequence_PlaceHolderStatement(ISerializationContext context, PlaceHolderStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PostIncDecExpression
	 *     Assignment returns PostIncDecExpression
	 *     Assignment.Assignment_1_0_0 returns PostIncDecExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PostIncDecExpression
	 *     BinaryExpression returns PostIncDecExpression
	 *     Or returns PostIncDecExpression
	 *     Or.Or_1_0 returns PostIncDecExpression
	 *     And returns PostIncDecExpression
	 *     And.And_1_0 returns PostIncDecExpression
	 *     Equality returns PostIncDecExpression
	 *     Equality.Equality_1_0 returns PostIncDecExpression
	 *     Comparison returns PostIncDecExpression
	 *     Comparison.Comparison_1_0 returns PostIncDecExpression
	 *     BitOr returns PostIncDecExpression
	 *     BitOr.BitOr_1_0 returns PostIncDecExpression
	 *     BitXor returns PostIncDecExpression
	 *     BitXor.BitXor_1_0 returns PostIncDecExpression
	 *     BitAnd returns PostIncDecExpression
	 *     BitAnd.BitAnd_1_0 returns PostIncDecExpression
	 *     Shift returns PostIncDecExpression
	 *     Shift.Shift_1_0 returns PostIncDecExpression
	 *     AddSub returns PostIncDecExpression
	 *     AddSub.AddSub_1_0_0 returns PostIncDecExpression
	 *     MulDivMod returns PostIncDecExpression
	 *     MulDivMod.MulDivMod_1_0 returns PostIncDecExpression
	 *     Exponent returns PostIncDecExpression
	 *     Exponent.Exponent_1_0 returns PostIncDecExpression
	 *     UnaryExpression returns PostIncDecExpression
	 *     PreExpression returns PostIncDecExpression
	 *     PreExpression.PreIncExpression_1_2 returns PostIncDecExpression
	 *     PreExpression.PreDecExpression_2_2 returns PostIncDecExpression
	 *     PostIncDecExpression returns PostIncDecExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PostIncDecExpression
	 *     PrimaryExpression returns PostIncDecExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PostIncDecExpression
	 *     PrimaryArithmetic returns PostIncDecExpression
	 *
	 * Constraint:
	 *     (expression=PostIncDecExpression_PostIncDecExpression_1_0 postOp=IncDecOpEnum)
	 */
	protected void sequence_PostIncDecExpression(ISerializationContext context, PostIncDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.POST_INC_DEC_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.POST_INC_DEC_EXPRESSION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.POST_INC_DEC_EXPRESSION__POST_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.POST_INC_DEC_EXPRESSION__POST_OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPostIncDecExpressionAccess().getPostOpIncDecOpEnumEnumRuleCall_1_1_0(), semanticObject.getPostOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PreDecExpression returns PreDecExpression
	 *
	 * Constraint:
	 *     expression=PostIncDecExpression
	 */
	protected void sequence_PreDecExpression(ISerializationContext context, PreDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.PRE_DEC_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.PRE_DEC_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreDecExpressionAccess().getExpressionPostIncDecExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreDecExpression
	 *     Assignment returns PreDecExpression
	 *     Assignment.Assignment_1_0_0 returns PreDecExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PreDecExpression
	 *     BinaryExpression returns PreDecExpression
	 *     Or returns PreDecExpression
	 *     Or.Or_1_0 returns PreDecExpression
	 *     And returns PreDecExpression
	 *     And.And_1_0 returns PreDecExpression
	 *     Equality returns PreDecExpression
	 *     Equality.Equality_1_0 returns PreDecExpression
	 *     Comparison returns PreDecExpression
	 *     Comparison.Comparison_1_0 returns PreDecExpression
	 *     BitOr returns PreDecExpression
	 *     BitOr.BitOr_1_0 returns PreDecExpression
	 *     BitXor returns PreDecExpression
	 *     BitXor.BitXor_1_0 returns PreDecExpression
	 *     BitAnd returns PreDecExpression
	 *     BitAnd.BitAnd_1_0 returns PreDecExpression
	 *     Shift returns PreDecExpression
	 *     Shift.Shift_1_0 returns PreDecExpression
	 *     AddSub returns PreDecExpression
	 *     AddSub.AddSub_1_0_0 returns PreDecExpression
	 *     MulDivMod returns PreDecExpression
	 *     MulDivMod.MulDivMod_1_0 returns PreDecExpression
	 *     Exponent returns PreDecExpression
	 *     Exponent.Exponent_1_0 returns PreDecExpression
	 *     UnaryExpression returns PreDecExpression
	 *     PreExpression returns PreDecExpression
	 *     PreExpression.PreIncExpression_1_2 returns PreDecExpression
	 *     PreExpression.PreDecExpression_2_2 returns PreDecExpression
	 *     PostIncDecExpression returns PreDecExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PreDecExpression
	 *     PrimaryExpression returns PreDecExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PreDecExpression
	 *     PrimaryArithmetic returns PreDecExpression
	 *
	 * Constraint:
	 *     expression=PreExpression_PreDecExpression_2_2
	 */
	protected void sequence_PreExpression(ISerializationContext context, PreDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.PRE_DEC_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.PRE_DEC_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreIncExpression
	 *     Assignment returns PreIncExpression
	 *     Assignment.Assignment_1_0_0 returns PreIncExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PreIncExpression
	 *     BinaryExpression returns PreIncExpression
	 *     Or returns PreIncExpression
	 *     Or.Or_1_0 returns PreIncExpression
	 *     And returns PreIncExpression
	 *     And.And_1_0 returns PreIncExpression
	 *     Equality returns PreIncExpression
	 *     Equality.Equality_1_0 returns PreIncExpression
	 *     Comparison returns PreIncExpression
	 *     Comparison.Comparison_1_0 returns PreIncExpression
	 *     BitOr returns PreIncExpression
	 *     BitOr.BitOr_1_0 returns PreIncExpression
	 *     BitXor returns PreIncExpression
	 *     BitXor.BitXor_1_0 returns PreIncExpression
	 *     BitAnd returns PreIncExpression
	 *     BitAnd.BitAnd_1_0 returns PreIncExpression
	 *     Shift returns PreIncExpression
	 *     Shift.Shift_1_0 returns PreIncExpression
	 *     AddSub returns PreIncExpression
	 *     AddSub.AddSub_1_0_0 returns PreIncExpression
	 *     MulDivMod returns PreIncExpression
	 *     MulDivMod.MulDivMod_1_0 returns PreIncExpression
	 *     Exponent returns PreIncExpression
	 *     Exponent.Exponent_1_0 returns PreIncExpression
	 *     UnaryExpression returns PreIncExpression
	 *     PreExpression returns PreIncExpression
	 *     PreExpression.PreIncExpression_1_2 returns PreIncExpression
	 *     PreExpression.PreDecExpression_2_2 returns PreIncExpression
	 *     PostIncDecExpression returns PreIncExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PreIncExpression
	 *     PrimaryExpression returns PreIncExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PreIncExpression
	 *     PrimaryArithmetic returns PreIncExpression
	 *
	 * Constraint:
	 *     expression=PreExpression_PreIncExpression_1_2
	 */
	protected void sequence_PreExpression(ISerializationContext context, PreIncExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.PRE_INC_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.PRE_INC_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PreIncExpression returns PreIncExpression
	 *
	 * Constraint:
	 *     expression=PostIncDecExpression
	 */
	protected void sequence_PreIncExpression(ISerializationContext context, PreIncExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.PRE_INC_EXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.PRE_INC_EXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreIncExpressionAccess().getExpressionPostIncDecExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Tuple
	 *     Assignment returns Tuple
	 *     Assignment.Assignment_1_0_0 returns Tuple
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Tuple
	 *     BinaryExpression returns Tuple
	 *     Or returns Tuple
	 *     Or.Or_1_0 returns Tuple
	 *     And returns Tuple
	 *     And.And_1_0 returns Tuple
	 *     Equality returns Tuple
	 *     Equality.Equality_1_0 returns Tuple
	 *     Comparison returns Tuple
	 *     Comparison.Comparison_1_0 returns Tuple
	 *     BitOr returns Tuple
	 *     BitOr.BitOr_1_0 returns Tuple
	 *     BitXor returns Tuple
	 *     BitXor.BitXor_1_0 returns Tuple
	 *     BitAnd returns Tuple
	 *     BitAnd.BitAnd_1_0 returns Tuple
	 *     Shift returns Tuple
	 *     Shift.Shift_1_0 returns Tuple
	 *     AddSub returns Tuple
	 *     AddSub.AddSub_1_0_0 returns Tuple
	 *     MulDivMod returns Tuple
	 *     MulDivMod.MulDivMod_1_0 returns Tuple
	 *     Exponent returns Tuple
	 *     Exponent.Exponent_1_0 returns Tuple
	 *     UnaryExpression returns Tuple
	 *     PreExpression returns Tuple
	 *     PreExpression.PreIncExpression_1_2 returns Tuple
	 *     PreExpression.PreDecExpression_2_2 returns Tuple
	 *     PostIncDecExpression returns Tuple
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Tuple
	 *     PrimaryExpression returns Tuple
	 *     PrimaryExpression.Tuple_4_2_0 returns Tuple
	 *     PrimaryArithmetic returns Tuple
	 *
	 * Constraint:
	 *     (
	 *         (members+=PrimaryExpression_Tuple_4_2_0 (members+=TupleSeparator members+=Expression?)+) | 
	 *         (members+=PrimaryExpression_Tuple_5_2_0 members+=Expression? (members+=TupleSeparator members+=Expression?)*)
	 *     )?
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns QualifiedIdentifier
	 *     StandardType returns QualifiedIdentifier
	 *     QualifiedIdentifier returns QualifiedIdentifier
	 *     Expression returns QualifiedIdentifier
	 *     Assignment returns QualifiedIdentifier
	 *     Assignment.Assignment_1_0_0 returns QualifiedIdentifier
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns QualifiedIdentifier
	 *     BinaryExpression returns QualifiedIdentifier
	 *     Or returns QualifiedIdentifier
	 *     Or.Or_1_0 returns QualifiedIdentifier
	 *     And returns QualifiedIdentifier
	 *     And.And_1_0 returns QualifiedIdentifier
	 *     Equality returns QualifiedIdentifier
	 *     Equality.Equality_1_0 returns QualifiedIdentifier
	 *     Comparison returns QualifiedIdentifier
	 *     Comparison.Comparison_1_0 returns QualifiedIdentifier
	 *     BitOr returns QualifiedIdentifier
	 *     BitOr.BitOr_1_0 returns QualifiedIdentifier
	 *     BitXor returns QualifiedIdentifier
	 *     BitXor.BitXor_1_0 returns QualifiedIdentifier
	 *     BitAnd returns QualifiedIdentifier
	 *     BitAnd.BitAnd_1_0 returns QualifiedIdentifier
	 *     Shift returns QualifiedIdentifier
	 *     Shift.Shift_1_0 returns QualifiedIdentifier
	 *     AddSub returns QualifiedIdentifier
	 *     AddSub.AddSub_1_0_0 returns QualifiedIdentifier
	 *     MulDivMod returns QualifiedIdentifier
	 *     MulDivMod.MulDivMod_1_0 returns QualifiedIdentifier
	 *     Exponent returns QualifiedIdentifier
	 *     Exponent.Exponent_1_0 returns QualifiedIdentifier
	 *     UnaryExpression returns QualifiedIdentifier
	 *     PreExpression returns QualifiedIdentifier
	 *     PreExpression.PreIncExpression_1_2 returns QualifiedIdentifier
	 *     PreExpression.PreDecExpression_2_2 returns QualifiedIdentifier
	 *     PostIncDecExpression returns QualifiedIdentifier
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns QualifiedIdentifier
	 *     PrimaryExpression returns QualifiedIdentifier
	 *     PrimaryExpression.Tuple_4_2_0 returns QualifiedIdentifier
	 *     PrimaryArithmetic returns QualifiedIdentifier
	 *
	 * Constraint:
	 *     (identifier=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_QualifiedIdentifier(ISerializationContext context, QualifiedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnParameterDeclaration returns ReturnParameterDeclaration
	 *
	 * Constraint:
	 *     (typeRef=Type variable=Variable?)
	 */
	protected void sequence_ReturnParameterDeclaration(ISerializationContext context, ReturnParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnsParameterList returns ReturnsParameterList
	 *
	 * Constraint:
	 *     (parameters+=ReturnParameterDeclaration parameters+=ReturnParameterDeclaration*)?
	 */
	protected void sequence_ReturnsParameterList(ISerializationContext context, ReturnsParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SecondOperators returns SecondOperators
	 *
	 * Constraint:
	 *     ((operator='+' | operator='-' | operator='/' | operator='*') value=PrimaryArithmetic)
	 */
	protected void sequence_SecondOperators(ISerializationContext context, SecondOperators semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Shift
	 *     Assignment returns Shift
	 *     Assignment.Assignment_1_0_0 returns Shift
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Shift
	 *     BinaryExpression returns Shift
	 *     Or returns Shift
	 *     Or.Or_1_0 returns Shift
	 *     And returns Shift
	 *     And.And_1_0 returns Shift
	 *     Equality returns Shift
	 *     Equality.Equality_1_0 returns Shift
	 *     Comparison returns Shift
	 *     Comparison.Comparison_1_0 returns Shift
	 *     BitOr returns Shift
	 *     BitOr.BitOr_1_0 returns Shift
	 *     BitXor returns Shift
	 *     BitXor.BitXor_1_0 returns Shift
	 *     BitAnd returns Shift
	 *     BitAnd.BitAnd_1_0 returns Shift
	 *     Shift returns Shift
	 *     Shift.Shift_1_0 returns Shift
	 *     AddSub returns Shift
	 *     AddSub.AddSub_1_0_0 returns Shift
	 *     MulDivMod returns Shift
	 *     MulDivMod.MulDivMod_1_0 returns Shift
	 *     Exponent returns Shift
	 *     Exponent.Exponent_1_0 returns Shift
	 *     UnaryExpression returns Shift
	 *     PreExpression returns Shift
	 *     PreExpression.PreIncExpression_1_2 returns Shift
	 *     PreExpression.PreDecExpression_2_2 returns Shift
	 *     PostIncDecExpression returns Shift
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Shift
	 *     PrimaryExpression returns Shift
	 *     PrimaryExpression.Tuple_4_2_0 returns Shift
	 *     PrimaryArithmetic returns Shift
	 *
	 * Constraint:
	 *     (left=Shift_Shift_1_0 shiftOp=ShiftOpEnum right=AddSub)
	 */
	protected void sequence_Shift(ISerializationContext context, Shift semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.SHIFT__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.SHIFT__LEFT));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.SHIFT__SHIFT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.SHIFT__SHIFT_OP));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.SHIFT__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.SHIFT__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShiftAccess().getShiftLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getShiftAccess().getShiftOpShiftOpEnumEnumRuleCall_1_1_0(), semanticObject.getShiftOp());
		feeder.accept(grammarAccess.getShiftAccess().getRightAddSubParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SignExpression
	 *     Assignment returns SignExpression
	 *     Assignment.Assignment_1_0_0 returns SignExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SignExpression
	 *     BinaryExpression returns SignExpression
	 *     Or returns SignExpression
	 *     Or.Or_1_0 returns SignExpression
	 *     And returns SignExpression
	 *     And.And_1_0 returns SignExpression
	 *     Equality returns SignExpression
	 *     Equality.Equality_1_0 returns SignExpression
	 *     Comparison returns SignExpression
	 *     Comparison.Comparison_1_0 returns SignExpression
	 *     BitOr returns SignExpression
	 *     BitOr.BitOr_1_0 returns SignExpression
	 *     BitXor returns SignExpression
	 *     BitXor.BitXor_1_0 returns SignExpression
	 *     BitAnd returns SignExpression
	 *     BitAnd.BitAnd_1_0 returns SignExpression
	 *     Shift returns SignExpression
	 *     Shift.Shift_1_0 returns SignExpression
	 *     AddSub returns SignExpression
	 *     AddSub.AddSub_1_0_0 returns SignExpression
	 *     MulDivMod returns SignExpression
	 *     MulDivMod.MulDivMod_1_0 returns SignExpression
	 *     Exponent returns SignExpression
	 *     Exponent.Exponent_1_0 returns SignExpression
	 *     UnaryExpression returns SignExpression
	 *     SignExpression returns SignExpression
	 *     PreExpression returns SignExpression
	 *     PreExpression.PreIncExpression_1_2 returns SignExpression
	 *     PreExpression.PreDecExpression_2_2 returns SignExpression
	 *     PostIncDecExpression returns SignExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SignExpression
	 *     PrimaryExpression returns SignExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns SignExpression
	 *     PrimaryArithmetic returns SignExpression
	 *
	 * Constraint:
	 *     ((signOp='+' | signOp='-') expression=UnaryExpression)
	 */
	protected void sequence_SignExpression(ISerializationContext context, SignExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement2_StandardVariableDeclaration_0_1_0 
	 *         optionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression?
	 *     )
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getTupleTupleParserRuleCall_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getVariableVariableParserRuleCall_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns StandardVariableDeclaration
	 *     Statement returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement_StandardVariableDeclaration_0_0_1_0 
	 *         ptionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression? 
	 *         semicolon?=';'
	 *     )
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTupleVariableDeclaration
	 *     Statement returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__TUPLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getTupleTupleParserRuleCall_0_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTypeDeclaration
	 *     Statement returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__VARIABLE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__EXPRESSION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__SEMICOLON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VAR_VARIABLE_TYPE_DECLARATION__SEMICOLON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getVariableVariableParserRuleCall_0_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Solidity returns Solidity
	 *
	 * Constraint:
	 *     (importDirective+=ImportDirective | contract+=Contract)+
	 */
	protected void sequence_Solidity(ISerializationContext context, Solidity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SpecialExpression
	 *     SpecialExpression returns SpecialExpression
	 *     Assignment returns SpecialExpression
	 *     Assignment.Assignment_1_0_0 returns SpecialExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SpecialExpression
	 *     BinaryExpression returns SpecialExpression
	 *     Or returns SpecialExpression
	 *     Or.Or_1_0 returns SpecialExpression
	 *     And returns SpecialExpression
	 *     And.And_1_0 returns SpecialExpression
	 *     Equality returns SpecialExpression
	 *     Equality.Equality_1_0 returns SpecialExpression
	 *     Comparison returns SpecialExpression
	 *     Comparison.Comparison_1_0 returns SpecialExpression
	 *     BitOr returns SpecialExpression
	 *     BitOr.BitOr_1_0 returns SpecialExpression
	 *     BitXor returns SpecialExpression
	 *     BitXor.BitXor_1_0 returns SpecialExpression
	 *     BitAnd returns SpecialExpression
	 *     BitAnd.BitAnd_1_0 returns SpecialExpression
	 *     Shift returns SpecialExpression
	 *     Shift.Shift_1_0 returns SpecialExpression
	 *     AddSub returns SpecialExpression
	 *     AddSub.AddSub_1_0_0 returns SpecialExpression
	 *     MulDivMod returns SpecialExpression
	 *     MulDivMod.MulDivMod_1_0 returns SpecialExpression
	 *     Exponent returns SpecialExpression
	 *     Exponent.Exponent_1_0 returns SpecialExpression
	 *     UnaryExpression returns SpecialExpression
	 *     PreExpression returns SpecialExpression
	 *     PreExpression.PreIncExpression_1_2 returns SpecialExpression
	 *     PreExpression.PreDecExpression_2_2 returns SpecialExpression
	 *     PostIncDecExpression returns SpecialExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SpecialExpression
	 *     PrimaryExpression returns SpecialExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns SpecialExpression
	 *     PrimaryArithmetic returns SpecialExpression
	 *
	 * Constraint:
	 *     (type=SpecialExpressionTypeEnum fieldOrMethod=Field? (qualifiers+=Index | qualifiers+=Arguments)*)
	 */
	protected void sequence_SpecialExpression(ISerializationContext context, SpecialExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpecialVariablesTypeEnum returns SpecialVariablesTypeEnum
	 *
	 * Constraint:
	 *     (name=BLOCK | name=MSG | name=TX)
	 */
	protected void sequence_SpecialVariablesTypeEnum(ISerializationContext context, SpecialVariablesTypeEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SpecialVariables
	 *     Assignment returns SpecialVariables
	 *     Assignment.Assignment_1_0_0 returns SpecialVariables
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SpecialVariables
	 *     BinaryExpression returns SpecialVariables
	 *     Or returns SpecialVariables
	 *     Or.Or_1_0 returns SpecialVariables
	 *     And returns SpecialVariables
	 *     And.And_1_0 returns SpecialVariables
	 *     Equality returns SpecialVariables
	 *     Equality.Equality_1_0 returns SpecialVariables
	 *     Comparison returns SpecialVariables
	 *     Comparison.Comparison_1_0 returns SpecialVariables
	 *     BitOr returns SpecialVariables
	 *     BitOr.BitOr_1_0 returns SpecialVariables
	 *     BitXor returns SpecialVariables
	 *     BitXor.BitXor_1_0 returns SpecialVariables
	 *     BitAnd returns SpecialVariables
	 *     BitAnd.BitAnd_1_0 returns SpecialVariables
	 *     Shift returns SpecialVariables
	 *     Shift.Shift_1_0 returns SpecialVariables
	 *     AddSub returns SpecialVariables
	 *     AddSub.AddSub_1_0_0 returns SpecialVariables
	 *     MulDivMod returns SpecialVariables
	 *     MulDivMod.MulDivMod_1_0 returns SpecialVariables
	 *     Exponent returns SpecialVariables
	 *     Exponent.Exponent_1_0 returns SpecialVariables
	 *     UnaryExpression returns SpecialVariables
	 *     PreExpression returns SpecialVariables
	 *     PreExpression.PreIncExpression_1_2 returns SpecialVariables
	 *     PreExpression.PreDecExpression_2_2 returns SpecialVariables
	 *     PostIncDecExpression returns SpecialVariables
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SpecialVariables
	 *     PrimaryExpression returns SpecialVariables
	 *     PrimaryExpression.Tuple_4_2_0 returns SpecialVariables
	 *     Literal returns SpecialVariables
	 *     PrimaryArithmetic returns SpecialVariables
	 *     SpecialVariables returns SpecialVariables
	 *
	 * Constraint:
	 *     (type=SpecialVariablesTypeEnum field=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_SpecialVariables(ISerializationContext context, SpecialVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns StandardVariableDeclaration
	 *     StandardVariableDeclaration returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable expression=Expression?)
	 */
	protected void sequence_StandardVariableDeclaration(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Assignment returns StringLiteral
	 *     Assignment.Assignment_1_0_0 returns StringLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns StringLiteral
	 *     BinaryExpression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0 returns StringLiteral
	 *     BitOr returns StringLiteral
	 *     BitOr.BitOr_1_0 returns StringLiteral
	 *     BitXor returns StringLiteral
	 *     BitXor.BitXor_1_0 returns StringLiteral
	 *     BitAnd returns StringLiteral
	 *     BitAnd.BitAnd_1_0 returns StringLiteral
	 *     Shift returns StringLiteral
	 *     Shift.Shift_1_0 returns StringLiteral
	 *     AddSub returns StringLiteral
	 *     AddSub.AddSub_1_0_0 returns StringLiteral
	 *     MulDivMod returns StringLiteral
	 *     MulDivMod.MulDivMod_1_0 returns StringLiteral
	 *     Exponent returns StringLiteral
	 *     Exponent.Exponent_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     PreExpression returns StringLiteral
	 *     PreExpression.PreIncExpression_1_2 returns StringLiteral
	 *     PreExpression.PreDecExpression_2_2 returns StringLiteral
	 *     PostIncDecExpression returns StringLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns StringLiteral
	 *     Literal returns StringLiteral
	 *     PrimaryArithmetic returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StructDefinition returns StructDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilityEnum? name=ID members+=VariableDeclaration*)
	 */
	protected void sequence_StructDefinition(ISerializationContext context, StructDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolAlias returns SymbolAlias
	 *
	 * Constraint:
	 *     (symbol=ID alias=ID)
	 */
	protected void sequence_SymbolAlias(ISerializationContext context, SymbolAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.SYMBOL_ALIAS__SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.SYMBOL_ALIAS__SYMBOL));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.SYMBOL_ALIAS__ALIAS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.SYMBOL_ALIAS__ALIAS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolAliasAccess().getSymbolIDTerminalRuleCall_0_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getSymbolAliasAccess().getAliasIDTerminalRuleCall_2_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ThrowStatement
	 *     ThrowStatement returns ThrowStatement
	 *
	 * Constraint:
	 *     {ThrowStatement}
	 */
	protected void sequence_ThrowStatement(ISerializationContext context, ThrowStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Time returns Time
	 *
	 * Constraint:
	 *     (value=INT time=TimeSubdenominationEnum)
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TIME__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TIME__VALUE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TIME__TIME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TIME__TIME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeAccess().getTimeTimeSubdenominationEnumEnumRuleCall_1_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TupleSeparator returns TupleSeparator
	 *     PrimaryExpression.Tuple_5_2_0 returns TupleSeparator
	 *
	 * Constraint:
	 *     {TupleSeparator}
	 */
	protected void sequence_TupleSeparator(ISerializationContext context, TupleSeparator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tuple returns Tuple
	 *
	 * Constraint:
	 *     (members+=Expression? (members+=TupleSeparator members+=Expression?)+)?
	 */
	protected void sequence_Tuple(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TypeCast
	 *     Assignment returns TypeCast
	 *     Assignment.Assignment_1_0_0 returns TypeCast
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns TypeCast
	 *     BinaryExpression returns TypeCast
	 *     Or returns TypeCast
	 *     Or.Or_1_0 returns TypeCast
	 *     And returns TypeCast
	 *     And.And_1_0 returns TypeCast
	 *     Equality returns TypeCast
	 *     Equality.Equality_1_0 returns TypeCast
	 *     Comparison returns TypeCast
	 *     Comparison.Comparison_1_0 returns TypeCast
	 *     BitOr returns TypeCast
	 *     BitOr.BitOr_1_0 returns TypeCast
	 *     BitXor returns TypeCast
	 *     BitXor.BitXor_1_0 returns TypeCast
	 *     BitAnd returns TypeCast
	 *     BitAnd.BitAnd_1_0 returns TypeCast
	 *     Shift returns TypeCast
	 *     Shift.Shift_1_0 returns TypeCast
	 *     AddSub returns TypeCast
	 *     AddSub.AddSub_1_0_0 returns TypeCast
	 *     MulDivMod returns TypeCast
	 *     MulDivMod.MulDivMod_1_0 returns TypeCast
	 *     Exponent returns TypeCast
	 *     Exponent.Exponent_1_0 returns TypeCast
	 *     UnaryExpression returns TypeCast
	 *     PreExpression returns TypeCast
	 *     PreExpression.PreIncExpression_1_2 returns TypeCast
	 *     PreExpression.PreDecExpression_2_2 returns TypeCast
	 *     PostIncDecExpression returns TypeCast
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns TypeCast
	 *     PrimaryExpression returns TypeCast
	 *     PrimaryExpression.Tuple_4_2_0 returns TypeCast
	 *     PrimaryArithmetic returns TypeCast
	 *     TypeCast returns TypeCast
	 *
	 * Constraint:
	 *     (value=ElementaryTypeNameEnum expression=Expression)
	 */
	protected void sequence_TypeCast(ISerializationContext context, TypeCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__VALUE));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TYPE_CAST__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeCastAccess().getValueElementaryTypeNameEnumParserRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTypeCastAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     isVarType?=VarType
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.TYPE__IS_VAR_TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.TYPE__IS_VAR_TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getIsVarTypeVarTypeParserRuleCall_1_0(), semanticObject.isIsVarType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     UnitTypes returns UnitTypes
	 *
	 * Constraint:
	 *     (time=Time | units=Ether)
	 */
	protected void sequence_UnitTypes(ISerializationContext context, UnitTypes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableDeclaration
	 *     VarVariableDeclaration returns VarVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType variable=Variable expression=Expression?)
	 */
	protected void sequence_VarVariableDeclaration(ISerializationContext context, VarVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableTupleVariableDeclaration
	 *     VarVariableTupleVariableDeclaration returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType tuple=Tuple expression=Expression?)
	 */
	protected void sequence_VarVariableTupleVariableDeclaration(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VARIABLE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VARIABLE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VisibilityEnum returns VisibilityEnum
	 *
	 * Constraint:
	 *     (type='public' | type='internal' | type='private' | type='external')
	 */
	protected void sequence_VisibilityEnum(ISerializationContext context, VisibilityEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VisibilitySpecifier returns VisibilitySpecifier
	 *     VariableDeclarationOptionalElement returns VisibilitySpecifier
	 *
	 * Constraint:
	 *     visibility=VisibilityEnum
	 */
	protected void sequence_VisibilitySpecifier(ISerializationContext context, VisibilitySpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.VISIBILITY_SPECIFIER__VISIBILITY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.VISIBILITY_SPECIFIER__VISIBILITY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVisibilitySpecifierAccess().getVisibilityVisibilityEnumParserRuleCall_0(), semanticObject.getVisibility());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__BODY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OptGrammarPackage.Literals.WHILE_STATEMENT__BODY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
