/*
 * generated by Xtext 2.19.0
 */
package org.unicam.tryGrammar.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unicam.tryGrammar.myGrammar.AddSub;
import org.unicam.tryGrammar.myGrammar.And;
import org.unicam.tryGrammar.myGrammar.Arguments;
import org.unicam.tryGrammar.myGrammar.ArrayDimensions;
import org.unicam.tryGrammar.myGrammar.Assignment;
import org.unicam.tryGrammar.myGrammar.BinaryNotExpression;
import org.unicam.tryGrammar.myGrammar.BitAnd;
import org.unicam.tryGrammar.myGrammar.BitOr;
import org.unicam.tryGrammar.myGrammar.BitXor;
import org.unicam.tryGrammar.myGrammar.Block;
import org.unicam.tryGrammar.myGrammar.BooleanConst;
import org.unicam.tryGrammar.myGrammar.BreakStatement;
import org.unicam.tryGrammar.myGrammar.Comparison;
import org.unicam.tryGrammar.myGrammar.Const;
import org.unicam.tryGrammar.myGrammar.ConstantSpecifier;
import org.unicam.tryGrammar.myGrammar.Continue;
import org.unicam.tryGrammar.myGrammar.Contract;
import org.unicam.tryGrammar.myGrammar.DecimalLiteral;
import org.unicam.tryGrammar.myGrammar.DefinitionBody;
import org.unicam.tryGrammar.myGrammar.DeleteStatement;
import org.unicam.tryGrammar.myGrammar.ElementaryType;
import org.unicam.tryGrammar.myGrammar.EnumDefinition;
import org.unicam.tryGrammar.myGrammar.EnumValue;
import org.unicam.tryGrammar.myGrammar.Equality;
import org.unicam.tryGrammar.myGrammar.Ether;
import org.unicam.tryGrammar.myGrammar.Event;
import org.unicam.tryGrammar.myGrammar.Exponent;
import org.unicam.tryGrammar.myGrammar.ExpressionStatement;
import org.unicam.tryGrammar.myGrammar.Field;
import org.unicam.tryGrammar.myGrammar.ForStatement;
import org.unicam.tryGrammar.myGrammar.FunctionCallArg;
import org.unicam.tryGrammar.myGrammar.FunctionCallArguments;
import org.unicam.tryGrammar.myGrammar.FunctionCallListArguments;
import org.unicam.tryGrammar.myGrammar.FunctionDefinition;
import org.unicam.tryGrammar.myGrammar.GasleftFunction;
import org.unicam.tryGrammar.myGrammar.HexLiteral;
import org.unicam.tryGrammar.myGrammar.IfStatement;
import org.unicam.tryGrammar.myGrammar.ImportDirective;
import org.unicam.tryGrammar.myGrammar.Index;
import org.unicam.tryGrammar.myGrammar.IndexedSpecifer;
import org.unicam.tryGrammar.myGrammar.InheritanceSpecifier;
import org.unicam.tryGrammar.myGrammar.Library;
import org.unicam.tryGrammar.myGrammar.LocationSpecifier;
import org.unicam.tryGrammar.myGrammar.Mapping;
import org.unicam.tryGrammar.myGrammar.Modifier;
import org.unicam.tryGrammar.myGrammar.ModifierInvocation;
import org.unicam.tryGrammar.myGrammar.MulDivMod;
import org.unicam.tryGrammar.myGrammar.MyGrammarPackage;
import org.unicam.tryGrammar.myGrammar.NewExpression;
import org.unicam.tryGrammar.myGrammar.NotExpression;
import org.unicam.tryGrammar.myGrammar.Now;
import org.unicam.tryGrammar.myGrammar.NumberDimensionless;
import org.unicam.tryGrammar.myGrammar.Or;
import org.unicam.tryGrammar.myGrammar.ParameterList;
import org.unicam.tryGrammar.myGrammar.PlaceHolderStatement;
import org.unicam.tryGrammar.myGrammar.PostIncDecExpression;
import org.unicam.tryGrammar.myGrammar.PreDecExpression;
import org.unicam.tryGrammar.myGrammar.PreIncExpression;
import org.unicam.tryGrammar.myGrammar.QualifiedIdentifier;
import org.unicam.tryGrammar.myGrammar.ReturnParameterDeclaration;
import org.unicam.tryGrammar.myGrammar.ReturnStatement;
import org.unicam.tryGrammar.myGrammar.ReturnsParameterList;
import org.unicam.tryGrammar.myGrammar.Shift;
import org.unicam.tryGrammar.myGrammar.SignExpression;
import org.unicam.tryGrammar.myGrammar.Solidity;
import org.unicam.tryGrammar.myGrammar.SpecialExpression;
import org.unicam.tryGrammar.myGrammar.SpecialVariables;
import org.unicam.tryGrammar.myGrammar.SpecialVariablesTypeEnum;
import org.unicam.tryGrammar.myGrammar.StandardVariableDeclaration;
import org.unicam.tryGrammar.myGrammar.StringLiteral;
import org.unicam.tryGrammar.myGrammar.StructDefinition;
import org.unicam.tryGrammar.myGrammar.SymbolAlias;
import org.unicam.tryGrammar.myGrammar.ThrowStatement;
import org.unicam.tryGrammar.myGrammar.Time;
import org.unicam.tryGrammar.myGrammar.Tuple;
import org.unicam.tryGrammar.myGrammar.TupleSeparator;
import org.unicam.tryGrammar.myGrammar.Type;
import org.unicam.tryGrammar.myGrammar.TypeCast;
import org.unicam.tryGrammar.myGrammar.VarVariableDeclaration;
import org.unicam.tryGrammar.myGrammar.VarVariableTupleVariableDeclaration;
import org.unicam.tryGrammar.myGrammar.VarVariableTypeDeclaration;
import org.unicam.tryGrammar.myGrammar.Variable;
import org.unicam.tryGrammar.myGrammar.VariableDeclarationExpression;
import org.unicam.tryGrammar.myGrammar.VisibilitySpecifier;
import org.unicam.tryGrammar.myGrammar.WhileStatement;
import org.unicam.tryGrammar.services.MyGrammarGrammarAccess;

@SuppressWarnings("all")
public class MyGrammarSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyGrammarGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyGrammarPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyGrammarPackage.ADD_SUB:
				sequence_AddSub(context, (AddSub) semanticObject); 
				return; 
			case MyGrammarPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case MyGrammarPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case MyGrammarPackage.ARRAY_DIMENSIONS:
				sequence_ArrayDimensions(context, (ArrayDimensions) semanticObject); 
				return; 
			case MyGrammarPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case MyGrammarPackage.BINARY_NOT_EXPRESSION:
				sequence_BinaryNotExpression(context, (BinaryNotExpression) semanticObject); 
				return; 
			case MyGrammarPackage.BIT_AND:
				sequence_BitAnd(context, (BitAnd) semanticObject); 
				return; 
			case MyGrammarPackage.BIT_OR:
				sequence_BitOr(context, (BitOr) semanticObject); 
				return; 
			case MyGrammarPackage.BIT_XOR:
				sequence_BitXor(context, (BitXor) semanticObject); 
				return; 
			case MyGrammarPackage.BLOCK:
				sequence_Body(context, (Block) semanticObject); 
				return; 
			case MyGrammarPackage.BOOLEAN_CONST:
				sequence_BooleanConst(context, (BooleanConst) semanticObject); 
				return; 
			case MyGrammarPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case MyGrammarPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case MyGrammarPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case MyGrammarPackage.CONSTANT_SPECIFIER:
				sequence_ConstantSpecifier(context, (ConstantSpecifier) semanticObject); 
				return; 
			case MyGrammarPackage.CONTINUE:
				sequence_ContinueStatement(context, (Continue) semanticObject); 
				return; 
			case MyGrammarPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case MyGrammarPackage.DECIMAL_LITERAL:
				sequence_DecimalLiteral(context, (DecimalLiteral) semanticObject); 
				return; 
			case MyGrammarPackage.DEFINITION_BODY:
				sequence_DefinitionBody(context, (DefinitionBody) semanticObject); 
				return; 
			case MyGrammarPackage.DELETE_STATEMENT:
				sequence_DeleteStatement(context, (DeleteStatement) semanticObject); 
				return; 
			case MyGrammarPackage.ELEMENTARY_TYPE:
				if (rule == grammarAccess.getElementaryTypeRule()) {
					sequence_ElementaryType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStandardTypeWithoutQualifiedIdentifierRule()
						|| action == grammarAccess.getSimpleStatementAccess().getStandardVariableDeclarationTypeAction_0_0_1_0()
						|| action == grammarAccess.getSimpleStatement2Access().getStandardVariableDeclarationTypeAction_0_1_0()) {
					sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getStandardTypeRule()) {
					sequence_ElementaryType_StandardType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.ENUM_DEFINITION:
				sequence_EnumDefinition(context, (EnumDefinition) semanticObject); 
				return; 
			case MyGrammarPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case MyGrammarPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case MyGrammarPackage.ETHER:
				sequence_Ether(context, (Ether) semanticObject); 
				return; 
			case MyGrammarPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case MyGrammarPackage.EXPONENT:
				sequence_Exponent(context, (Exponent) semanticObject); 
				return; 
			case MyGrammarPackage.EXPRESSION_STATEMENT:
				if (rule == grammarAccess.getSimpleStatement2Rule()
						|| rule == grammarAccess.getExpressionStatementRule()) {
					sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ExpressionStatement_SimpleStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case MyGrammarPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case MyGrammarPackage.FUNCTION_CALL_ARG:
				sequence_FunctionCallArg(context, (FunctionCallArg) semanticObject); 
				return; 
			case MyGrammarPackage.FUNCTION_CALL_ARGUMENTS:
				sequence_FunctionCallArguments(context, (FunctionCallArguments) semanticObject); 
				return; 
			case MyGrammarPackage.FUNCTION_CALL_LIST_ARGUMENTS:
				sequence_FunctionCallListArguments(context, (FunctionCallListArguments) semanticObject); 
				return; 
			case MyGrammarPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case MyGrammarPackage.GASLEFT_FUNCTION:
				sequence_GasleftFunction(context, (GasleftFunction) semanticObject); 
				return; 
			case MyGrammarPackage.HEX_LITERAL:
				sequence_HexLiteral(context, (HexLiteral) semanticObject); 
				return; 
			case MyGrammarPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case MyGrammarPackage.IMPORT_DIRECTIVE:
				sequence_ImportDirective(context, (ImportDirective) semanticObject); 
				return; 
			case MyGrammarPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case MyGrammarPackage.INDEXED_SPECIFER:
				sequence_IndexedSpecifer(context, (IndexedSpecifer) semanticObject); 
				return; 
			case MyGrammarPackage.INHERITANCE_SPECIFIER:
				sequence_InheritanceSpecifier(context, (InheritanceSpecifier) semanticObject); 
				return; 
			case MyGrammarPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case MyGrammarPackage.LOCATION_SPECIFIER:
				sequence_LocationSpecifier(context, (LocationSpecifier) semanticObject); 
				return; 
			case MyGrammarPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case MyGrammarPackage.MODIFIER:
				sequence_Modifier(context, (Modifier) semanticObject); 
				return; 
			case MyGrammarPackage.MODIFIER_INVOCATION:
				sequence_ModifierInvocation(context, (ModifierInvocation) semanticObject); 
				return; 
			case MyGrammarPackage.MUL_DIV_MOD:
				sequence_MulDivMod(context, (MulDivMod) semanticObject); 
				return; 
			case MyGrammarPackage.NEW_EXPRESSION:
				sequence_NewExpression(context, (NewExpression) semanticObject); 
				return; 
			case MyGrammarPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case MyGrammarPackage.NOW:
				sequence_Now(context, (Now) semanticObject); 
				return; 
			case MyGrammarPackage.NUMBER_DIMENSIONLESS:
				sequence_NumberDimensionless(context, (NumberDimensionless) semanticObject); 
				return; 
			case MyGrammarPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case MyGrammarPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case MyGrammarPackage.PLACE_HOLDER_STATEMENT:
				sequence_PlaceHolderStatement(context, (PlaceHolderStatement) semanticObject); 
				return; 
			case MyGrammarPackage.POST_INC_DEC_EXPRESSION:
				sequence_PostIncDecExpression(context, (PostIncDecExpression) semanticObject); 
				return; 
			case MyGrammarPackage.PRE_DEC_EXPRESSION:
				if (rule == grammarAccess.getPreDecExpressionRule()) {
					sequence_PreDecExpression(context, (PreDecExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()) {
					sequence_PreExpression(context, (PreDecExpression) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.PRE_INC_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()) {
					sequence_PreExpression(context, (PreIncExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPreIncExpressionRule()) {
					sequence_PreIncExpression(context, (PreIncExpression) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.QUALIFIED_IDENTIFIER:
				sequence_QualifiedIdentifier(context, (QualifiedIdentifier) semanticObject); 
				return; 
			case MyGrammarPackage.RETURN_PARAMETER_DECLARATION:
				sequence_ReturnParameterDeclaration(context, (ReturnParameterDeclaration) semanticObject); 
				return; 
			case MyGrammarPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case MyGrammarPackage.RETURNS_PARAMETER_LIST:
				sequence_ReturnsParameterList(context, (ReturnsParameterList) semanticObject); 
				return; 
			case MyGrammarPackage.SHIFT:
				sequence_Shift(context, (Shift) semanticObject); 
				return; 
			case MyGrammarPackage.SIGN_EXPRESSION:
				sequence_SignExpression(context, (SignExpression) semanticObject); 
				return; 
			case MyGrammarPackage.SOLIDITY:
				sequence_Solidity(context, (Solidity) semanticObject); 
				return; 
			case MyGrammarPackage.SPECIAL_EXPRESSION:
				sequence_SpecialExpression(context, (SpecialExpression) semanticObject); 
				return; 
			case MyGrammarPackage.SPECIAL_VARIABLES:
				sequence_SpecialVariables(context, (SpecialVariables) semanticObject); 
				return; 
			case MyGrammarPackage.SPECIAL_VARIABLES_TYPE_ENUM:
				sequence_SpecialVariablesTypeEnum(context, (SpecialVariablesTypeEnum) semanticObject); 
				return; 
			case MyGrammarPackage.STANDARD_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getStandardVariableDeclarationRule()) {
					sequence_StandardVariableDeclaration(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MyGrammarPackage.STRUCT_DEFINITION:
				sequence_StructDefinition(context, (StructDefinition) semanticObject); 
				return; 
			case MyGrammarPackage.SYMBOL_ALIAS:
				sequence_SymbolAlias(context, (SymbolAlias) semanticObject); 
				return; 
			case MyGrammarPackage.THROW_STATEMENT:
				sequence_ThrowStatement(context, (ThrowStatement) semanticObject); 
				return; 
			case MyGrammarPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case MyGrammarPackage.TUPLE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()) {
					sequence_PrimaryExpression(context, (Tuple) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTupleRule()) {
					sequence_Tuple(context, (Tuple) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.TUPLE_SEPARATOR:
				sequence_TupleSeparator(context, (TupleSeparator) semanticObject); 
				return; 
			case MyGrammarPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case MyGrammarPackage.TYPE_CAST:
				sequence_TypeCast(context, (TypeCast) semanticObject); 
				return; 
			case MyGrammarPackage.VAR_VARIABLE_DECLARATION:
				sequence_VarVariableDeclaration(context, (VarVariableDeclaration) semanticObject); 
				return; 
			case MyGrammarPackage.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getVarVariableTupleVariableDeclarationRule()) {
					sequence_VarVariableTupleVariableDeclaration(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.VAR_VARIABLE_TYPE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else break;
			case MyGrammarPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case MyGrammarPackage.VARIABLE_DECLARATION_EXPRESSION:
				sequence_Assignment(context, (VariableDeclarationExpression) semanticObject); 
				return; 
			case MyGrammarPackage.VISIBILITY_SPECIFIER:
				sequence_VisibilitySpecifier(context, (VisibilitySpecifier) semanticObject); 
				return; 
			case MyGrammarPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddSub
	 *     Assignment returns AddSub
	 *     Assignment.Assignment_1_0_0 returns AddSub
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns AddSub
	 *     BinaryExpression returns AddSub
	 *     Or returns AddSub
	 *     Or.Or_1_0 returns AddSub
	 *     And returns AddSub
	 *     And.And_1_0 returns AddSub
	 *     Equality returns AddSub
	 *     Equality.Equality_1_0 returns AddSub
	 *     Comparison returns AddSub
	 *     Comparison.Comparison_1_0 returns AddSub
	 *     BitOr returns AddSub
	 *     BitOr.BitOr_1_0 returns AddSub
	 *     BitXor returns AddSub
	 *     BitXor.BitXor_1_0 returns AddSub
	 *     BitAnd returns AddSub
	 *     BitAnd.BitAnd_1_0 returns AddSub
	 *     Shift returns AddSub
	 *     Shift.Shift_1_0 returns AddSub
	 *     AddSub returns AddSub
	 *     AddSub.AddSub_1_0_0 returns AddSub
	 *     MulDivMod returns AddSub
	 *     MulDivMod.MulDivMod_1_0 returns AddSub
	 *     Exponent returns AddSub
	 *     Exponent.Exponent_1_0 returns AddSub
	 *     UnaryExpression returns AddSub
	 *     PreExpression returns AddSub
	 *     PreExpression.PreIncExpression_1_2 returns AddSub
	 *     PreExpression.PreDecExpression_2_2 returns AddSub
	 *     PostIncDecExpression returns AddSub
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns AddSub
	 *     PrimaryExpression returns AddSub
	 *     PrimaryExpression.Tuple_4_2_0 returns AddSub
	 *
	 * Constraint:
	 *     (left=AddSub_AddSub_1_0_0 additionOp=AdditionOpEnum right=MulDivMod)
	 */
	protected void sequence_AddSub(ISerializationContext context, AddSub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAddSub_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAddSub_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAddSub_AdditionOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAddSub_AdditionOp()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAddSub_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAddSub_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddSubAccess().getAdditionOpAdditionOpEnumEnumRuleCall_1_0_1_0(), semanticObject.getAdditionOp());
		feeder.accept(grammarAccess.getAddSubAccess().getRightMulDivModParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Assignment returns And
	 *     Assignment.Assignment_1_0_0 returns And
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns And
	 *     BinaryExpression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     BitOr returns And
	 *     BitOr.BitOr_1_0 returns And
	 *     BitXor returns And
	 *     BitXor.BitXor_1_0 returns And
	 *     BitAnd returns And
	 *     BitAnd.BitAnd_1_0 returns And
	 *     Shift returns And
	 *     Shift.Shift_1_0 returns And
	 *     AddSub returns And
	 *     AddSub.AddSub_1_0_0 returns And
	 *     MulDivMod returns And
	 *     MulDivMod.MulDivMod_1_0 returns And
	 *     Exponent returns And
	 *     Exponent.Exponent_1_0 returns And
	 *     UnaryExpression returns And
	 *     PreExpression returns And
	 *     PreExpression.PreIncExpression_1_2 returns And
	 *     PreExpression.PreDecExpression_2_2 returns And
	 *     PostIncDecExpression returns And
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns And
	 *     PrimaryExpression returns And
	 *     PrimaryExpression.Tuple_4_2_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAnd_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAnd_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAnd_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAnd_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Arguments
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     arguments=FunctionCallArguments
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getArguments_Arguments()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getArguments_Arguments()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentsAccess().getArgumentsFunctionCallArgumentsParserRuleCall_0(), semanticObject.getArguments());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayDimensions returns ArrayDimensions
	 *
	 * Constraint:
	 *     (value+=Expression? value+=Expression*)
	 */
	protected void sequence_ArrayDimensions(ISerializationContext context, ArrayDimensions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *     Assignment.Assignment_1_0_0 returns Assignment
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Assignment
	 *     BinaryExpression returns Assignment
	 *     Or returns Assignment
	 *     Or.Or_1_0 returns Assignment
	 *     And returns Assignment
	 *     And.And_1_0 returns Assignment
	 *     Equality returns Assignment
	 *     Equality.Equality_1_0 returns Assignment
	 *     Comparison returns Assignment
	 *     Comparison.Comparison_1_0 returns Assignment
	 *     BitOr returns Assignment
	 *     BitOr.BitOr_1_0 returns Assignment
	 *     BitXor returns Assignment
	 *     BitXor.BitXor_1_0 returns Assignment
	 *     BitAnd returns Assignment
	 *     BitAnd.BitAnd_1_0 returns Assignment
	 *     Shift returns Assignment
	 *     Shift.Shift_1_0 returns Assignment
	 *     AddSub returns Assignment
	 *     AddSub.AddSub_1_0_0 returns Assignment
	 *     MulDivMod returns Assignment
	 *     MulDivMod.MulDivMod_1_0 returns Assignment
	 *     Exponent returns Assignment
	 *     Exponent.Exponent_1_0 returns Assignment
	 *     UnaryExpression returns Assignment
	 *     PreExpression returns Assignment
	 *     PreExpression.PreIncExpression_1_2 returns Assignment
	 *     PreExpression.PreDecExpression_2_2 returns Assignment
	 *     PostIncDecExpression returns Assignment
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Assignment
	 *     PrimaryExpression returns Assignment
	 *     PrimaryExpression.Tuple_4_2_0 returns Assignment
	 *
	 * Constraint:
	 *     (left=Assignment_Assignment_1_0_0 assignmentOp=AssignmentOpEnum expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAssignment_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAssignment_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAssignment_AssignmentOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAssignment_AssignmentOp()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getAssignment_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getAssignment_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentOpAssignmentOpEnumEnumRuleCall_1_0_1_0(), semanticObject.getAssignmentOp());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_1_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableDeclarationExpression
	 *     Assignment returns VariableDeclarationExpression
	 *     Assignment.Assignment_1_0_0 returns VariableDeclarationExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns VariableDeclarationExpression
	 *     BinaryExpression returns VariableDeclarationExpression
	 *     Or returns VariableDeclarationExpression
	 *     Or.Or_1_0 returns VariableDeclarationExpression
	 *     And returns VariableDeclarationExpression
	 *     And.And_1_0 returns VariableDeclarationExpression
	 *     Equality returns VariableDeclarationExpression
	 *     Equality.Equality_1_0 returns VariableDeclarationExpression
	 *     Comparison returns VariableDeclarationExpression
	 *     Comparison.Comparison_1_0 returns VariableDeclarationExpression
	 *     BitOr returns VariableDeclarationExpression
	 *     BitOr.BitOr_1_0 returns VariableDeclarationExpression
	 *     BitXor returns VariableDeclarationExpression
	 *     BitXor.BitXor_1_0 returns VariableDeclarationExpression
	 *     BitAnd returns VariableDeclarationExpression
	 *     BitAnd.BitAnd_1_0 returns VariableDeclarationExpression
	 *     Shift returns VariableDeclarationExpression
	 *     Shift.Shift_1_0 returns VariableDeclarationExpression
	 *     AddSub returns VariableDeclarationExpression
	 *     AddSub.AddSub_1_0_0 returns VariableDeclarationExpression
	 *     MulDivMod returns VariableDeclarationExpression
	 *     MulDivMod.MulDivMod_1_0 returns VariableDeclarationExpression
	 *     Exponent returns VariableDeclarationExpression
	 *     Exponent.Exponent_1_0 returns VariableDeclarationExpression
	 *     UnaryExpression returns VariableDeclarationExpression
	 *     PreExpression returns VariableDeclarationExpression
	 *     PreExpression.PreIncExpression_1_2 returns VariableDeclarationExpression
	 *     PreExpression.PreDecExpression_2_2 returns VariableDeclarationExpression
	 *     PostIncDecExpression returns VariableDeclarationExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns VariableDeclarationExpression
	 *     PrimaryExpression returns VariableDeclarationExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns VariableDeclarationExpression
	 *
	 * Constraint:
	 *     (type=Assignment_VariableDeclarationExpression_1_1_0 variable=Variable expression=Expression?)
	 */
	protected void sequence_Assignment(ISerializationContext context, VariableDeclarationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinaryNotExpression
	 *     Assignment returns BinaryNotExpression
	 *     Assignment.Assignment_1_0_0 returns BinaryNotExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BinaryNotExpression
	 *     BinaryExpression returns BinaryNotExpression
	 *     Or returns BinaryNotExpression
	 *     Or.Or_1_0 returns BinaryNotExpression
	 *     And returns BinaryNotExpression
	 *     And.And_1_0 returns BinaryNotExpression
	 *     Equality returns BinaryNotExpression
	 *     Equality.Equality_1_0 returns BinaryNotExpression
	 *     Comparison returns BinaryNotExpression
	 *     Comparison.Comparison_1_0 returns BinaryNotExpression
	 *     BitOr returns BinaryNotExpression
	 *     BitOr.BitOr_1_0 returns BinaryNotExpression
	 *     BitXor returns BinaryNotExpression
	 *     BitXor.BitXor_1_0 returns BinaryNotExpression
	 *     BitAnd returns BinaryNotExpression
	 *     BitAnd.BitAnd_1_0 returns BinaryNotExpression
	 *     Shift returns BinaryNotExpression
	 *     Shift.Shift_1_0 returns BinaryNotExpression
	 *     AddSub returns BinaryNotExpression
	 *     AddSub.AddSub_1_0_0 returns BinaryNotExpression
	 *     MulDivMod returns BinaryNotExpression
	 *     MulDivMod.MulDivMod_1_0 returns BinaryNotExpression
	 *     Exponent returns BinaryNotExpression
	 *     Exponent.Exponent_1_0 returns BinaryNotExpression
	 *     UnaryExpression returns BinaryNotExpression
	 *     BinaryNotExpression returns BinaryNotExpression
	 *     PreExpression returns BinaryNotExpression
	 *     PreExpression.PreIncExpression_1_2 returns BinaryNotExpression
	 *     PreExpression.PreDecExpression_2_2 returns BinaryNotExpression
	 *     PostIncDecExpression returns BinaryNotExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BinaryNotExpression
	 *     PrimaryExpression returns BinaryNotExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns BinaryNotExpression
	 *
	 * Constraint:
	 *     expression=UnaryExpression
	 */
	protected void sequence_BinaryNotExpression(ISerializationContext context, BinaryNotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBinaryNotExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBinaryNotExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryNotExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitAnd
	 *     Assignment returns BitAnd
	 *     Assignment.Assignment_1_0_0 returns BitAnd
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitAnd
	 *     BinaryExpression returns BitAnd
	 *     Or returns BitAnd
	 *     Or.Or_1_0 returns BitAnd
	 *     And returns BitAnd
	 *     And.And_1_0 returns BitAnd
	 *     Equality returns BitAnd
	 *     Equality.Equality_1_0 returns BitAnd
	 *     Comparison returns BitAnd
	 *     Comparison.Comparison_1_0 returns BitAnd
	 *     BitOr returns BitAnd
	 *     BitOr.BitOr_1_0 returns BitAnd
	 *     BitXor returns BitAnd
	 *     BitXor.BitXor_1_0 returns BitAnd
	 *     BitAnd returns BitAnd
	 *     BitAnd.BitAnd_1_0 returns BitAnd
	 *     Shift returns BitAnd
	 *     Shift.Shift_1_0 returns BitAnd
	 *     AddSub returns BitAnd
	 *     AddSub.AddSub_1_0_0 returns BitAnd
	 *     MulDivMod returns BitAnd
	 *     MulDivMod.MulDivMod_1_0 returns BitAnd
	 *     Exponent returns BitAnd
	 *     Exponent.Exponent_1_0 returns BitAnd
	 *     UnaryExpression returns BitAnd
	 *     PreExpression returns BitAnd
	 *     PreExpression.PreIncExpression_1_2 returns BitAnd
	 *     PreExpression.PreDecExpression_2_2 returns BitAnd
	 *     PostIncDecExpression returns BitAnd
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitAnd
	 *     PrimaryExpression returns BitAnd
	 *     PrimaryExpression.Tuple_4_2_0 returns BitAnd
	 *
	 * Constraint:
	 *     (left=BitAnd_BitAnd_1_0 right=Shift)
	 */
	protected void sequence_BitAnd(ISerializationContext context, BitAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBitAnd_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBitAnd_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBitAnd_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBitAnd_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitAndAccess().getRightShiftParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitOr
	 *     Assignment returns BitOr
	 *     Assignment.Assignment_1_0_0 returns BitOr
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitOr
	 *     BinaryExpression returns BitOr
	 *     Or returns BitOr
	 *     Or.Or_1_0 returns BitOr
	 *     And returns BitOr
	 *     And.And_1_0 returns BitOr
	 *     Equality returns BitOr
	 *     Equality.Equality_1_0 returns BitOr
	 *     Comparison returns BitOr
	 *     Comparison.Comparison_1_0 returns BitOr
	 *     BitOr returns BitOr
	 *     BitOr.BitOr_1_0 returns BitOr
	 *     BitXor returns BitOr
	 *     BitXor.BitXor_1_0 returns BitOr
	 *     BitAnd returns BitOr
	 *     BitAnd.BitAnd_1_0 returns BitOr
	 *     Shift returns BitOr
	 *     Shift.Shift_1_0 returns BitOr
	 *     AddSub returns BitOr
	 *     AddSub.AddSub_1_0_0 returns BitOr
	 *     MulDivMod returns BitOr
	 *     MulDivMod.MulDivMod_1_0 returns BitOr
	 *     Exponent returns BitOr
	 *     Exponent.Exponent_1_0 returns BitOr
	 *     UnaryExpression returns BitOr
	 *     PreExpression returns BitOr
	 *     PreExpression.PreIncExpression_1_2 returns BitOr
	 *     PreExpression.PreDecExpression_2_2 returns BitOr
	 *     PostIncDecExpression returns BitOr
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitOr
	 *     PrimaryExpression returns BitOr
	 *     PrimaryExpression.Tuple_4_2_0 returns BitOr
	 *
	 * Constraint:
	 *     (left=BitOr_BitOr_1_0 right=BitXor)
	 */
	protected void sequence_BitOr(ISerializationContext context, BitOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBitOr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBitOr_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBitOr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBitOr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitOrAccess().getRightBitXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitXor
	 *     Assignment returns BitXor
	 *     Assignment.Assignment_1_0_0 returns BitXor
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitXor
	 *     BinaryExpression returns BitXor
	 *     Or returns BitXor
	 *     Or.Or_1_0 returns BitXor
	 *     And returns BitXor
	 *     And.And_1_0 returns BitXor
	 *     Equality returns BitXor
	 *     Equality.Equality_1_0 returns BitXor
	 *     Comparison returns BitXor
	 *     Comparison.Comparison_1_0 returns BitXor
	 *     BitOr returns BitXor
	 *     BitOr.BitOr_1_0 returns BitXor
	 *     BitXor returns BitXor
	 *     BitXor.BitXor_1_0 returns BitXor
	 *     BitAnd returns BitXor
	 *     BitAnd.BitAnd_1_0 returns BitXor
	 *     Shift returns BitXor
	 *     Shift.Shift_1_0 returns BitXor
	 *     AddSub returns BitXor
	 *     AddSub.AddSub_1_0_0 returns BitXor
	 *     MulDivMod returns BitXor
	 *     MulDivMod.MulDivMod_1_0 returns BitXor
	 *     Exponent returns BitXor
	 *     Exponent.Exponent_1_0 returns BitXor
	 *     UnaryExpression returns BitXor
	 *     PreExpression returns BitXor
	 *     PreExpression.PreIncExpression_1_2 returns BitXor
	 *     PreExpression.PreDecExpression_2_2 returns BitXor
	 *     PostIncDecExpression returns BitXor
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitXor
	 *     PrimaryExpression returns BitXor
	 *     PrimaryExpression.Tuple_4_2_0 returns BitXor
	 *
	 * Constraint:
	 *     (left=BitXor_BitXor_1_0 right=BitAnd)
	 */
	protected void sequence_BitXor(ISerializationContext context, BitXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBitXor_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBitXor_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBitXor_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBitXor_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitXorAccess().getRightBitAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Block
	 *     Body returns Block
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)?
	 */
	protected void sequence_Body(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanConst
	 *     Assignment returns BooleanConst
	 *     Assignment.Assignment_1_0_0 returns BooleanConst
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BooleanConst
	 *     BinaryExpression returns BooleanConst
	 *     Or returns BooleanConst
	 *     Or.Or_1_0 returns BooleanConst
	 *     And returns BooleanConst
	 *     And.And_1_0 returns BooleanConst
	 *     Equality returns BooleanConst
	 *     Equality.Equality_1_0 returns BooleanConst
	 *     Comparison returns BooleanConst
	 *     Comparison.Comparison_1_0 returns BooleanConst
	 *     BitOr returns BooleanConst
	 *     BitOr.BitOr_1_0 returns BooleanConst
	 *     BitXor returns BooleanConst
	 *     BitXor.BitXor_1_0 returns BooleanConst
	 *     BitAnd returns BooleanConst
	 *     BitAnd.BitAnd_1_0 returns BooleanConst
	 *     Shift returns BooleanConst
	 *     Shift.Shift_1_0 returns BooleanConst
	 *     AddSub returns BooleanConst
	 *     AddSub.AddSub_1_0_0 returns BooleanConst
	 *     MulDivMod returns BooleanConst
	 *     MulDivMod.MulDivMod_1_0 returns BooleanConst
	 *     Exponent returns BooleanConst
	 *     Exponent.Exponent_1_0 returns BooleanConst
	 *     UnaryExpression returns BooleanConst
	 *     PreExpression returns BooleanConst
	 *     PreExpression.PreIncExpression_1_2 returns BooleanConst
	 *     PreExpression.PreDecExpression_2_2 returns BooleanConst
	 *     PostIncDecExpression returns BooleanConst
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BooleanConst
	 *     PrimaryExpression returns BooleanConst
	 *     PrimaryExpression.Tuple_4_2_0 returns BooleanConst
	 *     Literal returns BooleanConst
	 *     BooleanConst returns BooleanConst
	 *
	 * Constraint:
	 *     value=BooleanLiteralEnum
	 */
	protected void sequence_BooleanConst(ISerializationContext context, BooleanConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getBooleanConst_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getBooleanConst_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanConstAccess().getValueBooleanLiteralEnumEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Assignment returns Comparison
	 *     Assignment.Assignment_1_0_0 returns Comparison
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Comparison
	 *     BinaryExpression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     BitOr returns Comparison
	 *     BitOr.BitOr_1_0 returns Comparison
	 *     BitXor returns Comparison
	 *     BitXor.BitXor_1_0 returns Comparison
	 *     BitAnd returns Comparison
	 *     BitAnd.BitAnd_1_0 returns Comparison
	 *     Shift returns Comparison
	 *     Shift.Shift_1_0 returns Comparison
	 *     AddSub returns Comparison
	 *     AddSub.AddSub_1_0_0 returns Comparison
	 *     MulDivMod returns Comparison
	 *     MulDivMod.MulDivMod_1_0 returns Comparison
	 *     Exponent returns Comparison
	 *     Exponent.Exponent_1_0 returns Comparison
	 *     UnaryExpression returns Comparison
	 *     PreExpression returns Comparison
	 *     PreExpression.PreIncExpression_1_2 returns Comparison
	 *     PreExpression.PreDecExpression_2_2 returns Comparison
	 *     PostIncDecExpression returns Comparison
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Comparison
	 *     PrimaryExpression returns Comparison
	 *     PrimaryExpression.Tuple_4_2_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 comparisonOp=ComparisonOpEnum right=BitOr)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getComparison_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getComparison_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getComparison_ComparisonOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getComparison_ComparisonOp()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getComparison_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getComparison_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonOpComparisonOpEnumEnumRuleCall_1_1_0(), semanticObject.getComparisonOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRightBitOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     {Const}
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns ConstantSpecifier
	 *     ConstantSpecifier returns ConstantSpecifier
	 *
	 * Constraint:
	 *     {ConstantSpecifier}
	 */
	protected void sequence_ConstantSpecifier(ISerializationContext context, ConstantSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Continue
	 *     ContinueStatement returns Continue
	 *
	 * Constraint:
	 *     {Continue}
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, Continue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractOrLibrary returns Contract
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID (inheritanceSpecifiers+=InheritanceSpecifier inheritanceSpecifiers+=InheritanceSpecifier*)? body=DefinitionBody)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DecimalLiteral
	 *     Assignment returns DecimalLiteral
	 *     Assignment.Assignment_1_0_0 returns DecimalLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns DecimalLiteral
	 *     BinaryExpression returns DecimalLiteral
	 *     Or returns DecimalLiteral
	 *     Or.Or_1_0 returns DecimalLiteral
	 *     And returns DecimalLiteral
	 *     And.And_1_0 returns DecimalLiteral
	 *     Equality returns DecimalLiteral
	 *     Equality.Equality_1_0 returns DecimalLiteral
	 *     Comparison returns DecimalLiteral
	 *     Comparison.Comparison_1_0 returns DecimalLiteral
	 *     BitOr returns DecimalLiteral
	 *     BitOr.BitOr_1_0 returns DecimalLiteral
	 *     BitXor returns DecimalLiteral
	 *     BitXor.BitXor_1_0 returns DecimalLiteral
	 *     BitAnd returns DecimalLiteral
	 *     BitAnd.BitAnd_1_0 returns DecimalLiteral
	 *     Shift returns DecimalLiteral
	 *     Shift.Shift_1_0 returns DecimalLiteral
	 *     AddSub returns DecimalLiteral
	 *     AddSub.AddSub_1_0_0 returns DecimalLiteral
	 *     MulDivMod returns DecimalLiteral
	 *     MulDivMod.MulDivMod_1_0 returns DecimalLiteral
	 *     Exponent returns DecimalLiteral
	 *     Exponent.Exponent_1_0 returns DecimalLiteral
	 *     UnaryExpression returns DecimalLiteral
	 *     PreExpression returns DecimalLiteral
	 *     PreExpression.PreIncExpression_1_2 returns DecimalLiteral
	 *     PreExpression.PreDecExpression_2_2 returns DecimalLiteral
	 *     PostIncDecExpression returns DecimalLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns DecimalLiteral
	 *     PrimaryExpression returns DecimalLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns DecimalLiteral
	 *     Literal returns DecimalLiteral
	 *     Number returns DecimalLiteral
	 *     DecimalLiteral returns DecimalLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_DecimalLiteral(ISerializationContext context, DecimalLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getDecimalLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getDecimalLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalLiteralAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionBody returns DefinitionBody
	 *
	 * Constraint:
	 *     (
	 *         functions+=FunctionDefinition | 
	 *         structs+=StructDefinition | 
	 *         enums+=EnumDefinition | 
	 *         variables+=VariableDeclaration | 
	 *         modifiers+=Modifier | 
	 *         events+=Event
	 *     )*
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, DefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteStatement
	 *     DeleteStatement returns DeleteStatement
	 *
	 * Constraint:
	 *     variable=QualifiedIdentifier
	 */
	protected void sequence_DeleteStatement(ISerializationContext context, DeleteStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getDeleteStatement_Variable()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getDeleteStatement_Variable()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteStatementAccess().getVariableQualifiedIdentifierParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementaryType returns ElementaryType
	 *
	 * Constraint:
	 *     name=ElementaryTypeNameEnum
	 */
	protected void sequence_ElementaryType(ISerializationContext context, ElementaryType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getElementaryType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getElementaryType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementaryTypeAccess().getNameElementaryTypeNameEnumEnumRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StandardTypeWithoutQualifiedIdentifier returns ElementaryType
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns ElementaryType
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ElementaryType
	 *     StandardType returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardType(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumDefinition returns EnumDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilityEnum? name=ID (members+=EnumValue members+=EnumValue*)?)
	 */
	protected void sequence_EnumDefinition(ISerializationContext context, EnumDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getEnumValue_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getEnumValue_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Assignment returns Equality
	 *     Assignment.Assignment_1_0_0 returns Equality
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Equality
	 *     BinaryExpression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     BitOr returns Equality
	 *     BitOr.BitOr_1_0 returns Equality
	 *     BitXor returns Equality
	 *     BitXor.BitXor_1_0 returns Equality
	 *     BitAnd returns Equality
	 *     BitAnd.BitAnd_1_0 returns Equality
	 *     Shift returns Equality
	 *     Shift.Shift_1_0 returns Equality
	 *     AddSub returns Equality
	 *     AddSub.AddSub_1_0_0 returns Equality
	 *     MulDivMod returns Equality
	 *     MulDivMod.MulDivMod_1_0 returns Equality
	 *     Exponent returns Equality
	 *     Exponent.Exponent_1_0 returns Equality
	 *     UnaryExpression returns Equality
	 *     PreExpression returns Equality
	 *     PreExpression.PreIncExpression_1_2 returns Equality
	 *     PreExpression.PreDecExpression_2_2 returns Equality
	 *     PostIncDecExpression returns Equality
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Equality
	 *     PrimaryExpression returns Equality
	 *     PrimaryExpression.Tuple_4_2_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 equalityOp=EqualityOpEnum right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getEquality_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getEquality_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getEquality_EqualityOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getEquality_EqualityOp()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getEquality_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getEquality_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityOpEqualityOpEnumEnumRuleCall_1_1_0(), semanticObject.getEqualityOp());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Ether
	 *     Assignment returns Ether
	 *     Assignment.Assignment_1_0_0 returns Ether
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Ether
	 *     BinaryExpression returns Ether
	 *     Or returns Ether
	 *     Or.Or_1_0 returns Ether
	 *     And returns Ether
	 *     And.And_1_0 returns Ether
	 *     Equality returns Ether
	 *     Equality.Equality_1_0 returns Ether
	 *     Comparison returns Ether
	 *     Comparison.Comparison_1_0 returns Ether
	 *     BitOr returns Ether
	 *     BitOr.BitOr_1_0 returns Ether
	 *     BitXor returns Ether
	 *     BitXor.BitXor_1_0 returns Ether
	 *     BitAnd returns Ether
	 *     BitAnd.BitAnd_1_0 returns Ether
	 *     Shift returns Ether
	 *     Shift.Shift_1_0 returns Ether
	 *     AddSub returns Ether
	 *     AddSub.AddSub_1_0_0 returns Ether
	 *     MulDivMod returns Ether
	 *     MulDivMod.MulDivMod_1_0 returns Ether
	 *     Exponent returns Ether
	 *     Exponent.Exponent_1_0 returns Ether
	 *     UnaryExpression returns Ether
	 *     PreExpression returns Ether
	 *     PreExpression.PreIncExpression_1_2 returns Ether
	 *     PreExpression.PreDecExpression_2_2 returns Ether
	 *     PostIncDecExpression returns Ether
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Ether
	 *     PrimaryExpression returns Ether
	 *     PrimaryExpression.Tuple_4_2_0 returns Ether
	 *     Literal returns Ether
	 *     Number returns Ether
	 *     Ether returns Ether
	 *
	 * Constraint:
	 *     (value=INT ether=EtherSubDenominationEnum)
	 */
	protected void sequence_Ether(ISerializationContext context, Ether semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getEther_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getEther_Value()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getEther_Ether()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getEther_Ether()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEtherAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEtherAccess().getEtherEtherSubDenominationEnumEnumRuleCall_1_0(), semanticObject.getEther());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Exponent
	 *     Assignment returns Exponent
	 *     Assignment.Assignment_1_0_0 returns Exponent
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Exponent
	 *     BinaryExpression returns Exponent
	 *     Or returns Exponent
	 *     Or.Or_1_0 returns Exponent
	 *     And returns Exponent
	 *     And.And_1_0 returns Exponent
	 *     Equality returns Exponent
	 *     Equality.Equality_1_0 returns Exponent
	 *     Comparison returns Exponent
	 *     Comparison.Comparison_1_0 returns Exponent
	 *     BitOr returns Exponent
	 *     BitOr.BitOr_1_0 returns Exponent
	 *     BitXor returns Exponent
	 *     BitXor.BitXor_1_0 returns Exponent
	 *     BitAnd returns Exponent
	 *     BitAnd.BitAnd_1_0 returns Exponent
	 *     Shift returns Exponent
	 *     Shift.Shift_1_0 returns Exponent
	 *     AddSub returns Exponent
	 *     AddSub.AddSub_1_0_0 returns Exponent
	 *     MulDivMod returns Exponent
	 *     MulDivMod.MulDivMod_1_0 returns Exponent
	 *     Exponent returns Exponent
	 *     Exponent.Exponent_1_0 returns Exponent
	 *     UnaryExpression returns Exponent
	 *     PreExpression returns Exponent
	 *     PreExpression.PreIncExpression_1_2 returns Exponent
	 *     PreExpression.PreDecExpression_2_2 returns Exponent
	 *     PostIncDecExpression returns Exponent
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Exponent
	 *     PrimaryExpression returns Exponent
	 *     PrimaryExpression.Tuple_4_2_0 returns Exponent
	 *
	 * Constraint:
	 *     (left=Exponent_Exponent_1_0 right=UnaryExpression)
	 */
	protected void sequence_Exponent(ISerializationContext context, Exponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getExponent_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getExponent_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getExponent_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getExponent_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExponentAccess().getExponentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExponentAccess().getRightUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getExpressionStatement_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getExpressionStatement_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns ExpressionStatement
	 *     Statement returns ExpressionStatement
	 *
	 * Constraint:
	 *     (expression=Expression semicolon?=';')
	 */
	protected void sequence_ExpressionStatement_SimpleStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getExpressionStatement_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getExpressionStatement_Expression()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getExpressionStatement_Semicolon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getExpressionStatement_Semicolon()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     field=ID
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getField_Field()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getField_Field()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getFieldIDTerminalRuleCall_1_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (initExpression=SimpleStatement2? conditionExpression=Expression? loopExpression=ExpressionStatement? body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArg returns FunctionCallArg
	 *
	 * Constraint:
	 *     (name=ID expr=Expression)
	 */
	protected void sequence_FunctionCallArg(ISerializationContext context, FunctionCallArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getFunctionCallArg_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getFunctionCallArg_Name()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getFunctionCallArg_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getFunctionCallArg_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArguments returns FunctionCallArguments
	 *
	 * Constraint:
	 *     (args+=FunctionCallArg args+=FunctionCallArg*)?
	 */
	protected void sequence_FunctionCallArguments(ISerializationContext context, FunctionCallArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallListArguments returns FunctionCallListArguments
	 *     FunctionCallArguments returns FunctionCallListArguments
	 *
	 * Constraint:
	 *     (arguments+=Expression arguments+=Expression*)?
	 */
	protected void sequence_FunctionCallListArguments(ISerializationContext context, FunctionCallListArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (
	 *         visibility=VisibilityEnum 
	 *         payable?='payable'? 
	 *         name=ID 
	 *         parameters=ParameterList 
	 *         optionalElements+=FunctionDefinitionOptionalElement* 
	 *         returnParameters=ReturnsParameterList? 
	 *         block=Body?
	 *     )
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns GasleftFunction
	 *     Assignment returns GasleftFunction
	 *     Assignment.Assignment_1_0_0 returns GasleftFunction
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns GasleftFunction
	 *     BinaryExpression returns GasleftFunction
	 *     Or returns GasleftFunction
	 *     Or.Or_1_0 returns GasleftFunction
	 *     And returns GasleftFunction
	 *     And.And_1_0 returns GasleftFunction
	 *     Equality returns GasleftFunction
	 *     Equality.Equality_1_0 returns GasleftFunction
	 *     Comparison returns GasleftFunction
	 *     Comparison.Comparison_1_0 returns GasleftFunction
	 *     BitOr returns GasleftFunction
	 *     BitOr.BitOr_1_0 returns GasleftFunction
	 *     BitXor returns GasleftFunction
	 *     BitXor.BitXor_1_0 returns GasleftFunction
	 *     BitAnd returns GasleftFunction
	 *     BitAnd.BitAnd_1_0 returns GasleftFunction
	 *     Shift returns GasleftFunction
	 *     Shift.Shift_1_0 returns GasleftFunction
	 *     AddSub returns GasleftFunction
	 *     AddSub.AddSub_1_0_0 returns GasleftFunction
	 *     MulDivMod returns GasleftFunction
	 *     MulDivMod.MulDivMod_1_0 returns GasleftFunction
	 *     Exponent returns GasleftFunction
	 *     Exponent.Exponent_1_0 returns GasleftFunction
	 *     UnaryExpression returns GasleftFunction
	 *     PreExpression returns GasleftFunction
	 *     PreExpression.PreIncExpression_1_2 returns GasleftFunction
	 *     PreExpression.PreDecExpression_2_2 returns GasleftFunction
	 *     PostIncDecExpression returns GasleftFunction
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns GasleftFunction
	 *     PrimaryExpression returns GasleftFunction
	 *     PrimaryExpression.Tuple_4_2_0 returns GasleftFunction
	 *     Literal returns GasleftFunction
	 *     GasleftFunction returns GasleftFunction
	 *
	 * Constraint:
	 *     name='gasleft'
	 */
	protected void sequence_GasleftFunction(ISerializationContext context, GasleftFunction semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getGasleftFunction_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getGasleftFunction_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGasleftFunctionAccess().getNameGasleftKeyword_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HexLiteral
	 *     Assignment returns HexLiteral
	 *     Assignment.Assignment_1_0_0 returns HexLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns HexLiteral
	 *     BinaryExpression returns HexLiteral
	 *     Or returns HexLiteral
	 *     Or.Or_1_0 returns HexLiteral
	 *     And returns HexLiteral
	 *     And.And_1_0 returns HexLiteral
	 *     Equality returns HexLiteral
	 *     Equality.Equality_1_0 returns HexLiteral
	 *     Comparison returns HexLiteral
	 *     Comparison.Comparison_1_0 returns HexLiteral
	 *     BitOr returns HexLiteral
	 *     BitOr.BitOr_1_0 returns HexLiteral
	 *     BitXor returns HexLiteral
	 *     BitXor.BitXor_1_0 returns HexLiteral
	 *     BitAnd returns HexLiteral
	 *     BitAnd.BitAnd_1_0 returns HexLiteral
	 *     Shift returns HexLiteral
	 *     Shift.Shift_1_0 returns HexLiteral
	 *     AddSub returns HexLiteral
	 *     AddSub.AddSub_1_0_0 returns HexLiteral
	 *     MulDivMod returns HexLiteral
	 *     MulDivMod.MulDivMod_1_0 returns HexLiteral
	 *     Exponent returns HexLiteral
	 *     Exponent.Exponent_1_0 returns HexLiteral
	 *     UnaryExpression returns HexLiteral
	 *     PreExpression returns HexLiteral
	 *     PreExpression.PreIncExpression_1_2 returns HexLiteral
	 *     PreExpression.PreDecExpression_2_2 returns HexLiteral
	 *     PostIncDecExpression returns HexLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns HexLiteral
	 *     PrimaryExpression returns HexLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns HexLiteral
	 *     Literal returns HexLiteral
	 *     Number returns HexLiteral
	 *     HexLiteral returns HexLiteral
	 *
	 * Constraint:
	 *     value=HEX
	 */
	protected void sequence_HexLiteral(ISerializationContext context, HexLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getHexLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getHexLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHexLiteralAccess().getValueHEXTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression trueBody=Statement falseBody=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDirective returns ImportDirective
	 *
	 * Constraint:
	 *     (importURI=STRING | (unitAlias=ID importURI=STRING) | (symbolAliases+=SymbolAlias symbolAliases+=SymbolAlias? importURI=STRING))
	 */
	protected void sequence_ImportDirective(ISerializationContext context, ImportDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Index
	 *     Index returns Index
	 *
	 * Constraint:
	 *     value=Expression?
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns IndexedSpecifer
	 *     IndexedSpecifer returns IndexedSpecifer
	 *
	 * Constraint:
	 *     {IndexedSpecifer}
	 */
	protected void sequence_IndexedSpecifer(ISerializationContext context, IndexedSpecifer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InheritanceSpecifier returns InheritanceSpecifier
	 *
	 * Constraint:
	 *     (superType=[ContractOrLibrary|ID] args=FunctionCallListArguments?)
	 */
	protected void sequence_InheritanceSpecifier(ISerializationContext context, InheritanceSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractOrLibrary returns Library
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=ID (inheritanceSpecifiers+=InheritanceSpecifier inheritanceSpecifiers+=InheritanceSpecifier*)? body=DefinitionBody)
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns LocationSpecifier
	 *     LocationSpecifier returns LocationSpecifier
	 *
	 * Constraint:
	 *     location=LocationSpecifierEnum
	 */
	protected void sequence_LocationSpecifier(ISerializationContext context, LocationSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getLocationSpecifier_Location()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getLocationSpecifier_Location()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationSpecifierAccess().getLocationLocationSpecifierEnumEnumRuleCall_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Mapping
	 *     StandardType returns Mapping
	 *     StandardTypeWithoutQualifiedIdentifier returns Mapping
	 *     Mapping returns Mapping
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns Mapping
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns Mapping
	 *
	 * Constraint:
	 *     (keyType=ElementaryTypeNameEnum valueType=Type)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getMapping_KeyType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getMapping_KeyType()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getMapping_ValueType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getMapping_ValueType()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingAccess().getKeyTypeElementaryTypeNameEnumEnumRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMappingAccess().getValueTypeTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns ModifierInvocation
	 *     ModifierInvocation returns ModifierInvocation
	 *
	 * Constraint:
	 *     (name=[Modifier|ID] args=FunctionCallListArguments?)
	 */
	protected void sequence_ModifierInvocation(ISerializationContext context, ModifierInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList? block=Body)
	 */
	protected void sequence_Modifier(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulDivMod
	 *     Assignment returns MulDivMod
	 *     Assignment.Assignment_1_0_0 returns MulDivMod
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns MulDivMod
	 *     BinaryExpression returns MulDivMod
	 *     Or returns MulDivMod
	 *     Or.Or_1_0 returns MulDivMod
	 *     And returns MulDivMod
	 *     And.And_1_0 returns MulDivMod
	 *     Equality returns MulDivMod
	 *     Equality.Equality_1_0 returns MulDivMod
	 *     Comparison returns MulDivMod
	 *     Comparison.Comparison_1_0 returns MulDivMod
	 *     BitOr returns MulDivMod
	 *     BitOr.BitOr_1_0 returns MulDivMod
	 *     BitXor returns MulDivMod
	 *     BitXor.BitXor_1_0 returns MulDivMod
	 *     BitAnd returns MulDivMod
	 *     BitAnd.BitAnd_1_0 returns MulDivMod
	 *     Shift returns MulDivMod
	 *     Shift.Shift_1_0 returns MulDivMod
	 *     AddSub returns MulDivMod
	 *     AddSub.AddSub_1_0_0 returns MulDivMod
	 *     MulDivMod returns MulDivMod
	 *     MulDivMod.MulDivMod_1_0 returns MulDivMod
	 *     Exponent returns MulDivMod
	 *     Exponent.Exponent_1_0 returns MulDivMod
	 *     UnaryExpression returns MulDivMod
	 *     PreExpression returns MulDivMod
	 *     PreExpression.PreIncExpression_1_2 returns MulDivMod
	 *     PreExpression.PreDecExpression_2_2 returns MulDivMod
	 *     PostIncDecExpression returns MulDivMod
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns MulDivMod
	 *     PrimaryExpression returns MulDivMod
	 *     PrimaryExpression.Tuple_4_2_0 returns MulDivMod
	 *
	 * Constraint:
	 *     (left=MulDivMod_MulDivMod_1_0 multipliciativeOp=MulDivModOpEnum right=Exponent)
	 */
	protected void sequence_MulDivMod(ISerializationContext context, MulDivMod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getMulDivMod_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getMulDivMod_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getMulDivMod_MultipliciativeOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getMulDivMod_MultipliciativeOp()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getMulDivMod_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getMulDivMod_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivModAccess().getMultipliciativeOpMulDivModOpEnumEnumRuleCall_1_1_0(), semanticObject.getMultipliciativeOp());
		feeder.accept(grammarAccess.getMulDivModAccess().getRightExponentParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NewExpression
	 *     Assignment returns NewExpression
	 *     Assignment.Assignment_1_0_0 returns NewExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NewExpression
	 *     BinaryExpression returns NewExpression
	 *     Or returns NewExpression
	 *     Or.Or_1_0 returns NewExpression
	 *     And returns NewExpression
	 *     And.And_1_0 returns NewExpression
	 *     Equality returns NewExpression
	 *     Equality.Equality_1_0 returns NewExpression
	 *     Comparison returns NewExpression
	 *     Comparison.Comparison_1_0 returns NewExpression
	 *     BitOr returns NewExpression
	 *     BitOr.BitOr_1_0 returns NewExpression
	 *     BitXor returns NewExpression
	 *     BitXor.BitXor_1_0 returns NewExpression
	 *     BitAnd returns NewExpression
	 *     BitAnd.BitAnd_1_0 returns NewExpression
	 *     Shift returns NewExpression
	 *     Shift.Shift_1_0 returns NewExpression
	 *     AddSub returns NewExpression
	 *     AddSub.AddSub_1_0_0 returns NewExpression
	 *     MulDivMod returns NewExpression
	 *     MulDivMod.MulDivMod_1_0 returns NewExpression
	 *     Exponent returns NewExpression
	 *     Exponent.Exponent_1_0 returns NewExpression
	 *     UnaryExpression returns NewExpression
	 *     NewExpression returns NewExpression
	 *     PreExpression returns NewExpression
	 *     PreExpression.PreIncExpression_1_2 returns NewExpression
	 *     PreExpression.PreDecExpression_2_2 returns NewExpression
	 *     PostIncDecExpression returns NewExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NewExpression
	 *     PrimaryExpression returns NewExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns NewExpression
	 *
	 * Constraint:
	 *     (contract=[ContractOrLibrary|ID] args=FunctionCallListArguments)
	 */
	protected void sequence_NewExpression(ISerializationContext context, NewExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getNewExpression_Contract()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getNewExpression_Contract()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getNewExpression_Args()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getNewExpression_Args()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNewExpressionAccess().getContractContractOrLibraryIDTerminalRuleCall_1_0_1(), semanticObject.eGet(MyGrammarPackage.eINSTANCE.getNewExpression_Contract(), false));
		feeder.accept(grammarAccess.getNewExpressionAccess().getArgsFunctionCallListArgumentsParserRuleCall_2_0(), semanticObject.getArgs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     Assignment returns NotExpression
	 *     Assignment.Assignment_1_0_0 returns NotExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NotExpression
	 *     BinaryExpression returns NotExpression
	 *     Or returns NotExpression
	 *     Or.Or_1_0 returns NotExpression
	 *     And returns NotExpression
	 *     And.And_1_0 returns NotExpression
	 *     Equality returns NotExpression
	 *     Equality.Equality_1_0 returns NotExpression
	 *     Comparison returns NotExpression
	 *     Comparison.Comparison_1_0 returns NotExpression
	 *     BitOr returns NotExpression
	 *     BitOr.BitOr_1_0 returns NotExpression
	 *     BitXor returns NotExpression
	 *     BitXor.BitXor_1_0 returns NotExpression
	 *     BitAnd returns NotExpression
	 *     BitAnd.BitAnd_1_0 returns NotExpression
	 *     Shift returns NotExpression
	 *     Shift.Shift_1_0 returns NotExpression
	 *     AddSub returns NotExpression
	 *     AddSub.AddSub_1_0_0 returns NotExpression
	 *     MulDivMod returns NotExpression
	 *     MulDivMod.MulDivMod_1_0 returns NotExpression
	 *     Exponent returns NotExpression
	 *     Exponent.Exponent_1_0 returns NotExpression
	 *     UnaryExpression returns NotExpression
	 *     NotExpression returns NotExpression
	 *     PreExpression returns NotExpression
	 *     PreExpression.PreIncExpression_1_2 returns NotExpression
	 *     PreExpression.PreDecExpression_2_2 returns NotExpression
	 *     PostIncDecExpression returns NotExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NotExpression
	 *     PrimaryExpression returns NotExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns NotExpression
	 *
	 * Constraint:
	 *     expression=UnaryExpression
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getNotExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getNotExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Now
	 *     Assignment returns Now
	 *     Assignment.Assignment_1_0_0 returns Now
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Now
	 *     BinaryExpression returns Now
	 *     Or returns Now
	 *     Or.Or_1_0 returns Now
	 *     And returns Now
	 *     And.And_1_0 returns Now
	 *     Equality returns Now
	 *     Equality.Equality_1_0 returns Now
	 *     Comparison returns Now
	 *     Comparison.Comparison_1_0 returns Now
	 *     BitOr returns Now
	 *     BitOr.BitOr_1_0 returns Now
	 *     BitXor returns Now
	 *     BitXor.BitXor_1_0 returns Now
	 *     BitAnd returns Now
	 *     BitAnd.BitAnd_1_0 returns Now
	 *     Shift returns Now
	 *     Shift.Shift_1_0 returns Now
	 *     AddSub returns Now
	 *     AddSub.AddSub_1_0_0 returns Now
	 *     MulDivMod returns Now
	 *     MulDivMod.MulDivMod_1_0 returns Now
	 *     Exponent returns Now
	 *     Exponent.Exponent_1_0 returns Now
	 *     UnaryExpression returns Now
	 *     PreExpression returns Now
	 *     PreExpression.PreIncExpression_1_2 returns Now
	 *     PreExpression.PreDecExpression_2_2 returns Now
	 *     PostIncDecExpression returns Now
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Now
	 *     PrimaryExpression returns Now
	 *     PrimaryExpression.Tuple_4_2_0 returns Now
	 *     Literal returns Now
	 *     Number returns Now
	 *     Now returns Now
	 *
	 * Constraint:
	 *     {Now}
	 */
	protected void sequence_Now(ISerializationContext context, Now semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberDimensionless
	 *     Assignment returns NumberDimensionless
	 *     Assignment.Assignment_1_0_0 returns NumberDimensionless
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NumberDimensionless
	 *     BinaryExpression returns NumberDimensionless
	 *     Or returns NumberDimensionless
	 *     Or.Or_1_0 returns NumberDimensionless
	 *     And returns NumberDimensionless
	 *     And.And_1_0 returns NumberDimensionless
	 *     Equality returns NumberDimensionless
	 *     Equality.Equality_1_0 returns NumberDimensionless
	 *     Comparison returns NumberDimensionless
	 *     Comparison.Comparison_1_0 returns NumberDimensionless
	 *     BitOr returns NumberDimensionless
	 *     BitOr.BitOr_1_0 returns NumberDimensionless
	 *     BitXor returns NumberDimensionless
	 *     BitXor.BitXor_1_0 returns NumberDimensionless
	 *     BitAnd returns NumberDimensionless
	 *     BitAnd.BitAnd_1_0 returns NumberDimensionless
	 *     Shift returns NumberDimensionless
	 *     Shift.Shift_1_0 returns NumberDimensionless
	 *     AddSub returns NumberDimensionless
	 *     AddSub.AddSub_1_0_0 returns NumberDimensionless
	 *     MulDivMod returns NumberDimensionless
	 *     MulDivMod.MulDivMod_1_0 returns NumberDimensionless
	 *     Exponent returns NumberDimensionless
	 *     Exponent.Exponent_1_0 returns NumberDimensionless
	 *     UnaryExpression returns NumberDimensionless
	 *     PreExpression returns NumberDimensionless
	 *     PreExpression.PreIncExpression_1_2 returns NumberDimensionless
	 *     PreExpression.PreDecExpression_2_2 returns NumberDimensionless
	 *     PostIncDecExpression returns NumberDimensionless
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NumberDimensionless
	 *     PrimaryExpression returns NumberDimensionless
	 *     PrimaryExpression.Tuple_4_2_0 returns NumberDimensionless
	 *     Literal returns NumberDimensionless
	 *     Number returns NumberDimensionless
	 *     NumberDimensionless returns NumberDimensionless
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberDimensionless(ISerializationContext context, NumberDimensionless semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getNumberDimensionless_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getNumberDimensionless_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberDimensionlessAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Assignment returns Or
	 *     Assignment.Assignment_1_0_0 returns Or
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Or
	 *     BinaryExpression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     BitOr returns Or
	 *     BitOr.BitOr_1_0 returns Or
	 *     BitXor returns Or
	 *     BitXor.BitXor_1_0 returns Or
	 *     BitAnd returns Or
	 *     BitAnd.BitAnd_1_0 returns Or
	 *     Shift returns Or
	 *     Shift.Shift_1_0 returns Or
	 *     AddSub returns Or
	 *     AddSub.AddSub_1_0_0 returns Or
	 *     MulDivMod returns Or
	 *     MulDivMod.MulDivMod_1_0 returns Or
	 *     Exponent returns Or
	 *     Exponent.Exponent_1_0 returns Or
	 *     UnaryExpression returns Or
	 *     PreExpression returns Or
	 *     PreExpression.PreIncExpression_1_2 returns Or
	 *     PreExpression.PreDecExpression_2_2 returns Or
	 *     PostIncDecExpression returns Or
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Or
	 *     PrimaryExpression returns Or
	 *     PrimaryExpression.Tuple_4_2_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getOr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getOr_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getOr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getOr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=VariableDeclaration parameters+=VariableDeclaration*)?
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlaceHolderStatement
	 *     PlaceHolderStatement returns PlaceHolderStatement
	 *
	 * Constraint:
	 *     {PlaceHolderStatement}
	 */
	protected void sequence_PlaceHolderStatement(ISerializationContext context, PlaceHolderStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PostIncDecExpression
	 *     Assignment returns PostIncDecExpression
	 *     Assignment.Assignment_1_0_0 returns PostIncDecExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PostIncDecExpression
	 *     BinaryExpression returns PostIncDecExpression
	 *     Or returns PostIncDecExpression
	 *     Or.Or_1_0 returns PostIncDecExpression
	 *     And returns PostIncDecExpression
	 *     And.And_1_0 returns PostIncDecExpression
	 *     Equality returns PostIncDecExpression
	 *     Equality.Equality_1_0 returns PostIncDecExpression
	 *     Comparison returns PostIncDecExpression
	 *     Comparison.Comparison_1_0 returns PostIncDecExpression
	 *     BitOr returns PostIncDecExpression
	 *     BitOr.BitOr_1_0 returns PostIncDecExpression
	 *     BitXor returns PostIncDecExpression
	 *     BitXor.BitXor_1_0 returns PostIncDecExpression
	 *     BitAnd returns PostIncDecExpression
	 *     BitAnd.BitAnd_1_0 returns PostIncDecExpression
	 *     Shift returns PostIncDecExpression
	 *     Shift.Shift_1_0 returns PostIncDecExpression
	 *     AddSub returns PostIncDecExpression
	 *     AddSub.AddSub_1_0_0 returns PostIncDecExpression
	 *     MulDivMod returns PostIncDecExpression
	 *     MulDivMod.MulDivMod_1_0 returns PostIncDecExpression
	 *     Exponent returns PostIncDecExpression
	 *     Exponent.Exponent_1_0 returns PostIncDecExpression
	 *     UnaryExpression returns PostIncDecExpression
	 *     PreExpression returns PostIncDecExpression
	 *     PreExpression.PreIncExpression_1_2 returns PostIncDecExpression
	 *     PreExpression.PreDecExpression_2_2 returns PostIncDecExpression
	 *     PostIncDecExpression returns PostIncDecExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PostIncDecExpression
	 *     PrimaryExpression returns PostIncDecExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PostIncDecExpression
	 *
	 * Constraint:
	 *     (expression=PostIncDecExpression_PostIncDecExpression_1_0 postOp=IncDecOpEnum)
	 */
	protected void sequence_PostIncDecExpression(ISerializationContext context, PostIncDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getPostIncDecExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getPostIncDecExpression_Expression()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getPostIncDecExpression_PostOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getPostIncDecExpression_PostOp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPostIncDecExpressionAccess().getPostOpIncDecOpEnumEnumRuleCall_1_1_0(), semanticObject.getPostOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PreDecExpression returns PreDecExpression
	 *
	 * Constraint:
	 *     expression=PostIncDecExpression
	 */
	protected void sequence_PreDecExpression(ISerializationContext context, PreDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getPreDecExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getPreDecExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreDecExpressionAccess().getExpressionPostIncDecExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreDecExpression
	 *     Assignment returns PreDecExpression
	 *     Assignment.Assignment_1_0_0 returns PreDecExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PreDecExpression
	 *     BinaryExpression returns PreDecExpression
	 *     Or returns PreDecExpression
	 *     Or.Or_1_0 returns PreDecExpression
	 *     And returns PreDecExpression
	 *     And.And_1_0 returns PreDecExpression
	 *     Equality returns PreDecExpression
	 *     Equality.Equality_1_0 returns PreDecExpression
	 *     Comparison returns PreDecExpression
	 *     Comparison.Comparison_1_0 returns PreDecExpression
	 *     BitOr returns PreDecExpression
	 *     BitOr.BitOr_1_0 returns PreDecExpression
	 *     BitXor returns PreDecExpression
	 *     BitXor.BitXor_1_0 returns PreDecExpression
	 *     BitAnd returns PreDecExpression
	 *     BitAnd.BitAnd_1_0 returns PreDecExpression
	 *     Shift returns PreDecExpression
	 *     Shift.Shift_1_0 returns PreDecExpression
	 *     AddSub returns PreDecExpression
	 *     AddSub.AddSub_1_0_0 returns PreDecExpression
	 *     MulDivMod returns PreDecExpression
	 *     MulDivMod.MulDivMod_1_0 returns PreDecExpression
	 *     Exponent returns PreDecExpression
	 *     Exponent.Exponent_1_0 returns PreDecExpression
	 *     UnaryExpression returns PreDecExpression
	 *     PreExpression returns PreDecExpression
	 *     PreExpression.PreIncExpression_1_2 returns PreDecExpression
	 *     PreExpression.PreDecExpression_2_2 returns PreDecExpression
	 *     PostIncDecExpression returns PreDecExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PreDecExpression
	 *     PrimaryExpression returns PreDecExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PreDecExpression
	 *
	 * Constraint:
	 *     expression=PreExpression_PreDecExpression_2_2
	 */
	protected void sequence_PreExpression(ISerializationContext context, PreDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getPreDecExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getPreDecExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreIncExpression
	 *     Assignment returns PreIncExpression
	 *     Assignment.Assignment_1_0_0 returns PreIncExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PreIncExpression
	 *     BinaryExpression returns PreIncExpression
	 *     Or returns PreIncExpression
	 *     Or.Or_1_0 returns PreIncExpression
	 *     And returns PreIncExpression
	 *     And.And_1_0 returns PreIncExpression
	 *     Equality returns PreIncExpression
	 *     Equality.Equality_1_0 returns PreIncExpression
	 *     Comparison returns PreIncExpression
	 *     Comparison.Comparison_1_0 returns PreIncExpression
	 *     BitOr returns PreIncExpression
	 *     BitOr.BitOr_1_0 returns PreIncExpression
	 *     BitXor returns PreIncExpression
	 *     BitXor.BitXor_1_0 returns PreIncExpression
	 *     BitAnd returns PreIncExpression
	 *     BitAnd.BitAnd_1_0 returns PreIncExpression
	 *     Shift returns PreIncExpression
	 *     Shift.Shift_1_0 returns PreIncExpression
	 *     AddSub returns PreIncExpression
	 *     AddSub.AddSub_1_0_0 returns PreIncExpression
	 *     MulDivMod returns PreIncExpression
	 *     MulDivMod.MulDivMod_1_0 returns PreIncExpression
	 *     Exponent returns PreIncExpression
	 *     Exponent.Exponent_1_0 returns PreIncExpression
	 *     UnaryExpression returns PreIncExpression
	 *     PreExpression returns PreIncExpression
	 *     PreExpression.PreIncExpression_1_2 returns PreIncExpression
	 *     PreExpression.PreDecExpression_2_2 returns PreIncExpression
	 *     PostIncDecExpression returns PreIncExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PreIncExpression
	 *     PrimaryExpression returns PreIncExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PreIncExpression
	 *
	 * Constraint:
	 *     expression=PreExpression_PreIncExpression_1_2
	 */
	protected void sequence_PreExpression(ISerializationContext context, PreIncExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getPreIncExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getPreIncExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PreIncExpression returns PreIncExpression
	 *
	 * Constraint:
	 *     expression=PostIncDecExpression
	 */
	protected void sequence_PreIncExpression(ISerializationContext context, PreIncExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getPreIncExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getPreIncExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreIncExpressionAccess().getExpressionPostIncDecExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Tuple
	 *     Assignment returns Tuple
	 *     Assignment.Assignment_1_0_0 returns Tuple
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Tuple
	 *     BinaryExpression returns Tuple
	 *     Or returns Tuple
	 *     Or.Or_1_0 returns Tuple
	 *     And returns Tuple
	 *     And.And_1_0 returns Tuple
	 *     Equality returns Tuple
	 *     Equality.Equality_1_0 returns Tuple
	 *     Comparison returns Tuple
	 *     Comparison.Comparison_1_0 returns Tuple
	 *     BitOr returns Tuple
	 *     BitOr.BitOr_1_0 returns Tuple
	 *     BitXor returns Tuple
	 *     BitXor.BitXor_1_0 returns Tuple
	 *     BitAnd returns Tuple
	 *     BitAnd.BitAnd_1_0 returns Tuple
	 *     Shift returns Tuple
	 *     Shift.Shift_1_0 returns Tuple
	 *     AddSub returns Tuple
	 *     AddSub.AddSub_1_0_0 returns Tuple
	 *     MulDivMod returns Tuple
	 *     MulDivMod.MulDivMod_1_0 returns Tuple
	 *     Exponent returns Tuple
	 *     Exponent.Exponent_1_0 returns Tuple
	 *     UnaryExpression returns Tuple
	 *     PreExpression returns Tuple
	 *     PreExpression.PreIncExpression_1_2 returns Tuple
	 *     PreExpression.PreDecExpression_2_2 returns Tuple
	 *     PostIncDecExpression returns Tuple
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Tuple
	 *     PrimaryExpression returns Tuple
	 *     PrimaryExpression.Tuple_4_2_0 returns Tuple
	 *
	 * Constraint:
	 *     (
	 *         (members+=PrimaryExpression_Tuple_4_2_0 (members+=TupleSeparator members+=Expression?)+) | 
	 *         (members+=PrimaryExpression_Tuple_5_2_0 members+=Expression? (members+=TupleSeparator members+=Expression?)*)
	 *     )?
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns QualifiedIdentifier
	 *     StandardType returns QualifiedIdentifier
	 *     QualifiedIdentifier returns QualifiedIdentifier
	 *     Expression returns QualifiedIdentifier
	 *     Assignment returns QualifiedIdentifier
	 *     Assignment.Assignment_1_0_0 returns QualifiedIdentifier
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns QualifiedIdentifier
	 *     BinaryExpression returns QualifiedIdentifier
	 *     Or returns QualifiedIdentifier
	 *     Or.Or_1_0 returns QualifiedIdentifier
	 *     And returns QualifiedIdentifier
	 *     And.And_1_0 returns QualifiedIdentifier
	 *     Equality returns QualifiedIdentifier
	 *     Equality.Equality_1_0 returns QualifiedIdentifier
	 *     Comparison returns QualifiedIdentifier
	 *     Comparison.Comparison_1_0 returns QualifiedIdentifier
	 *     BitOr returns QualifiedIdentifier
	 *     BitOr.BitOr_1_0 returns QualifiedIdentifier
	 *     BitXor returns QualifiedIdentifier
	 *     BitXor.BitXor_1_0 returns QualifiedIdentifier
	 *     BitAnd returns QualifiedIdentifier
	 *     BitAnd.BitAnd_1_0 returns QualifiedIdentifier
	 *     Shift returns QualifiedIdentifier
	 *     Shift.Shift_1_0 returns QualifiedIdentifier
	 *     AddSub returns QualifiedIdentifier
	 *     AddSub.AddSub_1_0_0 returns QualifiedIdentifier
	 *     MulDivMod returns QualifiedIdentifier
	 *     MulDivMod.MulDivMod_1_0 returns QualifiedIdentifier
	 *     Exponent returns QualifiedIdentifier
	 *     Exponent.Exponent_1_0 returns QualifiedIdentifier
	 *     UnaryExpression returns QualifiedIdentifier
	 *     PreExpression returns QualifiedIdentifier
	 *     PreExpression.PreIncExpression_1_2 returns QualifiedIdentifier
	 *     PreExpression.PreDecExpression_2_2 returns QualifiedIdentifier
	 *     PostIncDecExpression returns QualifiedIdentifier
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns QualifiedIdentifier
	 *     PrimaryExpression returns QualifiedIdentifier
	 *     PrimaryExpression.Tuple_4_2_0 returns QualifiedIdentifier
	 *
	 * Constraint:
	 *     (identifier=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_QualifiedIdentifier(ISerializationContext context, QualifiedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnParameterDeclaration returns ReturnParameterDeclaration
	 *
	 * Constraint:
	 *     (typeRef=Type variable=Variable?)
	 */
	protected void sequence_ReturnParameterDeclaration(ISerializationContext context, ReturnParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnsParameterList returns ReturnsParameterList
	 *
	 * Constraint:
	 *     (parameters+=ReturnParameterDeclaration parameters+=ReturnParameterDeclaration*)?
	 */
	protected void sequence_ReturnsParameterList(ISerializationContext context, ReturnsParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Shift
	 *     Assignment returns Shift
	 *     Assignment.Assignment_1_0_0 returns Shift
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Shift
	 *     BinaryExpression returns Shift
	 *     Or returns Shift
	 *     Or.Or_1_0 returns Shift
	 *     And returns Shift
	 *     And.And_1_0 returns Shift
	 *     Equality returns Shift
	 *     Equality.Equality_1_0 returns Shift
	 *     Comparison returns Shift
	 *     Comparison.Comparison_1_0 returns Shift
	 *     BitOr returns Shift
	 *     BitOr.BitOr_1_0 returns Shift
	 *     BitXor returns Shift
	 *     BitXor.BitXor_1_0 returns Shift
	 *     BitAnd returns Shift
	 *     BitAnd.BitAnd_1_0 returns Shift
	 *     Shift returns Shift
	 *     Shift.Shift_1_0 returns Shift
	 *     AddSub returns Shift
	 *     AddSub.AddSub_1_0_0 returns Shift
	 *     MulDivMod returns Shift
	 *     MulDivMod.MulDivMod_1_0 returns Shift
	 *     Exponent returns Shift
	 *     Exponent.Exponent_1_0 returns Shift
	 *     UnaryExpression returns Shift
	 *     PreExpression returns Shift
	 *     PreExpression.PreIncExpression_1_2 returns Shift
	 *     PreExpression.PreDecExpression_2_2 returns Shift
	 *     PostIncDecExpression returns Shift
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Shift
	 *     PrimaryExpression returns Shift
	 *     PrimaryExpression.Tuple_4_2_0 returns Shift
	 *
	 * Constraint:
	 *     (left=Shift_Shift_1_0 shiftOp=ShiftOpEnum right=AddSub)
	 */
	protected void sequence_Shift(ISerializationContext context, Shift semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getShift_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getShift_Left()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getShift_ShiftOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getShift_ShiftOp()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getShift_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getShift_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShiftAccess().getShiftLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getShiftAccess().getShiftOpShiftOpEnumEnumRuleCall_1_1_0(), semanticObject.getShiftOp());
		feeder.accept(grammarAccess.getShiftAccess().getRightAddSubParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SignExpression
	 *     Assignment returns SignExpression
	 *     Assignment.Assignment_1_0_0 returns SignExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SignExpression
	 *     BinaryExpression returns SignExpression
	 *     Or returns SignExpression
	 *     Or.Or_1_0 returns SignExpression
	 *     And returns SignExpression
	 *     And.And_1_0 returns SignExpression
	 *     Equality returns SignExpression
	 *     Equality.Equality_1_0 returns SignExpression
	 *     Comparison returns SignExpression
	 *     Comparison.Comparison_1_0 returns SignExpression
	 *     BitOr returns SignExpression
	 *     BitOr.BitOr_1_0 returns SignExpression
	 *     BitXor returns SignExpression
	 *     BitXor.BitXor_1_0 returns SignExpression
	 *     BitAnd returns SignExpression
	 *     BitAnd.BitAnd_1_0 returns SignExpression
	 *     Shift returns SignExpression
	 *     Shift.Shift_1_0 returns SignExpression
	 *     AddSub returns SignExpression
	 *     AddSub.AddSub_1_0_0 returns SignExpression
	 *     MulDivMod returns SignExpression
	 *     MulDivMod.MulDivMod_1_0 returns SignExpression
	 *     Exponent returns SignExpression
	 *     Exponent.Exponent_1_0 returns SignExpression
	 *     UnaryExpression returns SignExpression
	 *     SignExpression returns SignExpression
	 *     PreExpression returns SignExpression
	 *     PreExpression.PreIncExpression_1_2 returns SignExpression
	 *     PreExpression.PreDecExpression_2_2 returns SignExpression
	 *     PostIncDecExpression returns SignExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SignExpression
	 *     PrimaryExpression returns SignExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns SignExpression
	 *
	 * Constraint:
	 *     ((signOp='+' | signOp='-') expression=UnaryExpression)
	 */
	protected void sequence_SignExpression(ISerializationContext context, SignExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement2_StandardVariableDeclaration_0_1_0 
	 *         optionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression?
	 *     )
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getTupleTupleParserRuleCall_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getVariableVariableParserRuleCall_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns StandardVariableDeclaration
	 *     Statement returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement_StandardVariableDeclaration_0_0_1_0 
	 *         ptionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression? 
	 *         semicolon?=';'
	 *     )
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTupleVariableDeclaration
	 *     Statement returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Semicolon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Semicolon()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getTupleTupleParserRuleCall_0_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTypeDeclaration
	 *     Statement returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Semicolon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVarVariableTypeDeclaration_Semicolon()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getVariableVariableParserRuleCall_0_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Solidity returns Solidity
	 *
	 * Constraint:
	 *     (importDirective+=ImportDirective | contract+=Contract | library+=Library)+
	 */
	protected void sequence_Solidity(ISerializationContext context, Solidity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SpecialExpression
	 *     SpecialExpression returns SpecialExpression
	 *     Assignment returns SpecialExpression
	 *     Assignment.Assignment_1_0_0 returns SpecialExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SpecialExpression
	 *     BinaryExpression returns SpecialExpression
	 *     Or returns SpecialExpression
	 *     Or.Or_1_0 returns SpecialExpression
	 *     And returns SpecialExpression
	 *     And.And_1_0 returns SpecialExpression
	 *     Equality returns SpecialExpression
	 *     Equality.Equality_1_0 returns SpecialExpression
	 *     Comparison returns SpecialExpression
	 *     Comparison.Comparison_1_0 returns SpecialExpression
	 *     BitOr returns SpecialExpression
	 *     BitOr.BitOr_1_0 returns SpecialExpression
	 *     BitXor returns SpecialExpression
	 *     BitXor.BitXor_1_0 returns SpecialExpression
	 *     BitAnd returns SpecialExpression
	 *     BitAnd.BitAnd_1_0 returns SpecialExpression
	 *     Shift returns SpecialExpression
	 *     Shift.Shift_1_0 returns SpecialExpression
	 *     AddSub returns SpecialExpression
	 *     AddSub.AddSub_1_0_0 returns SpecialExpression
	 *     MulDivMod returns SpecialExpression
	 *     MulDivMod.MulDivMod_1_0 returns SpecialExpression
	 *     Exponent returns SpecialExpression
	 *     Exponent.Exponent_1_0 returns SpecialExpression
	 *     UnaryExpression returns SpecialExpression
	 *     PreExpression returns SpecialExpression
	 *     PreExpression.PreIncExpression_1_2 returns SpecialExpression
	 *     PreExpression.PreDecExpression_2_2 returns SpecialExpression
	 *     PostIncDecExpression returns SpecialExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SpecialExpression
	 *     PrimaryExpression returns SpecialExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns SpecialExpression
	 *
	 * Constraint:
	 *     (type=SpecialExpressionTypeEnum fieldOrMethod=Field? (qualifiers+=Index | qualifiers+=Arguments)*)
	 */
	protected void sequence_SpecialExpression(ISerializationContext context, SpecialExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpecialVariablesTypeEnum returns SpecialVariablesTypeEnum
	 *
	 * Constraint:
	 *     (name=BLOCK | name=MSG | name=TX)
	 */
	protected void sequence_SpecialVariablesTypeEnum(ISerializationContext context, SpecialVariablesTypeEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SpecialVariables
	 *     Assignment returns SpecialVariables
	 *     Assignment.Assignment_1_0_0 returns SpecialVariables
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SpecialVariables
	 *     BinaryExpression returns SpecialVariables
	 *     Or returns SpecialVariables
	 *     Or.Or_1_0 returns SpecialVariables
	 *     And returns SpecialVariables
	 *     And.And_1_0 returns SpecialVariables
	 *     Equality returns SpecialVariables
	 *     Equality.Equality_1_0 returns SpecialVariables
	 *     Comparison returns SpecialVariables
	 *     Comparison.Comparison_1_0 returns SpecialVariables
	 *     BitOr returns SpecialVariables
	 *     BitOr.BitOr_1_0 returns SpecialVariables
	 *     BitXor returns SpecialVariables
	 *     BitXor.BitXor_1_0 returns SpecialVariables
	 *     BitAnd returns SpecialVariables
	 *     BitAnd.BitAnd_1_0 returns SpecialVariables
	 *     Shift returns SpecialVariables
	 *     Shift.Shift_1_0 returns SpecialVariables
	 *     AddSub returns SpecialVariables
	 *     AddSub.AddSub_1_0_0 returns SpecialVariables
	 *     MulDivMod returns SpecialVariables
	 *     MulDivMod.MulDivMod_1_0 returns SpecialVariables
	 *     Exponent returns SpecialVariables
	 *     Exponent.Exponent_1_0 returns SpecialVariables
	 *     UnaryExpression returns SpecialVariables
	 *     PreExpression returns SpecialVariables
	 *     PreExpression.PreIncExpression_1_2 returns SpecialVariables
	 *     PreExpression.PreDecExpression_2_2 returns SpecialVariables
	 *     PostIncDecExpression returns SpecialVariables
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SpecialVariables
	 *     PrimaryExpression returns SpecialVariables
	 *     PrimaryExpression.Tuple_4_2_0 returns SpecialVariables
	 *     Literal returns SpecialVariables
	 *     SpecialVariables returns SpecialVariables
	 *
	 * Constraint:
	 *     (type=SpecialVariablesTypeEnum field=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_SpecialVariables(ISerializationContext context, SpecialVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns StandardVariableDeclaration
	 *     StandardVariableDeclaration returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable expression=Expression?)
	 */
	protected void sequence_StandardVariableDeclaration(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Assignment returns StringLiteral
	 *     Assignment.Assignment_1_0_0 returns StringLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns StringLiteral
	 *     BinaryExpression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0 returns StringLiteral
	 *     BitOr returns StringLiteral
	 *     BitOr.BitOr_1_0 returns StringLiteral
	 *     BitXor returns StringLiteral
	 *     BitXor.BitXor_1_0 returns StringLiteral
	 *     BitAnd returns StringLiteral
	 *     BitAnd.BitAnd_1_0 returns StringLiteral
	 *     Shift returns StringLiteral
	 *     Shift.Shift_1_0 returns StringLiteral
	 *     AddSub returns StringLiteral
	 *     AddSub.AddSub_1_0_0 returns StringLiteral
	 *     MulDivMod returns StringLiteral
	 *     MulDivMod.MulDivMod_1_0 returns StringLiteral
	 *     Exponent returns StringLiteral
	 *     Exponent.Exponent_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     PreExpression returns StringLiteral
	 *     PreExpression.PreIncExpression_1_2 returns StringLiteral
	 *     PreExpression.PreDecExpression_2_2 returns StringLiteral
	 *     PostIncDecExpression returns StringLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getStringLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getStringLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StructDefinition returns StructDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilityEnum? name=ID members+=VariableDeclaration*)
	 */
	protected void sequence_StructDefinition(ISerializationContext context, StructDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolAlias returns SymbolAlias
	 *
	 * Constraint:
	 *     (symbol=ID alias=ID)
	 */
	protected void sequence_SymbolAlias(ISerializationContext context, SymbolAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getSymbolAlias_Symbol()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getSymbolAlias_Symbol()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getSymbolAlias_Alias()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getSymbolAlias_Alias()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolAliasAccess().getSymbolIDTerminalRuleCall_0_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getSymbolAliasAccess().getAliasIDTerminalRuleCall_2_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ThrowStatement
	 *     ThrowStatement returns ThrowStatement
	 *
	 * Constraint:
	 *     {ThrowStatement}
	 */
	protected void sequence_ThrowStatement(ISerializationContext context, ThrowStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Time
	 *     Assignment returns Time
	 *     Assignment.Assignment_1_0_0 returns Time
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Time
	 *     BinaryExpression returns Time
	 *     Or returns Time
	 *     Or.Or_1_0 returns Time
	 *     And returns Time
	 *     And.And_1_0 returns Time
	 *     Equality returns Time
	 *     Equality.Equality_1_0 returns Time
	 *     Comparison returns Time
	 *     Comparison.Comparison_1_0 returns Time
	 *     BitOr returns Time
	 *     BitOr.BitOr_1_0 returns Time
	 *     BitXor returns Time
	 *     BitXor.BitXor_1_0 returns Time
	 *     BitAnd returns Time
	 *     BitAnd.BitAnd_1_0 returns Time
	 *     Shift returns Time
	 *     Shift.Shift_1_0 returns Time
	 *     AddSub returns Time
	 *     AddSub.AddSub_1_0_0 returns Time
	 *     MulDivMod returns Time
	 *     MulDivMod.MulDivMod_1_0 returns Time
	 *     Exponent returns Time
	 *     Exponent.Exponent_1_0 returns Time
	 *     UnaryExpression returns Time
	 *     PreExpression returns Time
	 *     PreExpression.PreIncExpression_1_2 returns Time
	 *     PreExpression.PreDecExpression_2_2 returns Time
	 *     PostIncDecExpression returns Time
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Time
	 *     PrimaryExpression returns Time
	 *     PrimaryExpression.Tuple_4_2_0 returns Time
	 *     Literal returns Time
	 *     Number returns Time
	 *     Time returns Time
	 *
	 * Constraint:
	 *     (value=INT time=TimeSubdenominationEnum)
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getTime_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getTime_Value()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getTime_Time()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getTime_Time()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeAccess().getTimeTimeSubdenominationEnumEnumRuleCall_1_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TupleSeparator returns TupleSeparator
	 *     PrimaryExpression.Tuple_5_2_0 returns TupleSeparator
	 *
	 * Constraint:
	 *     {TupleSeparator}
	 */
	protected void sequence_TupleSeparator(ISerializationContext context, TupleSeparator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tuple returns Tuple
	 *
	 * Constraint:
	 *     (members+=Expression? (members+=TupleSeparator members+=Expression?)+)?
	 */
	protected void sequence_Tuple(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TypeCast
	 *     Assignment returns TypeCast
	 *     Assignment.Assignment_1_0_0 returns TypeCast
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns TypeCast
	 *     BinaryExpression returns TypeCast
	 *     Or returns TypeCast
	 *     Or.Or_1_0 returns TypeCast
	 *     And returns TypeCast
	 *     And.And_1_0 returns TypeCast
	 *     Equality returns TypeCast
	 *     Equality.Equality_1_0 returns TypeCast
	 *     Comparison returns TypeCast
	 *     Comparison.Comparison_1_0 returns TypeCast
	 *     BitOr returns TypeCast
	 *     BitOr.BitOr_1_0 returns TypeCast
	 *     BitXor returns TypeCast
	 *     BitXor.BitXor_1_0 returns TypeCast
	 *     BitAnd returns TypeCast
	 *     BitAnd.BitAnd_1_0 returns TypeCast
	 *     Shift returns TypeCast
	 *     Shift.Shift_1_0 returns TypeCast
	 *     AddSub returns TypeCast
	 *     AddSub.AddSub_1_0_0 returns TypeCast
	 *     MulDivMod returns TypeCast
	 *     MulDivMod.MulDivMod_1_0 returns TypeCast
	 *     Exponent returns TypeCast
	 *     Exponent.Exponent_1_0 returns TypeCast
	 *     UnaryExpression returns TypeCast
	 *     PreExpression returns TypeCast
	 *     PreExpression.PreIncExpression_1_2 returns TypeCast
	 *     PreExpression.PreDecExpression_2_2 returns TypeCast
	 *     PostIncDecExpression returns TypeCast
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns TypeCast
	 *     PrimaryExpression returns TypeCast
	 *     PrimaryExpression.Tuple_4_2_0 returns TypeCast
	 *     TypeCast returns TypeCast
	 *
	 * Constraint:
	 *     (value=ElementaryTypeNameEnum expression=Expression)
	 */
	protected void sequence_TypeCast(ISerializationContext context, TypeCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getTypeCast_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getTypeCast_Value()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getTypeCast_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getTypeCast_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeCastAccess().getValueElementaryTypeNameEnumEnumRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTypeCastAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     isVarType?=VarType
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getType_IsVarType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getType_IsVarType()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getIsVarTypeVarTypeParserRuleCall_1_0(), semanticObject.isIsVarType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableDeclaration
	 *     VarVariableDeclaration returns VarVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType variable=Variable expression=Expression?)
	 */
	protected void sequence_VarVariableDeclaration(ISerializationContext context, VarVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableTupleVariableDeclaration
	 *     VarVariableTupleVariableDeclaration returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType tuple=Tuple expression=Expression?)
	 */
	protected void sequence_VarVariableTupleVariableDeclaration(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVariable_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVariable_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns VisibilitySpecifier
	 *     VisibilitySpecifier returns VisibilitySpecifier
	 *     VariableDeclarationOptionalElement returns VisibilitySpecifier
	 *
	 * Constraint:
	 *     visibility=VisibilityEnum
	 */
	protected void sequence_VisibilitySpecifier(ISerializationContext context, VisibilitySpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getVisibilitySpecifier_Visibility()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getVisibilitySpecifier_Visibility()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVisibilitySpecifierAccess().getVisibilityVisibilityEnumEnumRuleCall_0(), semanticObject.getVisibility());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getWhileStatement_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getWhileStatement_Condition()));
			if (transientValues.isValueTransient(semanticObject, MyGrammarPackage.eINSTANCE.getWhileStatement_Body()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyGrammarPackage.eINSTANCE.getWhileStatement_Body()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
