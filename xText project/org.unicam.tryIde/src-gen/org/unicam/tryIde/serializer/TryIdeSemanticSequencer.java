/*
 * generated by Xtext 2.19.0
 */
package org.unicam.tryIde.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.unicam.tryIde.services.TryIdeGrammarAccess;
import org.unicam.tryIde.solidity.AddSub;
import org.unicam.tryIde.solidity.And;
import org.unicam.tryIde.solidity.Arguments;
import org.unicam.tryIde.solidity.ArrayDimensions;
import org.unicam.tryIde.solidity.Assignment;
import org.unicam.tryIde.solidity.BinaryNotExpression;
import org.unicam.tryIde.solidity.BitAnd;
import org.unicam.tryIde.solidity.BitOr;
import org.unicam.tryIde.solidity.BitXor;
import org.unicam.tryIde.solidity.Blocks;
import org.unicam.tryIde.solidity.BooleanConst;
import org.unicam.tryIde.solidity.BreakStatement;
import org.unicam.tryIde.solidity.Comparison;
import org.unicam.tryIde.solidity.Const;
import org.unicam.tryIde.solidity.ConstantSpecifier;
import org.unicam.tryIde.solidity.Continue;
import org.unicam.tryIde.solidity.Contract;
import org.unicam.tryIde.solidity.DecimalLiteral;
import org.unicam.tryIde.solidity.DefinitionBody;
import org.unicam.tryIde.solidity.DeleteStatement;
import org.unicam.tryIde.solidity.ElementaryType;
import org.unicam.tryIde.solidity.EnumDefinition;
import org.unicam.tryIde.solidity.EnumValue;
import org.unicam.tryIde.solidity.Equality;
import org.unicam.tryIde.solidity.Ether;
import org.unicam.tryIde.solidity.Event;
import org.unicam.tryIde.solidity.Exponent;
import org.unicam.tryIde.solidity.ExpressionStatement;
import org.unicam.tryIde.solidity.Field;
import org.unicam.tryIde.solidity.ForStatement;
import org.unicam.tryIde.solidity.FunctionCallArg;
import org.unicam.tryIde.solidity.FunctionCallArguments;
import org.unicam.tryIde.solidity.FunctionCallListArguments;
import org.unicam.tryIde.solidity.FunctionDefinition;
import org.unicam.tryIde.solidity.HexLiteral;
import org.unicam.tryIde.solidity.IfStatement;
import org.unicam.tryIde.solidity.ImportDirective;
import org.unicam.tryIde.solidity.Index;
import org.unicam.tryIde.solidity.IndexedSpecifer;
import org.unicam.tryIde.solidity.InheritanceSpecifier;
import org.unicam.tryIde.solidity.Library;
import org.unicam.tryIde.solidity.LocationSpecifier;
import org.unicam.tryIde.solidity.Mapping;
import org.unicam.tryIde.solidity.Modifier;
import org.unicam.tryIde.solidity.ModifierInvocation;
import org.unicam.tryIde.solidity.MulDivMod;
import org.unicam.tryIde.solidity.NewExpression;
import org.unicam.tryIde.solidity.NotExpression;
import org.unicam.tryIde.solidity.NumberDimensionless;
import org.unicam.tryIde.solidity.Or;
import org.unicam.tryIde.solidity.ParameterList;
import org.unicam.tryIde.solidity.PlaceHolderStatement;
import org.unicam.tryIde.solidity.PostIncDecExpression;
import org.unicam.tryIde.solidity.PreDecExpression;
import org.unicam.tryIde.solidity.PreIncExpression;
import org.unicam.tryIde.solidity.QualifiedIdentifier;
import org.unicam.tryIde.solidity.ReturnParameterDeclaration;
import org.unicam.tryIde.solidity.ReturnStatement;
import org.unicam.tryIde.solidity.ReturnsParameterList;
import org.unicam.tryIde.solidity.Shift;
import org.unicam.tryIde.solidity.SignExpression;
import org.unicam.tryIde.solidity.Solidity;
import org.unicam.tryIde.solidity.SolidityPackage;
import org.unicam.tryIde.solidity.SpecialExpression;
import org.unicam.tryIde.solidity.SpecialVariables;
import org.unicam.tryIde.solidity.SpecialVariablesTypeEnum;
import org.unicam.tryIde.solidity.StandardVariableDeclaration;
import org.unicam.tryIde.solidity.StringLiteral;
import org.unicam.tryIde.solidity.StructDefinition;
import org.unicam.tryIde.solidity.SymbolAlias;
import org.unicam.tryIde.solidity.ThrowStatement;
import org.unicam.tryIde.solidity.Time;
import org.unicam.tryIde.solidity.Tuple;
import org.unicam.tryIde.solidity.TupleSeparator;
import org.unicam.tryIde.solidity.Type;
import org.unicam.tryIde.solidity.TypeCast;
import org.unicam.tryIde.solidity.VarVariableDeclaration;
import org.unicam.tryIde.solidity.VarVariableTupleVariableDeclaration;
import org.unicam.tryIde.solidity.VarVariableTypeDeclaration;
import org.unicam.tryIde.solidity.Variable;
import org.unicam.tryIde.solidity.VariableDeclarationExpression;
import org.unicam.tryIde.solidity.VisibilitySpecifier;
import org.unicam.tryIde.solidity.WhileStatement;

@SuppressWarnings("all")
public class TryIdeSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private TryIdeGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SolidityPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SolidityPackage.ADD_SUB:
				sequence_AddSub(context, (AddSub) semanticObject); 
				return; 
			case SolidityPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case SolidityPackage.ARGUMENTS:
				sequence_Arguments(context, (Arguments) semanticObject); 
				return; 
			case SolidityPackage.ARRAY_DIMENSIONS:
				sequence_ArrayDimensions(context, (ArrayDimensions) semanticObject); 
				return; 
			case SolidityPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case SolidityPackage.BINARY_NOT_EXPRESSION:
				sequence_BinaryNotExpression(context, (BinaryNotExpression) semanticObject); 
				return; 
			case SolidityPackage.BIT_AND:
				sequence_BitAnd(context, (BitAnd) semanticObject); 
				return; 
			case SolidityPackage.BIT_OR:
				sequence_BitOr(context, (BitOr) semanticObject); 
				return; 
			case SolidityPackage.BIT_XOR:
				sequence_BitXor(context, (BitXor) semanticObject); 
				return; 
			case SolidityPackage.BLOCKS:
				sequence_Blocks(context, (Blocks) semanticObject); 
				return; 
			case SolidityPackage.BOOLEAN_CONST:
				sequence_BooleanConst(context, (BooleanConst) semanticObject); 
				return; 
			case SolidityPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case SolidityPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case SolidityPackage.CONST:
				sequence_Const(context, (Const) semanticObject); 
				return; 
			case SolidityPackage.CONSTANT_SPECIFIER:
				sequence_ConstantSpecifier(context, (ConstantSpecifier) semanticObject); 
				return; 
			case SolidityPackage.CONTINUE:
				sequence_ContinueStatement(context, (Continue) semanticObject); 
				return; 
			case SolidityPackage.CONTRACT:
				sequence_Contract(context, (Contract) semanticObject); 
				return; 
			case SolidityPackage.DECIMAL_LITERAL:
				sequence_DecimalLiteral(context, (DecimalLiteral) semanticObject); 
				return; 
			case SolidityPackage.DEFINITION_BODY:
				sequence_DefinitionBody(context, (DefinitionBody) semanticObject); 
				return; 
			case SolidityPackage.DELETE_STATEMENT:
				sequence_DeleteStatement(context, (DeleteStatement) semanticObject); 
				return; 
			case SolidityPackage.ELEMENTARY_TYPE:
				if (rule == grammarAccess.getElementaryTypeRule()) {
					sequence_ElementaryType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getStandardTypeWithoutQualifiedIdentifierRule()
						|| action == grammarAccess.getSimpleStatementAccess().getStandardVariableDeclarationTypeAction_0_0_1_0()
						|| action == grammarAccess.getSimpleStatement2Access().getStandardVariableDeclarationTypeAction_0_1_0()) {
					sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(context, (ElementaryType) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTypeRule()
						|| rule == grammarAccess.getStandardTypeRule()) {
					sequence_ElementaryType_StandardType(context, (ElementaryType) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.ENUM_DEFINITION:
				sequence_EnumDefinition(context, (EnumDefinition) semanticObject); 
				return; 
			case SolidityPackage.ENUM_VALUE:
				sequence_EnumValue(context, (EnumValue) semanticObject); 
				return; 
			case SolidityPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case SolidityPackage.ETHER:
				sequence_Ether(context, (Ether) semanticObject); 
				return; 
			case SolidityPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case SolidityPackage.EXPONENT:
				sequence_Exponent(context, (Exponent) semanticObject); 
				return; 
			case SolidityPackage.EXPRESSION_STATEMENT:
				if (rule == grammarAccess.getSimpleStatement2Rule()
						|| rule == grammarAccess.getExpressionStatementRule()) {
					sequence_ExpressionStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_ExpressionStatement_SimpleStatement(context, (ExpressionStatement) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case SolidityPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case SolidityPackage.FUNCTION_CALL_ARG:
				sequence_FunctionCallArg(context, (FunctionCallArg) semanticObject); 
				return; 
			case SolidityPackage.FUNCTION_CALL_ARGUMENTS:
				sequence_FunctionCallArguments(context, (FunctionCallArguments) semanticObject); 
				return; 
			case SolidityPackage.FUNCTION_CALL_LIST_ARGUMENTS:
				sequence_FunctionCallListArguments(context, (FunctionCallListArguments) semanticObject); 
				return; 
			case SolidityPackage.FUNCTION_DEFINITION:
				sequence_FunctionDefinition(context, (FunctionDefinition) semanticObject); 
				return; 
			case SolidityPackage.HEX_LITERAL:
				sequence_HexLiteral(context, (HexLiteral) semanticObject); 
				return; 
			case SolidityPackage.IF_STATEMENT:
				sequence_IfStatement(context, (IfStatement) semanticObject); 
				return; 
			case SolidityPackage.IMPORT_DIRECTIVE:
				sequence_ImportDirective(context, (ImportDirective) semanticObject); 
				return; 
			case SolidityPackage.INDEX:
				sequence_Index(context, (Index) semanticObject); 
				return; 
			case SolidityPackage.INDEXED_SPECIFER:
				sequence_IndexedSpecifer(context, (IndexedSpecifer) semanticObject); 
				return; 
			case SolidityPackage.INHERITANCE_SPECIFIER:
				sequence_InheritanceSpecifier(context, (InheritanceSpecifier) semanticObject); 
				return; 
			case SolidityPackage.LIBRARY:
				sequence_Library(context, (Library) semanticObject); 
				return; 
			case SolidityPackage.LOCATION_SPECIFIER:
				sequence_LocationSpecifier(context, (LocationSpecifier) semanticObject); 
				return; 
			case SolidityPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case SolidityPackage.MODIFIER:
				sequence_Modifier(context, (Modifier) semanticObject); 
				return; 
			case SolidityPackage.MODIFIER_INVOCATION:
				sequence_ModifierInvocation(context, (ModifierInvocation) semanticObject); 
				return; 
			case SolidityPackage.MUL_DIV_MOD:
				sequence_MulDivMod(context, (MulDivMod) semanticObject); 
				return; 
			case SolidityPackage.NEW_EXPRESSION:
				sequence_NewExpression(context, (NewExpression) semanticObject); 
				return; 
			case SolidityPackage.NOT_EXPRESSION:
				sequence_NotExpression(context, (NotExpression) semanticObject); 
				return; 
			case SolidityPackage.NUMBER_DIMENSIONLESS:
				sequence_NumberDimensionless(context, (NumberDimensionless) semanticObject); 
				return; 
			case SolidityPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case SolidityPackage.PARAMETER_LIST:
				sequence_ParameterList(context, (ParameterList) semanticObject); 
				return; 
			case SolidityPackage.PLACE_HOLDER_STATEMENT:
				sequence_PlaceHolderStatement(context, (PlaceHolderStatement) semanticObject); 
				return; 
			case SolidityPackage.POST_INC_DEC_EXPRESSION:
				sequence_PostIncDecExpression(context, (PostIncDecExpression) semanticObject); 
				return; 
			case SolidityPackage.PRE_DEC_EXPRESSION:
				if (rule == grammarAccess.getPreDecExpressionRule()) {
					sequence_PreDecExpression(context, (PreDecExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()) {
					sequence_PreExpression(context, (PreDecExpression) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.PRE_INC_EXPRESSION:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()) {
					sequence_PreExpression(context, (PreIncExpression) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPreIncExpressionRule()) {
					sequence_PreIncExpression(context, (PreIncExpression) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.QUALIFIED_IDENTIFIER:
				sequence_QualifiedIdentifier(context, (QualifiedIdentifier) semanticObject); 
				return; 
			case SolidityPackage.RETURN_PARAMETER_DECLARATION:
				sequence_ReturnParameterDeclaration(context, (ReturnParameterDeclaration) semanticObject); 
				return; 
			case SolidityPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case SolidityPackage.RETURNS_PARAMETER_LIST:
				sequence_ReturnsParameterList(context, (ReturnsParameterList) semanticObject); 
				return; 
			case SolidityPackage.SHIFT:
				sequence_Shift(context, (Shift) semanticObject); 
				return; 
			case SolidityPackage.SIGN_EXPRESSION:
				sequence_SignExpression(context, (SignExpression) semanticObject); 
				return; 
			case SolidityPackage.SOLIDITY:
				sequence_Solidity(context, (Solidity) semanticObject); 
				return; 
			case SolidityPackage.SPECIAL_EXPRESSION:
				sequence_SpecialExpression(context, (SpecialExpression) semanticObject); 
				return; 
			case SolidityPackage.SPECIAL_VARIABLES:
				sequence_SpecialVariables(context, (SpecialVariables) semanticObject); 
				return; 
			case SolidityPackage.SPECIAL_VARIABLES_TYPE_ENUM:
				sequence_SpecialVariablesTypeEnum(context, (SpecialVariablesTypeEnum) semanticObject); 
				return; 
			case SolidityPackage.STANDARD_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getStandardVariableDeclarationRule()) {
					sequence_StandardVariableDeclaration(context, (StandardVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case SolidityPackage.STRUCT_DEFINITION:
				sequence_StructDefinition(context, (StructDefinition) semanticObject); 
				return; 
			case SolidityPackage.SYMBOL_ALIAS:
				sequence_SymbolAlias(context, (SymbolAlias) semanticObject); 
				return; 
			case SolidityPackage.THROW_STATEMENT:
				sequence_ThrowStatement(context, (ThrowStatement) semanticObject); 
				return; 
			case SolidityPackage.TIME:
				sequence_Time(context, (Time) semanticObject); 
				return; 
			case SolidityPackage.TUPLE:
				if (rule == grammarAccess.getExpressionRule()
						|| rule == grammarAccess.getAssignmentRule()
						|| action == grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0()
						|| action == grammarAccess.getAssignmentAccess().getVariableDeclarationExpressionTypeAction_1_1_0()
						|| rule == grammarAccess.getBinaryExpressionRule()
						|| rule == grammarAccess.getOrRule()
						|| action == grammarAccess.getOrAccess().getOrLeftAction_1_0()
						|| rule == grammarAccess.getAndRule()
						|| action == grammarAccess.getAndAccess().getAndLeftAction_1_0()
						|| rule == grammarAccess.getEqualityRule()
						|| action == grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0()
						|| rule == grammarAccess.getComparisonRule()
						|| action == grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0()
						|| rule == grammarAccess.getBitOrRule()
						|| action == grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0()
						|| rule == grammarAccess.getBitXorRule()
						|| action == grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0()
						|| rule == grammarAccess.getBitAndRule()
						|| action == grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0()
						|| rule == grammarAccess.getShiftRule()
						|| action == grammarAccess.getShiftAccess().getShiftLeftAction_1_0()
						|| rule == grammarAccess.getAddSubRule()
						|| action == grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0()
						|| rule == grammarAccess.getMulDivModRule()
						|| action == grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0()
						|| rule == grammarAccess.getExponentRule()
						|| action == grammarAccess.getExponentAccess().getExponentLeftAction_1_0()
						|| rule == grammarAccess.getUnaryExpressionRule()
						|| rule == grammarAccess.getPreExpressionRule()
						|| action == grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2()
						|| action == grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2()
						|| rule == grammarAccess.getPostIncDecExpressionRule()
						|| action == grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0()
						|| rule == grammarAccess.getPrimaryExpressionRule()
						|| action == grammarAccess.getPrimaryExpressionAccess().getTupleMembersAction_4_2_0()) {
					sequence_PrimaryExpression(context, (Tuple) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTupleRule()) {
					sequence_Tuple(context, (Tuple) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.TUPLE_SEPARATOR:
				sequence_TupleSeparator(context, (TupleSeparator) semanticObject); 
				return; 
			case SolidityPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case SolidityPackage.TYPE_CAST:
				sequence_TypeCast(context, (TypeCast) semanticObject); 
				return; 
			case SolidityPackage.VAR_VARIABLE_DECLARATION:
				sequence_VarVariableDeclaration(context, (VarVariableDeclaration) semanticObject); 
				return; 
			case SolidityPackage.VAR_VARIABLE_TUPLE_VARIABLE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getVariableDeclarationRule()
						|| rule == grammarAccess.getVarVariableTupleVariableDeclarationRule()) {
					sequence_VarVariableTupleVariableDeclaration(context, (VarVariableTupleVariableDeclaration) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.VAR_VARIABLE_TYPE_DECLARATION:
				if (rule == grammarAccess.getSimpleStatement2Rule()) {
					sequence_SimpleStatement2(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getSimpleStatementRule()
						|| rule == grammarAccess.getStatementRule()) {
					sequence_SimpleStatement(context, (VarVariableTypeDeclaration) semanticObject); 
					return; 
				}
				else break;
			case SolidityPackage.VARIABLE:
				sequence_Variable(context, (Variable) semanticObject); 
				return; 
			case SolidityPackage.VARIABLE_DECLARATION_EXPRESSION:
				sequence_Assignment(context, (VariableDeclarationExpression) semanticObject); 
				return; 
			case SolidityPackage.VISIBILITY_SPECIFIER:
				sequence_VisibilitySpecifier(context, (VisibilitySpecifier) semanticObject); 
				return; 
			case SolidityPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns AddSub
	 *     Assignment returns AddSub
	 *     Assignment.Assignment_1_0_0 returns AddSub
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns AddSub
	 *     BinaryExpression returns AddSub
	 *     Or returns AddSub
	 *     Or.Or_1_0 returns AddSub
	 *     And returns AddSub
	 *     And.And_1_0 returns AddSub
	 *     Equality returns AddSub
	 *     Equality.Equality_1_0 returns AddSub
	 *     Comparison returns AddSub
	 *     Comparison.Comparison_1_0 returns AddSub
	 *     BitOr returns AddSub
	 *     BitOr.BitOr_1_0 returns AddSub
	 *     BitXor returns AddSub
	 *     BitXor.BitXor_1_0 returns AddSub
	 *     BitAnd returns AddSub
	 *     BitAnd.BitAnd_1_0 returns AddSub
	 *     Shift returns AddSub
	 *     Shift.Shift_1_0 returns AddSub
	 *     AddSub returns AddSub
	 *     AddSub.AddSub_1_0_0 returns AddSub
	 *     MulDivMod returns AddSub
	 *     MulDivMod.MulDivMod_1_0 returns AddSub
	 *     Exponent returns AddSub
	 *     Exponent.Exponent_1_0 returns AddSub
	 *     UnaryExpression returns AddSub
	 *     PreExpression returns AddSub
	 *     PreExpression.PreIncExpression_1_2 returns AddSub
	 *     PreExpression.PreDecExpression_2_2 returns AddSub
	 *     PostIncDecExpression returns AddSub
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns AddSub
	 *     PrimaryExpression returns AddSub
	 *     PrimaryExpression.Tuple_4_2_0 returns AddSub
	 *
	 * Constraint:
	 *     (left=AddSub_AddSub_1_0_0 additionOp=AdditionOpEnum right=MulDivMod)
	 */
	protected void sequence_AddSub(ISerializationContext context, AddSub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAddSub_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAddSub_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAddSub_AdditionOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAddSub_AdditionOp()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAddSub_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAddSub_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddSubAccess().getAddSubLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAddSubAccess().getAdditionOpAdditionOpEnumEnumRuleCall_1_0_1_0(), semanticObject.getAdditionOp());
		feeder.accept(grammarAccess.getAddSubAccess().getRightMulDivModParserRuleCall_1_0_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns And
	 *     Assignment returns And
	 *     Assignment.Assignment_1_0_0 returns And
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns And
	 *     BinaryExpression returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     BitOr returns And
	 *     BitOr.BitOr_1_0 returns And
	 *     BitXor returns And
	 *     BitXor.BitXor_1_0 returns And
	 *     BitAnd returns And
	 *     BitAnd.BitAnd_1_0 returns And
	 *     Shift returns And
	 *     Shift.Shift_1_0 returns And
	 *     AddSub returns And
	 *     AddSub.AddSub_1_0_0 returns And
	 *     MulDivMod returns And
	 *     MulDivMod.MulDivMod_1_0 returns And
	 *     Exponent returns And
	 *     Exponent.Exponent_1_0 returns And
	 *     UnaryExpression returns And
	 *     PreExpression returns And
	 *     PreExpression.PreIncExpression_1_2 returns And
	 *     PreExpression.PreDecExpression_2_2 returns And
	 *     PostIncDecExpression returns And
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns And
	 *     PrimaryExpression returns And
	 *     PrimaryExpression.Tuple_4_2_0 returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=Equality)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAnd_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAnd_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAnd_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAnd_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Arguments
	 *     Arguments returns Arguments
	 *
	 * Constraint:
	 *     arguments=FunctionCallArguments
	 */
	protected void sequence_Arguments(ISerializationContext context, Arguments semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getArguments_Arguments()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getArguments_Arguments()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArgumentsAccess().getArgumentsFunctionCallArgumentsParserRuleCall_0(), semanticObject.getArguments());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ArrayDimensions returns ArrayDimensions
	 *
	 * Constraint:
	 *     (value+=Expression? value+=Expression*)
	 */
	protected void sequence_ArrayDimensions(ISerializationContext context, ArrayDimensions semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *     Assignment.Assignment_1_0_0 returns Assignment
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Assignment
	 *     BinaryExpression returns Assignment
	 *     Or returns Assignment
	 *     Or.Or_1_0 returns Assignment
	 *     And returns Assignment
	 *     And.And_1_0 returns Assignment
	 *     Equality returns Assignment
	 *     Equality.Equality_1_0 returns Assignment
	 *     Comparison returns Assignment
	 *     Comparison.Comparison_1_0 returns Assignment
	 *     BitOr returns Assignment
	 *     BitOr.BitOr_1_0 returns Assignment
	 *     BitXor returns Assignment
	 *     BitXor.BitXor_1_0 returns Assignment
	 *     BitAnd returns Assignment
	 *     BitAnd.BitAnd_1_0 returns Assignment
	 *     Shift returns Assignment
	 *     Shift.Shift_1_0 returns Assignment
	 *     AddSub returns Assignment
	 *     AddSub.AddSub_1_0_0 returns Assignment
	 *     MulDivMod returns Assignment
	 *     MulDivMod.MulDivMod_1_0 returns Assignment
	 *     Exponent returns Assignment
	 *     Exponent.Exponent_1_0 returns Assignment
	 *     UnaryExpression returns Assignment
	 *     PreExpression returns Assignment
	 *     PreExpression.PreIncExpression_1_2 returns Assignment
	 *     PreExpression.PreDecExpression_2_2 returns Assignment
	 *     PostIncDecExpression returns Assignment
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Assignment
	 *     PrimaryExpression returns Assignment
	 *     PrimaryExpression.Tuple_4_2_0 returns Assignment
	 *
	 * Constraint:
	 *     (left=Assignment_Assignment_1_0_0 assignmentOp=AssignmentOpEnum expression=Expression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAssignment_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAssignment_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAssignment_AssignmentOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAssignment_AssignmentOp()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getAssignment_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getAssignment_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentLeftAction_1_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAssignmentAccess().getAssignmentOpAssignmentOpEnumEnumRuleCall_1_0_1_0(), semanticObject.getAssignmentOp());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpressionExpressionParserRuleCall_1_0_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VariableDeclarationExpression
	 *     Assignment returns VariableDeclarationExpression
	 *     Assignment.Assignment_1_0_0 returns VariableDeclarationExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns VariableDeclarationExpression
	 *     BinaryExpression returns VariableDeclarationExpression
	 *     Or returns VariableDeclarationExpression
	 *     Or.Or_1_0 returns VariableDeclarationExpression
	 *     And returns VariableDeclarationExpression
	 *     And.And_1_0 returns VariableDeclarationExpression
	 *     Equality returns VariableDeclarationExpression
	 *     Equality.Equality_1_0 returns VariableDeclarationExpression
	 *     Comparison returns VariableDeclarationExpression
	 *     Comparison.Comparison_1_0 returns VariableDeclarationExpression
	 *     BitOr returns VariableDeclarationExpression
	 *     BitOr.BitOr_1_0 returns VariableDeclarationExpression
	 *     BitXor returns VariableDeclarationExpression
	 *     BitXor.BitXor_1_0 returns VariableDeclarationExpression
	 *     BitAnd returns VariableDeclarationExpression
	 *     BitAnd.BitAnd_1_0 returns VariableDeclarationExpression
	 *     Shift returns VariableDeclarationExpression
	 *     Shift.Shift_1_0 returns VariableDeclarationExpression
	 *     AddSub returns VariableDeclarationExpression
	 *     AddSub.AddSub_1_0_0 returns VariableDeclarationExpression
	 *     MulDivMod returns VariableDeclarationExpression
	 *     MulDivMod.MulDivMod_1_0 returns VariableDeclarationExpression
	 *     Exponent returns VariableDeclarationExpression
	 *     Exponent.Exponent_1_0 returns VariableDeclarationExpression
	 *     UnaryExpression returns VariableDeclarationExpression
	 *     PreExpression returns VariableDeclarationExpression
	 *     PreExpression.PreIncExpression_1_2 returns VariableDeclarationExpression
	 *     PreExpression.PreDecExpression_2_2 returns VariableDeclarationExpression
	 *     PostIncDecExpression returns VariableDeclarationExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns VariableDeclarationExpression
	 *     PrimaryExpression returns VariableDeclarationExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns VariableDeclarationExpression
	 *
	 * Constraint:
	 *     (type=Assignment_VariableDeclarationExpression_1_1_0 variable=Variable expression=Expression?)
	 */
	protected void sequence_Assignment(ISerializationContext context, VariableDeclarationExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BinaryNotExpression
	 *     Assignment returns BinaryNotExpression
	 *     Assignment.Assignment_1_0_0 returns BinaryNotExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BinaryNotExpression
	 *     BinaryExpression returns BinaryNotExpression
	 *     Or returns BinaryNotExpression
	 *     Or.Or_1_0 returns BinaryNotExpression
	 *     And returns BinaryNotExpression
	 *     And.And_1_0 returns BinaryNotExpression
	 *     Equality returns BinaryNotExpression
	 *     Equality.Equality_1_0 returns BinaryNotExpression
	 *     Comparison returns BinaryNotExpression
	 *     Comparison.Comparison_1_0 returns BinaryNotExpression
	 *     BitOr returns BinaryNotExpression
	 *     BitOr.BitOr_1_0 returns BinaryNotExpression
	 *     BitXor returns BinaryNotExpression
	 *     BitXor.BitXor_1_0 returns BinaryNotExpression
	 *     BitAnd returns BinaryNotExpression
	 *     BitAnd.BitAnd_1_0 returns BinaryNotExpression
	 *     Shift returns BinaryNotExpression
	 *     Shift.Shift_1_0 returns BinaryNotExpression
	 *     AddSub returns BinaryNotExpression
	 *     AddSub.AddSub_1_0_0 returns BinaryNotExpression
	 *     MulDivMod returns BinaryNotExpression
	 *     MulDivMod.MulDivMod_1_0 returns BinaryNotExpression
	 *     Exponent returns BinaryNotExpression
	 *     Exponent.Exponent_1_0 returns BinaryNotExpression
	 *     UnaryExpression returns BinaryNotExpression
	 *     BinaryNotExpression returns BinaryNotExpression
	 *     PreExpression returns BinaryNotExpression
	 *     PreExpression.PreIncExpression_1_2 returns BinaryNotExpression
	 *     PreExpression.PreDecExpression_2_2 returns BinaryNotExpression
	 *     PostIncDecExpression returns BinaryNotExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BinaryNotExpression
	 *     PrimaryExpression returns BinaryNotExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns BinaryNotExpression
	 *
	 * Constraint:
	 *     expression=UnaryExpression
	 */
	protected void sequence_BinaryNotExpression(ISerializationContext context, BinaryNotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBinaryNotExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBinaryNotExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryNotExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitAnd
	 *     Assignment returns BitAnd
	 *     Assignment.Assignment_1_0_0 returns BitAnd
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitAnd
	 *     BinaryExpression returns BitAnd
	 *     Or returns BitAnd
	 *     Or.Or_1_0 returns BitAnd
	 *     And returns BitAnd
	 *     And.And_1_0 returns BitAnd
	 *     Equality returns BitAnd
	 *     Equality.Equality_1_0 returns BitAnd
	 *     Comparison returns BitAnd
	 *     Comparison.Comparison_1_0 returns BitAnd
	 *     BitOr returns BitAnd
	 *     BitOr.BitOr_1_0 returns BitAnd
	 *     BitXor returns BitAnd
	 *     BitXor.BitXor_1_0 returns BitAnd
	 *     BitAnd returns BitAnd
	 *     BitAnd.BitAnd_1_0 returns BitAnd
	 *     Shift returns BitAnd
	 *     Shift.Shift_1_0 returns BitAnd
	 *     AddSub returns BitAnd
	 *     AddSub.AddSub_1_0_0 returns BitAnd
	 *     MulDivMod returns BitAnd
	 *     MulDivMod.MulDivMod_1_0 returns BitAnd
	 *     Exponent returns BitAnd
	 *     Exponent.Exponent_1_0 returns BitAnd
	 *     UnaryExpression returns BitAnd
	 *     PreExpression returns BitAnd
	 *     PreExpression.PreIncExpression_1_2 returns BitAnd
	 *     PreExpression.PreDecExpression_2_2 returns BitAnd
	 *     PostIncDecExpression returns BitAnd
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitAnd
	 *     PrimaryExpression returns BitAnd
	 *     PrimaryExpression.Tuple_4_2_0 returns BitAnd
	 *
	 * Constraint:
	 *     (left=BitAnd_BitAnd_1_0 right=Shift)
	 */
	protected void sequence_BitAnd(ISerializationContext context, BitAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBitAnd_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBitAnd_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBitAnd_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBitAnd_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitAndAccess().getRightShiftParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitOr
	 *     Assignment returns BitOr
	 *     Assignment.Assignment_1_0_0 returns BitOr
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitOr
	 *     BinaryExpression returns BitOr
	 *     Or returns BitOr
	 *     Or.Or_1_0 returns BitOr
	 *     And returns BitOr
	 *     And.And_1_0 returns BitOr
	 *     Equality returns BitOr
	 *     Equality.Equality_1_0 returns BitOr
	 *     Comparison returns BitOr
	 *     Comparison.Comparison_1_0 returns BitOr
	 *     BitOr returns BitOr
	 *     BitOr.BitOr_1_0 returns BitOr
	 *     BitXor returns BitOr
	 *     BitXor.BitXor_1_0 returns BitOr
	 *     BitAnd returns BitOr
	 *     BitAnd.BitAnd_1_0 returns BitOr
	 *     Shift returns BitOr
	 *     Shift.Shift_1_0 returns BitOr
	 *     AddSub returns BitOr
	 *     AddSub.AddSub_1_0_0 returns BitOr
	 *     MulDivMod returns BitOr
	 *     MulDivMod.MulDivMod_1_0 returns BitOr
	 *     Exponent returns BitOr
	 *     Exponent.Exponent_1_0 returns BitOr
	 *     UnaryExpression returns BitOr
	 *     PreExpression returns BitOr
	 *     PreExpression.PreIncExpression_1_2 returns BitOr
	 *     PreExpression.PreDecExpression_2_2 returns BitOr
	 *     PostIncDecExpression returns BitOr
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitOr
	 *     PrimaryExpression returns BitOr
	 *     PrimaryExpression.Tuple_4_2_0 returns BitOr
	 *
	 * Constraint:
	 *     (left=BitOr_BitOr_1_0 right=BitXor)
	 */
	protected void sequence_BitOr(ISerializationContext context, BitOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBitOr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBitOr_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBitOr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBitOr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitOrAccess().getRightBitXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BitXor
	 *     Assignment returns BitXor
	 *     Assignment.Assignment_1_0_0 returns BitXor
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BitXor
	 *     BinaryExpression returns BitXor
	 *     Or returns BitXor
	 *     Or.Or_1_0 returns BitXor
	 *     And returns BitXor
	 *     And.And_1_0 returns BitXor
	 *     Equality returns BitXor
	 *     Equality.Equality_1_0 returns BitXor
	 *     Comparison returns BitXor
	 *     Comparison.Comparison_1_0 returns BitXor
	 *     BitOr returns BitXor
	 *     BitOr.BitOr_1_0 returns BitXor
	 *     BitXor returns BitXor
	 *     BitXor.BitXor_1_0 returns BitXor
	 *     BitAnd returns BitXor
	 *     BitAnd.BitAnd_1_0 returns BitXor
	 *     Shift returns BitXor
	 *     Shift.Shift_1_0 returns BitXor
	 *     AddSub returns BitXor
	 *     AddSub.AddSub_1_0_0 returns BitXor
	 *     MulDivMod returns BitXor
	 *     MulDivMod.MulDivMod_1_0 returns BitXor
	 *     Exponent returns BitXor
	 *     Exponent.Exponent_1_0 returns BitXor
	 *     UnaryExpression returns BitXor
	 *     PreExpression returns BitXor
	 *     PreExpression.PreIncExpression_1_2 returns BitXor
	 *     PreExpression.PreDecExpression_2_2 returns BitXor
	 *     PostIncDecExpression returns BitXor
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BitXor
	 *     PrimaryExpression returns BitXor
	 *     PrimaryExpression.Tuple_4_2_0 returns BitXor
	 *
	 * Constraint:
	 *     (left=BitXor_BitXor_1_0 right=BitAnd)
	 */
	protected void sequence_BitXor(ISerializationContext context, BitXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBitXor_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBitXor_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBitXor_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBitXor_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitXorAccess().getRightBitAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Blocks
	 *     Blocks returns Blocks
	 *
	 * Constraint:
	 *     (statements+=Statement statements+=Statement*)?
	 */
	protected void sequence_Blocks(ISerializationContext context, Blocks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns BooleanConst
	 *     Assignment returns BooleanConst
	 *     Assignment.Assignment_1_0_0 returns BooleanConst
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns BooleanConst
	 *     BinaryExpression returns BooleanConst
	 *     Or returns BooleanConst
	 *     Or.Or_1_0 returns BooleanConst
	 *     And returns BooleanConst
	 *     And.And_1_0 returns BooleanConst
	 *     Equality returns BooleanConst
	 *     Equality.Equality_1_0 returns BooleanConst
	 *     Comparison returns BooleanConst
	 *     Comparison.Comparison_1_0 returns BooleanConst
	 *     BitOr returns BooleanConst
	 *     BitOr.BitOr_1_0 returns BooleanConst
	 *     BitXor returns BooleanConst
	 *     BitXor.BitXor_1_0 returns BooleanConst
	 *     BitAnd returns BooleanConst
	 *     BitAnd.BitAnd_1_0 returns BooleanConst
	 *     Shift returns BooleanConst
	 *     Shift.Shift_1_0 returns BooleanConst
	 *     AddSub returns BooleanConst
	 *     AddSub.AddSub_1_0_0 returns BooleanConst
	 *     MulDivMod returns BooleanConst
	 *     MulDivMod.MulDivMod_1_0 returns BooleanConst
	 *     Exponent returns BooleanConst
	 *     Exponent.Exponent_1_0 returns BooleanConst
	 *     UnaryExpression returns BooleanConst
	 *     PreExpression returns BooleanConst
	 *     PreExpression.PreIncExpression_1_2 returns BooleanConst
	 *     PreExpression.PreDecExpression_2_2 returns BooleanConst
	 *     PostIncDecExpression returns BooleanConst
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns BooleanConst
	 *     PrimaryExpression returns BooleanConst
	 *     PrimaryExpression.Tuple_4_2_0 returns BooleanConst
	 *     Literal returns BooleanConst
	 *     BooleanConst returns BooleanConst
	 *
	 * Constraint:
	 *     value=BooleanLiteralEnum
	 */
	protected void sequence_BooleanConst(ISerializationContext context, BooleanConst semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getBooleanConst_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getBooleanConst_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanConstAccess().getValueBooleanLiteralEnumEnumRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Comparison
	 *     Assignment returns Comparison
	 *     Assignment.Assignment_1_0_0 returns Comparison
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Comparison
	 *     BinaryExpression returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     BitOr returns Comparison
	 *     BitOr.BitOr_1_0 returns Comparison
	 *     BitXor returns Comparison
	 *     BitXor.BitXor_1_0 returns Comparison
	 *     BitAnd returns Comparison
	 *     BitAnd.BitAnd_1_0 returns Comparison
	 *     Shift returns Comparison
	 *     Shift.Shift_1_0 returns Comparison
	 *     AddSub returns Comparison
	 *     AddSub.AddSub_1_0_0 returns Comparison
	 *     MulDivMod returns Comparison
	 *     MulDivMod.MulDivMod_1_0 returns Comparison
	 *     Exponent returns Comparison
	 *     Exponent.Exponent_1_0 returns Comparison
	 *     UnaryExpression returns Comparison
	 *     PreExpression returns Comparison
	 *     PreExpression.PreIncExpression_1_2 returns Comparison
	 *     PreExpression.PreDecExpression_2_2 returns Comparison
	 *     PostIncDecExpression returns Comparison
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Comparison
	 *     PrimaryExpression returns Comparison
	 *     PrimaryExpression.Tuple_4_2_0 returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 comparisonOp=ComparisonOpEnum right=BitOr)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getComparison_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getComparison_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getComparison_ComparisonOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getComparison_ComparisonOp()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getComparison_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getComparison_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonAccess().getComparisonOpComparisonOpEnumEnumRuleCall_1_1_0(), semanticObject.getComparisonOp());
		feeder.accept(grammarAccess.getComparisonAccess().getRightBitOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns Const
	 *     Const returns Const
	 *
	 * Constraint:
	 *     {Const}
	 */
	protected void sequence_Const(ISerializationContext context, Const semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns ConstantSpecifier
	 *     ConstantSpecifier returns ConstantSpecifier
	 *
	 * Constraint:
	 *     {ConstantSpecifier}
	 */
	protected void sequence_ConstantSpecifier(ISerializationContext context, ConstantSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Continue
	 *     ContinueStatement returns Continue
	 *
	 * Constraint:
	 *     {Continue}
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, Continue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractOrLibrary returns Contract
	 *     Contract returns Contract
	 *
	 * Constraint:
	 *     (name=ID (inheritanceSpecifiers+=InheritanceSpecifier inheritanceSpecifiers+=InheritanceSpecifier*)? body=DefinitionBody)
	 */
	protected void sequence_Contract(ISerializationContext context, Contract semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns DecimalLiteral
	 *     Assignment returns DecimalLiteral
	 *     Assignment.Assignment_1_0_0 returns DecimalLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns DecimalLiteral
	 *     BinaryExpression returns DecimalLiteral
	 *     Or returns DecimalLiteral
	 *     Or.Or_1_0 returns DecimalLiteral
	 *     And returns DecimalLiteral
	 *     And.And_1_0 returns DecimalLiteral
	 *     Equality returns DecimalLiteral
	 *     Equality.Equality_1_0 returns DecimalLiteral
	 *     Comparison returns DecimalLiteral
	 *     Comparison.Comparison_1_0 returns DecimalLiteral
	 *     BitOr returns DecimalLiteral
	 *     BitOr.BitOr_1_0 returns DecimalLiteral
	 *     BitXor returns DecimalLiteral
	 *     BitXor.BitXor_1_0 returns DecimalLiteral
	 *     BitAnd returns DecimalLiteral
	 *     BitAnd.BitAnd_1_0 returns DecimalLiteral
	 *     Shift returns DecimalLiteral
	 *     Shift.Shift_1_0 returns DecimalLiteral
	 *     AddSub returns DecimalLiteral
	 *     AddSub.AddSub_1_0_0 returns DecimalLiteral
	 *     MulDivMod returns DecimalLiteral
	 *     MulDivMod.MulDivMod_1_0 returns DecimalLiteral
	 *     Exponent returns DecimalLiteral
	 *     Exponent.Exponent_1_0 returns DecimalLiteral
	 *     UnaryExpression returns DecimalLiteral
	 *     PreExpression returns DecimalLiteral
	 *     PreExpression.PreIncExpression_1_2 returns DecimalLiteral
	 *     PreExpression.PreDecExpression_2_2 returns DecimalLiteral
	 *     PostIncDecExpression returns DecimalLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns DecimalLiteral
	 *     PrimaryExpression returns DecimalLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns DecimalLiteral
	 *     Literal returns DecimalLiteral
	 *     Number returns DecimalLiteral
	 *     DecimalLiteral returns DecimalLiteral
	 *
	 * Constraint:
	 *     value=DECIMAL
	 */
	protected void sequence_DecimalLiteral(ISerializationContext context, DecimalLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getDecimalLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getDecimalLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDecimalLiteralAccess().getValueDECIMALTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DefinitionBody returns DefinitionBody
	 *
	 * Constraint:
	 *     (
	 *         functions+=FunctionDefinition | 
	 *         structs+=StructDefinition | 
	 *         enums+=EnumDefinition | 
	 *         variables+=VariableDeclaration | 
	 *         modifiers+=Modifier | 
	 *         events+=Event
	 *     )*
	 */
	protected void sequence_DefinitionBody(ISerializationContext context, DefinitionBody semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DeleteStatement
	 *     DeleteStatement returns DeleteStatement
	 *
	 * Constraint:
	 *     variable=QualifiedIdentifier
	 */
	protected void sequence_DeleteStatement(ISerializationContext context, DeleteStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getDeleteStatement_Variable()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getDeleteStatement_Variable()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeleteStatementAccess().getVariableQualifiedIdentifierParserRuleCall_1_0(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ElementaryType returns ElementaryType
	 *
	 * Constraint:
	 *     name=ElementaryTypeNameEnum
	 */
	protected void sequence_ElementaryType(ISerializationContext context, ElementaryType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getElementaryType_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getElementaryType_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getElementaryTypeAccess().getNameElementaryTypeNameEnumEnumRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StandardTypeWithoutQualifiedIdentifier returns ElementaryType
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns ElementaryType
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardTypeWithoutQualifiedIdentifier(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns ElementaryType
	 *     StandardType returns ElementaryType
	 *
	 * Constraint:
	 *     (name=ElementaryTypeNameEnum dimension=ArrayDimensions?)
	 */
	protected void sequence_ElementaryType_StandardType(ISerializationContext context, ElementaryType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumDefinition returns EnumDefinition
	 *
	 * Constraint:
	 *     (visibility=VisibilitySpecifier? name=ID members+=EnumValue members+=EnumValue*)
	 */
	protected void sequence_EnumDefinition(ISerializationContext context, EnumDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     EnumValue returns EnumValue
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_EnumValue(ISerializationContext context, EnumValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getEnumValue_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getEnumValue_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEnumValueAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Equality
	 *     Assignment returns Equality
	 *     Assignment.Assignment_1_0_0 returns Equality
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Equality
	 *     BinaryExpression returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     BitOr returns Equality
	 *     BitOr.BitOr_1_0 returns Equality
	 *     BitXor returns Equality
	 *     BitXor.BitXor_1_0 returns Equality
	 *     BitAnd returns Equality
	 *     BitAnd.BitAnd_1_0 returns Equality
	 *     Shift returns Equality
	 *     Shift.Shift_1_0 returns Equality
	 *     AddSub returns Equality
	 *     AddSub.AddSub_1_0_0 returns Equality
	 *     MulDivMod returns Equality
	 *     MulDivMod.MulDivMod_1_0 returns Equality
	 *     Exponent returns Equality
	 *     Exponent.Exponent_1_0 returns Equality
	 *     UnaryExpression returns Equality
	 *     PreExpression returns Equality
	 *     PreExpression.PreIncExpression_1_2 returns Equality
	 *     PreExpression.PreDecExpression_2_2 returns Equality
	 *     PostIncDecExpression returns Equality
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Equality
	 *     PrimaryExpression returns Equality
	 *     PrimaryExpression.Tuple_4_2_0 returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 equalityOp=EqualityOpEnum right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getEquality_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getEquality_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getEquality_EqualityOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getEquality_EqualityOp()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getEquality_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getEquality_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualityAccess().getEqualityOpEqualityOpEnumEnumRuleCall_1_1_0(), semanticObject.getEqualityOp());
		feeder.accept(grammarAccess.getEqualityAccess().getRightComparisonParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Ether
	 *     Assignment returns Ether
	 *     Assignment.Assignment_1_0_0 returns Ether
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Ether
	 *     BinaryExpression returns Ether
	 *     Or returns Ether
	 *     Or.Or_1_0 returns Ether
	 *     And returns Ether
	 *     And.And_1_0 returns Ether
	 *     Equality returns Ether
	 *     Equality.Equality_1_0 returns Ether
	 *     Comparison returns Ether
	 *     Comparison.Comparison_1_0 returns Ether
	 *     BitOr returns Ether
	 *     BitOr.BitOr_1_0 returns Ether
	 *     BitXor returns Ether
	 *     BitXor.BitXor_1_0 returns Ether
	 *     BitAnd returns Ether
	 *     BitAnd.BitAnd_1_0 returns Ether
	 *     Shift returns Ether
	 *     Shift.Shift_1_0 returns Ether
	 *     AddSub returns Ether
	 *     AddSub.AddSub_1_0_0 returns Ether
	 *     MulDivMod returns Ether
	 *     MulDivMod.MulDivMod_1_0 returns Ether
	 *     Exponent returns Ether
	 *     Exponent.Exponent_1_0 returns Ether
	 *     UnaryExpression returns Ether
	 *     PreExpression returns Ether
	 *     PreExpression.PreIncExpression_1_2 returns Ether
	 *     PreExpression.PreDecExpression_2_2 returns Ether
	 *     PostIncDecExpression returns Ether
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Ether
	 *     PrimaryExpression returns Ether
	 *     PrimaryExpression.Tuple_4_2_0 returns Ether
	 *     Literal returns Ether
	 *     Number returns Ether
	 *     Ether returns Ether
	 *
	 * Constraint:
	 *     (value=INT ether=EtherSubDenominationEnum)
	 */
	protected void sequence_Ether(ISerializationContext context, Ether semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getEther_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getEther_Value()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getEther_Ether()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getEther_Ether()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEtherAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getEtherAccess().getEtherEtherSubDenominationEnumEnumRuleCall_1_0(), semanticObject.getEther());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList? isAnonymous?='anonymous'?)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Exponent
	 *     Assignment returns Exponent
	 *     Assignment.Assignment_1_0_0 returns Exponent
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Exponent
	 *     BinaryExpression returns Exponent
	 *     Or returns Exponent
	 *     Or.Or_1_0 returns Exponent
	 *     And returns Exponent
	 *     And.And_1_0 returns Exponent
	 *     Equality returns Exponent
	 *     Equality.Equality_1_0 returns Exponent
	 *     Comparison returns Exponent
	 *     Comparison.Comparison_1_0 returns Exponent
	 *     BitOr returns Exponent
	 *     BitOr.BitOr_1_0 returns Exponent
	 *     BitXor returns Exponent
	 *     BitXor.BitXor_1_0 returns Exponent
	 *     BitAnd returns Exponent
	 *     BitAnd.BitAnd_1_0 returns Exponent
	 *     Shift returns Exponent
	 *     Shift.Shift_1_0 returns Exponent
	 *     AddSub returns Exponent
	 *     AddSub.AddSub_1_0_0 returns Exponent
	 *     MulDivMod returns Exponent
	 *     MulDivMod.MulDivMod_1_0 returns Exponent
	 *     Exponent returns Exponent
	 *     Exponent.Exponent_1_0 returns Exponent
	 *     UnaryExpression returns Exponent
	 *     PreExpression returns Exponent
	 *     PreExpression.PreIncExpression_1_2 returns Exponent
	 *     PreExpression.PreDecExpression_2_2 returns Exponent
	 *     PostIncDecExpression returns Exponent
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Exponent
	 *     PrimaryExpression returns Exponent
	 *     PrimaryExpression.Tuple_4_2_0 returns Exponent
	 *
	 * Constraint:
	 *     (left=Exponent_Exponent_1_0 right=UnaryExpression)
	 */
	protected void sequence_Exponent(ISerializationContext context, Exponent semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getExponent_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getExponent_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getExponent_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getExponent_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExponentAccess().getExponentLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExponentAccess().getRightUnaryExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns ExpressionStatement
	 *     ExpressionStatement returns ExpressionStatement
	 *
	 * Constraint:
	 *     expression=Expression
	 */
	protected void sequence_ExpressionStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getExpressionStatement_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getExpressionStatement_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns ExpressionStatement
	 *     Statement returns ExpressionStatement
	 *
	 * Constraint:
	 *     (expression=Expression semicolon?=';')
	 */
	protected void sequence_ExpressionStatement_SimpleStatement(ISerializationContext context, ExpressionStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getExpressionStatement_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getExpressionStatement_Expression()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getExpressionStatement_Semicolon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getExpressionStatement_Semicolon()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionStatementAccess().getExpressionExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Field
	 *     Field returns Field
	 *
	 * Constraint:
	 *     field=ID
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getField_Field()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getField_Field()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getFieldIDTerminalRuleCall_1_0(), semanticObject.getField());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (initExpression=SimpleStatement2? conditionExpression=Expression? loopExpression=ExpressionStatement? body=Statement)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArg returns FunctionCallArg
	 *
	 * Constraint:
	 *     (name=ID expr=Expression)
	 */
	protected void sequence_FunctionCallArg(ISerializationContext context, FunctionCallArg semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getFunctionCallArg_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getFunctionCallArg_Name()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getFunctionCallArg_Expr()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getFunctionCallArg_Expr()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFunctionCallArgAccess().getExprExpressionParserRuleCall_2_0(), semanticObject.getExpr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallArguments returns FunctionCallArguments
	 *
	 * Constraint:
	 *     (args+=FunctionCallArg args+=FunctionCallArg*)?
	 */
	protected void sequence_FunctionCallArguments(ISerializationContext context, FunctionCallArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionCallListArguments returns FunctionCallListArguments
	 *     FunctionCallArguments returns FunctionCallListArguments
	 *
	 * Constraint:
	 *     (arguments+=Expression arguments+=Expression*)?
	 */
	protected void sequence_FunctionCallListArguments(ISerializationContext context, FunctionCallListArguments semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinition returns FunctionDefinition
	 *
	 * Constraint:
	 *     (name=ID? parameters=ParameterList optionalElements+=FunctionDefinitionOptionalElement* returnParameters=ReturnsParameterList? blocks=Blocks?)
	 */
	protected void sequence_FunctionDefinition(ISerializationContext context, FunctionDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns HexLiteral
	 *     Assignment returns HexLiteral
	 *     Assignment.Assignment_1_0_0 returns HexLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns HexLiteral
	 *     BinaryExpression returns HexLiteral
	 *     Or returns HexLiteral
	 *     Or.Or_1_0 returns HexLiteral
	 *     And returns HexLiteral
	 *     And.And_1_0 returns HexLiteral
	 *     Equality returns HexLiteral
	 *     Equality.Equality_1_0 returns HexLiteral
	 *     Comparison returns HexLiteral
	 *     Comparison.Comparison_1_0 returns HexLiteral
	 *     BitOr returns HexLiteral
	 *     BitOr.BitOr_1_0 returns HexLiteral
	 *     BitXor returns HexLiteral
	 *     BitXor.BitXor_1_0 returns HexLiteral
	 *     BitAnd returns HexLiteral
	 *     BitAnd.BitAnd_1_0 returns HexLiteral
	 *     Shift returns HexLiteral
	 *     Shift.Shift_1_0 returns HexLiteral
	 *     AddSub returns HexLiteral
	 *     AddSub.AddSub_1_0_0 returns HexLiteral
	 *     MulDivMod returns HexLiteral
	 *     MulDivMod.MulDivMod_1_0 returns HexLiteral
	 *     Exponent returns HexLiteral
	 *     Exponent.Exponent_1_0 returns HexLiteral
	 *     UnaryExpression returns HexLiteral
	 *     PreExpression returns HexLiteral
	 *     PreExpression.PreIncExpression_1_2 returns HexLiteral
	 *     PreExpression.PreDecExpression_2_2 returns HexLiteral
	 *     PostIncDecExpression returns HexLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns HexLiteral
	 *     PrimaryExpression returns HexLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns HexLiteral
	 *     Literal returns HexLiteral
	 *     Number returns HexLiteral
	 *     HexLiteral returns HexLiteral
	 *
	 * Constraint:
	 *     value=HEX
	 */
	protected void sequence_HexLiteral(ISerializationContext context, HexLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getHexLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getHexLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHexLiteralAccess().getValueHEXTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IfStatement
	 *     IfStatement returns IfStatement
	 *
	 * Constraint:
	 *     (condition=Expression trueBody=Statement falseBody=Statement?)
	 */
	protected void sequence_IfStatement(ISerializationContext context, IfStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ImportDirective returns ImportDirective
	 *
	 * Constraint:
	 *     (importURI=STRING | (unitAlias=ID importURI=STRING) | (symbolAliases+=SymbolAlias symbolAliases+=SymbolAlias? importURI=STRING))
	 */
	protected void sequence_ImportDirective(ISerializationContext context, ImportDirective semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Qualifier returns Index
	 *     Index returns Index
	 *
	 * Constraint:
	 *     value=Expression?
	 */
	protected void sequence_Index(ISerializationContext context, Index semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns IndexedSpecifer
	 *     IndexedSpecifer returns IndexedSpecifer
	 *
	 * Constraint:
	 *     {IndexedSpecifer}
	 */
	protected void sequence_IndexedSpecifer(ISerializationContext context, IndexedSpecifer semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InheritanceSpecifier returns InheritanceSpecifier
	 *
	 * Constraint:
	 *     (superType=[ContractOrLibrary|ID] args=FunctionCallListArguments?)
	 */
	protected void sequence_InheritanceSpecifier(ISerializationContext context, InheritanceSpecifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContractOrLibrary returns Library
	 *     Library returns Library
	 *
	 * Constraint:
	 *     (name=ID (inheritanceSpecifiers+=InheritanceSpecifier inheritanceSpecifiers+=InheritanceSpecifier*)? body=DefinitionBody)
	 */
	protected void sequence_Library(ISerializationContext context, Library semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclarationOptionalElement returns LocationSpecifier
	 *     LocationSpecifier returns LocationSpecifier
	 *
	 * Constraint:
	 *     location=LocationSpecifierEnum
	 */
	protected void sequence_LocationSpecifier(ISerializationContext context, LocationSpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getLocationSpecifier_Location()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getLocationSpecifier_Location()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocationSpecifierAccess().getLocationLocationSpecifierEnumEnumRuleCall_0(), semanticObject.getLocation());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Mapping
	 *     StandardType returns Mapping
	 *     StandardTypeWithoutQualifiedIdentifier returns Mapping
	 *     Mapping returns Mapping
	 *     SimpleStatement.StandardVariableDeclaration_0_0_1_0 returns Mapping
	 *     SimpleStatement2.StandardVariableDeclaration_0_1_0 returns Mapping
	 *
	 * Constraint:
	 *     (keyType=ElementaryTypeNameEnum valueType=Type)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getMapping_KeyType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getMapping_KeyType()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getMapping_ValueType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getMapping_ValueType()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingAccess().getKeyTypeElementaryTypeNameEnumEnumRuleCall_2_0(), semanticObject.getKeyType());
		feeder.accept(grammarAccess.getMappingAccess().getValueTypeTypeParserRuleCall_4_0(), semanticObject.getValueType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns ModifierInvocation
	 *     ModifierInvocation returns ModifierInvocation
	 *
	 * Constraint:
	 *     (name=[Modifier|ID] args=FunctionCallListArguments?)
	 */
	protected void sequence_ModifierInvocation(ISerializationContext context, ModifierInvocation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Modifier returns Modifier
	 *
	 * Constraint:
	 *     (name=ID parameters=ParameterList? blocks=Blocks)
	 */
	protected void sequence_Modifier(ISerializationContext context, Modifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns MulDivMod
	 *     Assignment returns MulDivMod
	 *     Assignment.Assignment_1_0_0 returns MulDivMod
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns MulDivMod
	 *     BinaryExpression returns MulDivMod
	 *     Or returns MulDivMod
	 *     Or.Or_1_0 returns MulDivMod
	 *     And returns MulDivMod
	 *     And.And_1_0 returns MulDivMod
	 *     Equality returns MulDivMod
	 *     Equality.Equality_1_0 returns MulDivMod
	 *     Comparison returns MulDivMod
	 *     Comparison.Comparison_1_0 returns MulDivMod
	 *     BitOr returns MulDivMod
	 *     BitOr.BitOr_1_0 returns MulDivMod
	 *     BitXor returns MulDivMod
	 *     BitXor.BitXor_1_0 returns MulDivMod
	 *     BitAnd returns MulDivMod
	 *     BitAnd.BitAnd_1_0 returns MulDivMod
	 *     Shift returns MulDivMod
	 *     Shift.Shift_1_0 returns MulDivMod
	 *     AddSub returns MulDivMod
	 *     AddSub.AddSub_1_0_0 returns MulDivMod
	 *     MulDivMod returns MulDivMod
	 *     MulDivMod.MulDivMod_1_0 returns MulDivMod
	 *     Exponent returns MulDivMod
	 *     Exponent.Exponent_1_0 returns MulDivMod
	 *     UnaryExpression returns MulDivMod
	 *     PreExpression returns MulDivMod
	 *     PreExpression.PreIncExpression_1_2 returns MulDivMod
	 *     PreExpression.PreDecExpression_2_2 returns MulDivMod
	 *     PostIncDecExpression returns MulDivMod
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns MulDivMod
	 *     PrimaryExpression returns MulDivMod
	 *     PrimaryExpression.Tuple_4_2_0 returns MulDivMod
	 *
	 * Constraint:
	 *     (left=MulDivMod_MulDivMod_1_0 multipliciativeOp=MulDivModOpEnum right=Exponent)
	 */
	protected void sequence_MulDivMod(ISerializationContext context, MulDivMod semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getMulDivMod_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getMulDivMod_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getMulDivMod_MultipliciativeOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getMulDivMod_MultipliciativeOp()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getMulDivMod_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getMulDivMod_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulDivModAccess().getMulDivModLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulDivModAccess().getMultipliciativeOpMulDivModOpEnumEnumRuleCall_1_1_0(), semanticObject.getMultipliciativeOp());
		feeder.accept(grammarAccess.getMulDivModAccess().getRightExponentParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NewExpression
	 *     Assignment returns NewExpression
	 *     Assignment.Assignment_1_0_0 returns NewExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NewExpression
	 *     BinaryExpression returns NewExpression
	 *     Or returns NewExpression
	 *     Or.Or_1_0 returns NewExpression
	 *     And returns NewExpression
	 *     And.And_1_0 returns NewExpression
	 *     Equality returns NewExpression
	 *     Equality.Equality_1_0 returns NewExpression
	 *     Comparison returns NewExpression
	 *     Comparison.Comparison_1_0 returns NewExpression
	 *     BitOr returns NewExpression
	 *     BitOr.BitOr_1_0 returns NewExpression
	 *     BitXor returns NewExpression
	 *     BitXor.BitXor_1_0 returns NewExpression
	 *     BitAnd returns NewExpression
	 *     BitAnd.BitAnd_1_0 returns NewExpression
	 *     Shift returns NewExpression
	 *     Shift.Shift_1_0 returns NewExpression
	 *     AddSub returns NewExpression
	 *     AddSub.AddSub_1_0_0 returns NewExpression
	 *     MulDivMod returns NewExpression
	 *     MulDivMod.MulDivMod_1_0 returns NewExpression
	 *     Exponent returns NewExpression
	 *     Exponent.Exponent_1_0 returns NewExpression
	 *     UnaryExpression returns NewExpression
	 *     NewExpression returns NewExpression
	 *     PreExpression returns NewExpression
	 *     PreExpression.PreIncExpression_1_2 returns NewExpression
	 *     PreExpression.PreDecExpression_2_2 returns NewExpression
	 *     PostIncDecExpression returns NewExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NewExpression
	 *     PrimaryExpression returns NewExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns NewExpression
	 *
	 * Constraint:
	 *     (contract=[ContractOrLibrary|ID] args=FunctionCallListArguments)
	 */
	protected void sequence_NewExpression(ISerializationContext context, NewExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getNewExpression_Contract()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getNewExpression_Contract()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getNewExpression_Args()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getNewExpression_Args()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNewExpressionAccess().getContractContractOrLibraryIDTerminalRuleCall_1_0_1(), semanticObject.eGet(SolidityPackage.eINSTANCE.getNewExpression_Contract(), false));
		feeder.accept(grammarAccess.getNewExpressionAccess().getArgsFunctionCallListArgumentsParserRuleCall_2_0(), semanticObject.getArgs());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NotExpression
	 *     Assignment returns NotExpression
	 *     Assignment.Assignment_1_0_0 returns NotExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NotExpression
	 *     BinaryExpression returns NotExpression
	 *     Or returns NotExpression
	 *     Or.Or_1_0 returns NotExpression
	 *     And returns NotExpression
	 *     And.And_1_0 returns NotExpression
	 *     Equality returns NotExpression
	 *     Equality.Equality_1_0 returns NotExpression
	 *     Comparison returns NotExpression
	 *     Comparison.Comparison_1_0 returns NotExpression
	 *     BitOr returns NotExpression
	 *     BitOr.BitOr_1_0 returns NotExpression
	 *     BitXor returns NotExpression
	 *     BitXor.BitXor_1_0 returns NotExpression
	 *     BitAnd returns NotExpression
	 *     BitAnd.BitAnd_1_0 returns NotExpression
	 *     Shift returns NotExpression
	 *     Shift.Shift_1_0 returns NotExpression
	 *     AddSub returns NotExpression
	 *     AddSub.AddSub_1_0_0 returns NotExpression
	 *     MulDivMod returns NotExpression
	 *     MulDivMod.MulDivMod_1_0 returns NotExpression
	 *     Exponent returns NotExpression
	 *     Exponent.Exponent_1_0 returns NotExpression
	 *     UnaryExpression returns NotExpression
	 *     NotExpression returns NotExpression
	 *     PreExpression returns NotExpression
	 *     PreExpression.PreIncExpression_1_2 returns NotExpression
	 *     PreExpression.PreDecExpression_2_2 returns NotExpression
	 *     PostIncDecExpression returns NotExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NotExpression
	 *     PrimaryExpression returns NotExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns NotExpression
	 *
	 * Constraint:
	 *     expression=UnaryExpression
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getNotExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getNotExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getExpressionUnaryExpressionParserRuleCall_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns NumberDimensionless
	 *     Assignment returns NumberDimensionless
	 *     Assignment.Assignment_1_0_0 returns NumberDimensionless
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns NumberDimensionless
	 *     BinaryExpression returns NumberDimensionless
	 *     Or returns NumberDimensionless
	 *     Or.Or_1_0 returns NumberDimensionless
	 *     And returns NumberDimensionless
	 *     And.And_1_0 returns NumberDimensionless
	 *     Equality returns NumberDimensionless
	 *     Equality.Equality_1_0 returns NumberDimensionless
	 *     Comparison returns NumberDimensionless
	 *     Comparison.Comparison_1_0 returns NumberDimensionless
	 *     BitOr returns NumberDimensionless
	 *     BitOr.BitOr_1_0 returns NumberDimensionless
	 *     BitXor returns NumberDimensionless
	 *     BitXor.BitXor_1_0 returns NumberDimensionless
	 *     BitAnd returns NumberDimensionless
	 *     BitAnd.BitAnd_1_0 returns NumberDimensionless
	 *     Shift returns NumberDimensionless
	 *     Shift.Shift_1_0 returns NumberDimensionless
	 *     AddSub returns NumberDimensionless
	 *     AddSub.AddSub_1_0_0 returns NumberDimensionless
	 *     MulDivMod returns NumberDimensionless
	 *     MulDivMod.MulDivMod_1_0 returns NumberDimensionless
	 *     Exponent returns NumberDimensionless
	 *     Exponent.Exponent_1_0 returns NumberDimensionless
	 *     UnaryExpression returns NumberDimensionless
	 *     PreExpression returns NumberDimensionless
	 *     PreExpression.PreIncExpression_1_2 returns NumberDimensionless
	 *     PreExpression.PreDecExpression_2_2 returns NumberDimensionless
	 *     PostIncDecExpression returns NumberDimensionless
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns NumberDimensionless
	 *     PrimaryExpression returns NumberDimensionless
	 *     PrimaryExpression.Tuple_4_2_0 returns NumberDimensionless
	 *     Literal returns NumberDimensionless
	 *     Number returns NumberDimensionless
	 *     NumberDimensionless returns NumberDimensionless
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_NumberDimensionless(ISerializationContext context, NumberDimensionless semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getNumberDimensionless_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getNumberDimensionless_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNumberDimensionlessAccess().getValueINTTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Or
	 *     Assignment returns Or
	 *     Assignment.Assignment_1_0_0 returns Or
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Or
	 *     BinaryExpression returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     BitOr returns Or
	 *     BitOr.BitOr_1_0 returns Or
	 *     BitXor returns Or
	 *     BitXor.BitXor_1_0 returns Or
	 *     BitAnd returns Or
	 *     BitAnd.BitAnd_1_0 returns Or
	 *     Shift returns Or
	 *     Shift.Shift_1_0 returns Or
	 *     AddSub returns Or
	 *     AddSub.AddSub_1_0_0 returns Or
	 *     MulDivMod returns Or
	 *     MulDivMod.MulDivMod_1_0 returns Or
	 *     Exponent returns Or
	 *     Exponent.Exponent_1_0 returns Or
	 *     UnaryExpression returns Or
	 *     PreExpression returns Or
	 *     PreExpression.PreIncExpression_1_2 returns Or
	 *     PreExpression.PreDecExpression_2_2 returns Or
	 *     PostIncDecExpression returns Or
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Or
	 *     PrimaryExpression returns Or
	 *     PrimaryExpression.Tuple_4_2_0 returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getOr_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getOr_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getOr_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getOr_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ParameterList returns ParameterList
	 *
	 * Constraint:
	 *     (parameters+=VariableDeclaration parameters+=VariableDeclaration*)?
	 */
	protected void sequence_ParameterList(ISerializationContext context, ParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns PlaceHolderStatement
	 *     PlaceHolderStatement returns PlaceHolderStatement
	 *
	 * Constraint:
	 *     {PlaceHolderStatement}
	 */
	protected void sequence_PlaceHolderStatement(ISerializationContext context, PlaceHolderStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PostIncDecExpression
	 *     Assignment returns PostIncDecExpression
	 *     Assignment.Assignment_1_0_0 returns PostIncDecExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PostIncDecExpression
	 *     BinaryExpression returns PostIncDecExpression
	 *     Or returns PostIncDecExpression
	 *     Or.Or_1_0 returns PostIncDecExpression
	 *     And returns PostIncDecExpression
	 *     And.And_1_0 returns PostIncDecExpression
	 *     Equality returns PostIncDecExpression
	 *     Equality.Equality_1_0 returns PostIncDecExpression
	 *     Comparison returns PostIncDecExpression
	 *     Comparison.Comparison_1_0 returns PostIncDecExpression
	 *     BitOr returns PostIncDecExpression
	 *     BitOr.BitOr_1_0 returns PostIncDecExpression
	 *     BitXor returns PostIncDecExpression
	 *     BitXor.BitXor_1_0 returns PostIncDecExpression
	 *     BitAnd returns PostIncDecExpression
	 *     BitAnd.BitAnd_1_0 returns PostIncDecExpression
	 *     Shift returns PostIncDecExpression
	 *     Shift.Shift_1_0 returns PostIncDecExpression
	 *     AddSub returns PostIncDecExpression
	 *     AddSub.AddSub_1_0_0 returns PostIncDecExpression
	 *     MulDivMod returns PostIncDecExpression
	 *     MulDivMod.MulDivMod_1_0 returns PostIncDecExpression
	 *     Exponent returns PostIncDecExpression
	 *     Exponent.Exponent_1_0 returns PostIncDecExpression
	 *     UnaryExpression returns PostIncDecExpression
	 *     PreExpression returns PostIncDecExpression
	 *     PreExpression.PreIncExpression_1_2 returns PostIncDecExpression
	 *     PreExpression.PreDecExpression_2_2 returns PostIncDecExpression
	 *     PostIncDecExpression returns PostIncDecExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PostIncDecExpression
	 *     PrimaryExpression returns PostIncDecExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PostIncDecExpression
	 *
	 * Constraint:
	 *     (expression=PostIncDecExpression_PostIncDecExpression_1_0 postOp=IncDecOpEnum)
	 */
	protected void sequence_PostIncDecExpression(ISerializationContext context, PostIncDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getPostIncDecExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getPostIncDecExpression_Expression()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getPostIncDecExpression_PostOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getPostIncDecExpression_PostOp()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostIncDecExpressionAccess().getPostIncDecExpressionExpressionAction_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getPostIncDecExpressionAccess().getPostOpIncDecOpEnumEnumRuleCall_1_1_0(), semanticObject.getPostOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PreDecExpression returns PreDecExpression
	 *
	 * Constraint:
	 *     expression=PostIncDecExpression
	 */
	protected void sequence_PreDecExpression(ISerializationContext context, PreDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getPreDecExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getPreDecExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreDecExpressionAccess().getExpressionPostIncDecExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreDecExpression
	 *     Assignment returns PreDecExpression
	 *     Assignment.Assignment_1_0_0 returns PreDecExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PreDecExpression
	 *     BinaryExpression returns PreDecExpression
	 *     Or returns PreDecExpression
	 *     Or.Or_1_0 returns PreDecExpression
	 *     And returns PreDecExpression
	 *     And.And_1_0 returns PreDecExpression
	 *     Equality returns PreDecExpression
	 *     Equality.Equality_1_0 returns PreDecExpression
	 *     Comparison returns PreDecExpression
	 *     Comparison.Comparison_1_0 returns PreDecExpression
	 *     BitOr returns PreDecExpression
	 *     BitOr.BitOr_1_0 returns PreDecExpression
	 *     BitXor returns PreDecExpression
	 *     BitXor.BitXor_1_0 returns PreDecExpression
	 *     BitAnd returns PreDecExpression
	 *     BitAnd.BitAnd_1_0 returns PreDecExpression
	 *     Shift returns PreDecExpression
	 *     Shift.Shift_1_0 returns PreDecExpression
	 *     AddSub returns PreDecExpression
	 *     AddSub.AddSub_1_0_0 returns PreDecExpression
	 *     MulDivMod returns PreDecExpression
	 *     MulDivMod.MulDivMod_1_0 returns PreDecExpression
	 *     Exponent returns PreDecExpression
	 *     Exponent.Exponent_1_0 returns PreDecExpression
	 *     UnaryExpression returns PreDecExpression
	 *     PreExpression returns PreDecExpression
	 *     PreExpression.PreIncExpression_1_2 returns PreDecExpression
	 *     PreExpression.PreDecExpression_2_2 returns PreDecExpression
	 *     PostIncDecExpression returns PreDecExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PreDecExpression
	 *     PrimaryExpression returns PreDecExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PreDecExpression
	 *
	 * Constraint:
	 *     expression=PreExpression_PreDecExpression_2_2
	 */
	protected void sequence_PreExpression(ISerializationContext context, PreDecExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getPreDecExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getPreDecExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreExpressionAccess().getPreDecExpressionExpressionAction_2_2(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns PreIncExpression
	 *     Assignment returns PreIncExpression
	 *     Assignment.Assignment_1_0_0 returns PreIncExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns PreIncExpression
	 *     BinaryExpression returns PreIncExpression
	 *     Or returns PreIncExpression
	 *     Or.Or_1_0 returns PreIncExpression
	 *     And returns PreIncExpression
	 *     And.And_1_0 returns PreIncExpression
	 *     Equality returns PreIncExpression
	 *     Equality.Equality_1_0 returns PreIncExpression
	 *     Comparison returns PreIncExpression
	 *     Comparison.Comparison_1_0 returns PreIncExpression
	 *     BitOr returns PreIncExpression
	 *     BitOr.BitOr_1_0 returns PreIncExpression
	 *     BitXor returns PreIncExpression
	 *     BitXor.BitXor_1_0 returns PreIncExpression
	 *     BitAnd returns PreIncExpression
	 *     BitAnd.BitAnd_1_0 returns PreIncExpression
	 *     Shift returns PreIncExpression
	 *     Shift.Shift_1_0 returns PreIncExpression
	 *     AddSub returns PreIncExpression
	 *     AddSub.AddSub_1_0_0 returns PreIncExpression
	 *     MulDivMod returns PreIncExpression
	 *     MulDivMod.MulDivMod_1_0 returns PreIncExpression
	 *     Exponent returns PreIncExpression
	 *     Exponent.Exponent_1_0 returns PreIncExpression
	 *     UnaryExpression returns PreIncExpression
	 *     PreExpression returns PreIncExpression
	 *     PreExpression.PreIncExpression_1_2 returns PreIncExpression
	 *     PreExpression.PreDecExpression_2_2 returns PreIncExpression
	 *     PostIncDecExpression returns PreIncExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns PreIncExpression
	 *     PrimaryExpression returns PreIncExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns PreIncExpression
	 *
	 * Constraint:
	 *     expression=PreExpression_PreIncExpression_1_2
	 */
	protected void sequence_PreExpression(ISerializationContext context, PreIncExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getPreIncExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getPreIncExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreExpressionAccess().getPreIncExpressionExpressionAction_1_2(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PreIncExpression returns PreIncExpression
	 *
	 * Constraint:
	 *     expression=PostIncDecExpression
	 */
	protected void sequence_PreIncExpression(ISerializationContext context, PreIncExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getPreIncExpression_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getPreIncExpression_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPreIncExpressionAccess().getExpressionPostIncDecExpressionParserRuleCall_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Tuple
	 *     Assignment returns Tuple
	 *     Assignment.Assignment_1_0_0 returns Tuple
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Tuple
	 *     BinaryExpression returns Tuple
	 *     Or returns Tuple
	 *     Or.Or_1_0 returns Tuple
	 *     And returns Tuple
	 *     And.And_1_0 returns Tuple
	 *     Equality returns Tuple
	 *     Equality.Equality_1_0 returns Tuple
	 *     Comparison returns Tuple
	 *     Comparison.Comparison_1_0 returns Tuple
	 *     BitOr returns Tuple
	 *     BitOr.BitOr_1_0 returns Tuple
	 *     BitXor returns Tuple
	 *     BitXor.BitXor_1_0 returns Tuple
	 *     BitAnd returns Tuple
	 *     BitAnd.BitAnd_1_0 returns Tuple
	 *     Shift returns Tuple
	 *     Shift.Shift_1_0 returns Tuple
	 *     AddSub returns Tuple
	 *     AddSub.AddSub_1_0_0 returns Tuple
	 *     MulDivMod returns Tuple
	 *     MulDivMod.MulDivMod_1_0 returns Tuple
	 *     Exponent returns Tuple
	 *     Exponent.Exponent_1_0 returns Tuple
	 *     UnaryExpression returns Tuple
	 *     PreExpression returns Tuple
	 *     PreExpression.PreIncExpression_1_2 returns Tuple
	 *     PreExpression.PreDecExpression_2_2 returns Tuple
	 *     PostIncDecExpression returns Tuple
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Tuple
	 *     PrimaryExpression returns Tuple
	 *     PrimaryExpression.Tuple_4_2_0 returns Tuple
	 *
	 * Constraint:
	 *     (
	 *         (members+=PrimaryExpression_Tuple_4_2_0 (members+=TupleSeparator members+=Expression?)+) | 
	 *         (members+=PrimaryExpression_Tuple_5_2_0 members+=Expression? (members+=TupleSeparator members+=Expression?)*)
	 *     )?
	 */
	protected void sequence_PrimaryExpression(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns QualifiedIdentifier
	 *     StandardType returns QualifiedIdentifier
	 *     QualifiedIdentifier returns QualifiedIdentifier
	 *     Expression returns QualifiedIdentifier
	 *     Assignment returns QualifiedIdentifier
	 *     Assignment.Assignment_1_0_0 returns QualifiedIdentifier
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns QualifiedIdentifier
	 *     BinaryExpression returns QualifiedIdentifier
	 *     Or returns QualifiedIdentifier
	 *     Or.Or_1_0 returns QualifiedIdentifier
	 *     And returns QualifiedIdentifier
	 *     And.And_1_0 returns QualifiedIdentifier
	 *     Equality returns QualifiedIdentifier
	 *     Equality.Equality_1_0 returns QualifiedIdentifier
	 *     Comparison returns QualifiedIdentifier
	 *     Comparison.Comparison_1_0 returns QualifiedIdentifier
	 *     BitOr returns QualifiedIdentifier
	 *     BitOr.BitOr_1_0 returns QualifiedIdentifier
	 *     BitXor returns QualifiedIdentifier
	 *     BitXor.BitXor_1_0 returns QualifiedIdentifier
	 *     BitAnd returns QualifiedIdentifier
	 *     BitAnd.BitAnd_1_0 returns QualifiedIdentifier
	 *     Shift returns QualifiedIdentifier
	 *     Shift.Shift_1_0 returns QualifiedIdentifier
	 *     AddSub returns QualifiedIdentifier
	 *     AddSub.AddSub_1_0_0 returns QualifiedIdentifier
	 *     MulDivMod returns QualifiedIdentifier
	 *     MulDivMod.MulDivMod_1_0 returns QualifiedIdentifier
	 *     Exponent returns QualifiedIdentifier
	 *     Exponent.Exponent_1_0 returns QualifiedIdentifier
	 *     UnaryExpression returns QualifiedIdentifier
	 *     PreExpression returns QualifiedIdentifier
	 *     PreExpression.PreIncExpression_1_2 returns QualifiedIdentifier
	 *     PreExpression.PreDecExpression_2_2 returns QualifiedIdentifier
	 *     PostIncDecExpression returns QualifiedIdentifier
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns QualifiedIdentifier
	 *     PrimaryExpression returns QualifiedIdentifier
	 *     PrimaryExpression.Tuple_4_2_0 returns QualifiedIdentifier
	 *
	 * Constraint:
	 *     (identifier=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_QualifiedIdentifier(ISerializationContext context, QualifiedIdentifier semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnParameterDeclaration returns ReturnParameterDeclaration
	 *
	 * Constraint:
	 *     (typeRef=Type variable=Variable?)
	 */
	protected void sequence_ReturnParameterDeclaration(ISerializationContext context, ReturnParameterDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReturnsParameterList returns ReturnsParameterList
	 *
	 * Constraint:
	 *     (parameters+=ReturnParameterDeclaration parameters+=ReturnParameterDeclaration*)?
	 */
	protected void sequence_ReturnsParameterList(ISerializationContext context, ReturnsParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Shift
	 *     Assignment returns Shift
	 *     Assignment.Assignment_1_0_0 returns Shift
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Shift
	 *     BinaryExpression returns Shift
	 *     Or returns Shift
	 *     Or.Or_1_0 returns Shift
	 *     And returns Shift
	 *     And.And_1_0 returns Shift
	 *     Equality returns Shift
	 *     Equality.Equality_1_0 returns Shift
	 *     Comparison returns Shift
	 *     Comparison.Comparison_1_0 returns Shift
	 *     BitOr returns Shift
	 *     BitOr.BitOr_1_0 returns Shift
	 *     BitXor returns Shift
	 *     BitXor.BitXor_1_0 returns Shift
	 *     BitAnd returns Shift
	 *     BitAnd.BitAnd_1_0 returns Shift
	 *     Shift returns Shift
	 *     Shift.Shift_1_0 returns Shift
	 *     AddSub returns Shift
	 *     AddSub.AddSub_1_0_0 returns Shift
	 *     MulDivMod returns Shift
	 *     MulDivMod.MulDivMod_1_0 returns Shift
	 *     Exponent returns Shift
	 *     Exponent.Exponent_1_0 returns Shift
	 *     UnaryExpression returns Shift
	 *     PreExpression returns Shift
	 *     PreExpression.PreIncExpression_1_2 returns Shift
	 *     PreExpression.PreDecExpression_2_2 returns Shift
	 *     PostIncDecExpression returns Shift
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Shift
	 *     PrimaryExpression returns Shift
	 *     PrimaryExpression.Tuple_4_2_0 returns Shift
	 *
	 * Constraint:
	 *     (left=Shift_Shift_1_0 shiftOp=ShiftOpEnum right=AddSub)
	 */
	protected void sequence_Shift(ISerializationContext context, Shift semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getShift_Left()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getShift_Left()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getShift_ShiftOp()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getShift_ShiftOp()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getShift_Right()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getShift_Right()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShiftAccess().getShiftLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getShiftAccess().getShiftOpShiftOpEnumEnumRuleCall_1_1_0(), semanticObject.getShiftOp());
		feeder.accept(grammarAccess.getShiftAccess().getRightAddSubParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SignExpression
	 *     Assignment returns SignExpression
	 *     Assignment.Assignment_1_0_0 returns SignExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SignExpression
	 *     BinaryExpression returns SignExpression
	 *     Or returns SignExpression
	 *     Or.Or_1_0 returns SignExpression
	 *     And returns SignExpression
	 *     And.And_1_0 returns SignExpression
	 *     Equality returns SignExpression
	 *     Equality.Equality_1_0 returns SignExpression
	 *     Comparison returns SignExpression
	 *     Comparison.Comparison_1_0 returns SignExpression
	 *     BitOr returns SignExpression
	 *     BitOr.BitOr_1_0 returns SignExpression
	 *     BitXor returns SignExpression
	 *     BitXor.BitXor_1_0 returns SignExpression
	 *     BitAnd returns SignExpression
	 *     BitAnd.BitAnd_1_0 returns SignExpression
	 *     Shift returns SignExpression
	 *     Shift.Shift_1_0 returns SignExpression
	 *     AddSub returns SignExpression
	 *     AddSub.AddSub_1_0_0 returns SignExpression
	 *     MulDivMod returns SignExpression
	 *     MulDivMod.MulDivMod_1_0 returns SignExpression
	 *     Exponent returns SignExpression
	 *     Exponent.Exponent_1_0 returns SignExpression
	 *     UnaryExpression returns SignExpression
	 *     SignExpression returns SignExpression
	 *     PreExpression returns SignExpression
	 *     PreExpression.PreIncExpression_1_2 returns SignExpression
	 *     PreExpression.PreDecExpression_2_2 returns SignExpression
	 *     PostIncDecExpression returns SignExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SignExpression
	 *     PrimaryExpression returns SignExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns SignExpression
	 *
	 * Constraint:
	 *     ((signOp='+' | signOp='-') expression=UnaryExpression)
	 */
	protected void sequence_SignExpression(ISerializationContext context, SignExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement2_StandardVariableDeclaration_0_1_0 
	 *         optionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression?
	 *     )
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getTupleTupleParserRuleCall_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement2 returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression)
	 */
	protected void sequence_SimpleStatement2(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatement2Access().getVariableVariableParserRuleCall_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatement2Access().getExpressionExpressionParserRuleCall_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns StandardVariableDeclaration
	 *     Statement returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (
	 *         type=SimpleStatement_StandardVariableDeclaration_0_0_1_0 
	 *         optionalElements+=VariableDeclarationOptionalElement* 
	 *         variable=Variable 
	 *         expression=Expression? 
	 *         semicolon?=';'
	 *     )
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTupleVariableDeclaration
	 *     Statement returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (tuple=Tuple expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Tuple()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Expression()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Semicolon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTupleVariableDeclaration_Semicolon()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getTupleTupleParserRuleCall_0_1_1_1_1_0(), semanticObject.getTuple());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_1_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     SimpleStatement returns VarVariableTypeDeclaration
	 *     Statement returns VarVariableTypeDeclaration
	 *
	 * Constraint:
	 *     (variable=Variable expression=Expression semicolon?=';')
	 */
	protected void sequence_SimpleStatement(ISerializationContext context, VarVariableTypeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Variable()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Expression()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Semicolon()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVarVariableTypeDeclaration_Semicolon()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getVariableVariableParserRuleCall_0_1_1_0_1_0(), semanticObject.getVariable());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpressionExpressionParserRuleCall_0_1_1_0_2_1_0(), semanticObject.getExpression());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getSemicolonSemicolonKeyword_1_0(), semanticObject.isSemicolon());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Solidity returns Solidity
	 *
	 * Constraint:
	 *     (importDirective+=ImportDirective | contract+=Contract | library+=Library)+
	 */
	protected void sequence_Solidity(ISerializationContext context, Solidity semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SpecialExpression
	 *     SpecialExpression returns SpecialExpression
	 *     Assignment returns SpecialExpression
	 *     Assignment.Assignment_1_0_0 returns SpecialExpression
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SpecialExpression
	 *     BinaryExpression returns SpecialExpression
	 *     Or returns SpecialExpression
	 *     Or.Or_1_0 returns SpecialExpression
	 *     And returns SpecialExpression
	 *     And.And_1_0 returns SpecialExpression
	 *     Equality returns SpecialExpression
	 *     Equality.Equality_1_0 returns SpecialExpression
	 *     Comparison returns SpecialExpression
	 *     Comparison.Comparison_1_0 returns SpecialExpression
	 *     BitOr returns SpecialExpression
	 *     BitOr.BitOr_1_0 returns SpecialExpression
	 *     BitXor returns SpecialExpression
	 *     BitXor.BitXor_1_0 returns SpecialExpression
	 *     BitAnd returns SpecialExpression
	 *     BitAnd.BitAnd_1_0 returns SpecialExpression
	 *     Shift returns SpecialExpression
	 *     Shift.Shift_1_0 returns SpecialExpression
	 *     AddSub returns SpecialExpression
	 *     AddSub.AddSub_1_0_0 returns SpecialExpression
	 *     MulDivMod returns SpecialExpression
	 *     MulDivMod.MulDivMod_1_0 returns SpecialExpression
	 *     Exponent returns SpecialExpression
	 *     Exponent.Exponent_1_0 returns SpecialExpression
	 *     UnaryExpression returns SpecialExpression
	 *     PreExpression returns SpecialExpression
	 *     PreExpression.PreIncExpression_1_2 returns SpecialExpression
	 *     PreExpression.PreDecExpression_2_2 returns SpecialExpression
	 *     PostIncDecExpression returns SpecialExpression
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SpecialExpression
	 *     PrimaryExpression returns SpecialExpression
	 *     PrimaryExpression.Tuple_4_2_0 returns SpecialExpression
	 *
	 * Constraint:
	 *     (type=SpecialExpressionTypeEnum fieldOrMethod=Field? (qualifiers+=Index | qualifiers+=Arguments)*)
	 */
	protected void sequence_SpecialExpression(ISerializationContext context, SpecialExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SpecialVariablesTypeEnum returns SpecialVariablesTypeEnum
	 *
	 * Constraint:
	 *     (name=BLOCK | name=MSG | name=TX | name=NOW)
	 */
	protected void sequence_SpecialVariablesTypeEnum(ISerializationContext context, SpecialVariablesTypeEnum semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns SpecialVariables
	 *     Assignment returns SpecialVariables
	 *     Assignment.Assignment_1_0_0 returns SpecialVariables
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns SpecialVariables
	 *     BinaryExpression returns SpecialVariables
	 *     Or returns SpecialVariables
	 *     Or.Or_1_0 returns SpecialVariables
	 *     And returns SpecialVariables
	 *     And.And_1_0 returns SpecialVariables
	 *     Equality returns SpecialVariables
	 *     Equality.Equality_1_0 returns SpecialVariables
	 *     Comparison returns SpecialVariables
	 *     Comparison.Comparison_1_0 returns SpecialVariables
	 *     BitOr returns SpecialVariables
	 *     BitOr.BitOr_1_0 returns SpecialVariables
	 *     BitXor returns SpecialVariables
	 *     BitXor.BitXor_1_0 returns SpecialVariables
	 *     BitAnd returns SpecialVariables
	 *     BitAnd.BitAnd_1_0 returns SpecialVariables
	 *     Shift returns SpecialVariables
	 *     Shift.Shift_1_0 returns SpecialVariables
	 *     AddSub returns SpecialVariables
	 *     AddSub.AddSub_1_0_0 returns SpecialVariables
	 *     MulDivMod returns SpecialVariables
	 *     MulDivMod.MulDivMod_1_0 returns SpecialVariables
	 *     Exponent returns SpecialVariables
	 *     Exponent.Exponent_1_0 returns SpecialVariables
	 *     UnaryExpression returns SpecialVariables
	 *     PreExpression returns SpecialVariables
	 *     PreExpression.PreIncExpression_1_2 returns SpecialVariables
	 *     PreExpression.PreDecExpression_2_2 returns SpecialVariables
	 *     PostIncDecExpression returns SpecialVariables
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns SpecialVariables
	 *     PrimaryExpression returns SpecialVariables
	 *     PrimaryExpression.Tuple_4_2_0 returns SpecialVariables
	 *     Literal returns SpecialVariables
	 *     SpecialVariables returns SpecialVariables
	 *
	 * Constraint:
	 *     (type=SpecialVariablesTypeEnum field=ID qualifiers+=Qualifier*)
	 */
	protected void sequence_SpecialVariables(ISerializationContext context, SpecialVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns StandardVariableDeclaration
	 *     StandardVariableDeclaration returns StandardVariableDeclaration
	 *
	 * Constraint:
	 *     (type=StandardType optionalElements+=VariableDeclarationOptionalElement* variable=Variable expression=Expression?)
	 */
	protected void sequence_StandardVariableDeclaration(ISerializationContext context, StandardVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns StringLiteral
	 *     Assignment returns StringLiteral
	 *     Assignment.Assignment_1_0_0 returns StringLiteral
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns StringLiteral
	 *     BinaryExpression returns StringLiteral
	 *     Or returns StringLiteral
	 *     Or.Or_1_0 returns StringLiteral
	 *     And returns StringLiteral
	 *     And.And_1_0 returns StringLiteral
	 *     Equality returns StringLiteral
	 *     Equality.Equality_1_0 returns StringLiteral
	 *     Comparison returns StringLiteral
	 *     Comparison.Comparison_1_0 returns StringLiteral
	 *     BitOr returns StringLiteral
	 *     BitOr.BitOr_1_0 returns StringLiteral
	 *     BitXor returns StringLiteral
	 *     BitXor.BitXor_1_0 returns StringLiteral
	 *     BitAnd returns StringLiteral
	 *     BitAnd.BitAnd_1_0 returns StringLiteral
	 *     Shift returns StringLiteral
	 *     Shift.Shift_1_0 returns StringLiteral
	 *     AddSub returns StringLiteral
	 *     AddSub.AddSub_1_0_0 returns StringLiteral
	 *     MulDivMod returns StringLiteral
	 *     MulDivMod.MulDivMod_1_0 returns StringLiteral
	 *     Exponent returns StringLiteral
	 *     Exponent.Exponent_1_0 returns StringLiteral
	 *     UnaryExpression returns StringLiteral
	 *     PreExpression returns StringLiteral
	 *     PreExpression.PreIncExpression_1_2 returns StringLiteral
	 *     PreExpression.PreDecExpression_2_2 returns StringLiteral
	 *     PostIncDecExpression returns StringLiteral
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns StringLiteral
	 *     PrimaryExpression returns StringLiteral
	 *     PrimaryExpression.Tuple_4_2_0 returns StringLiteral
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getStringLiteral_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getStringLiteral_Value()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     StructDefinition returns StructDefinition
	 *
	 * Constraint:
	 *     (name=ID members+=VariableDeclaration*)
	 */
	protected void sequence_StructDefinition(ISerializationContext context, StructDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SymbolAlias returns SymbolAlias
	 *
	 * Constraint:
	 *     (symbol=ID alias=ID)
	 */
	protected void sequence_SymbolAlias(ISerializationContext context, SymbolAlias semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getSymbolAlias_Symbol()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getSymbolAlias_Symbol()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getSymbolAlias_Alias()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getSymbolAlias_Alias()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSymbolAliasAccess().getSymbolIDTerminalRuleCall_0_0(), semanticObject.getSymbol());
		feeder.accept(grammarAccess.getSymbolAliasAccess().getAliasIDTerminalRuleCall_2_0(), semanticObject.getAlias());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ThrowStatement
	 *     ThrowStatement returns ThrowStatement
	 *
	 * Constraint:
	 *     {ThrowStatement}
	 */
	protected void sequence_ThrowStatement(ISerializationContext context, ThrowStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Time
	 *     Assignment returns Time
	 *     Assignment.Assignment_1_0_0 returns Time
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns Time
	 *     BinaryExpression returns Time
	 *     Or returns Time
	 *     Or.Or_1_0 returns Time
	 *     And returns Time
	 *     And.And_1_0 returns Time
	 *     Equality returns Time
	 *     Equality.Equality_1_0 returns Time
	 *     Comparison returns Time
	 *     Comparison.Comparison_1_0 returns Time
	 *     BitOr returns Time
	 *     BitOr.BitOr_1_0 returns Time
	 *     BitXor returns Time
	 *     BitXor.BitXor_1_0 returns Time
	 *     BitAnd returns Time
	 *     BitAnd.BitAnd_1_0 returns Time
	 *     Shift returns Time
	 *     Shift.Shift_1_0 returns Time
	 *     AddSub returns Time
	 *     AddSub.AddSub_1_0_0 returns Time
	 *     MulDivMod returns Time
	 *     MulDivMod.MulDivMod_1_0 returns Time
	 *     Exponent returns Time
	 *     Exponent.Exponent_1_0 returns Time
	 *     UnaryExpression returns Time
	 *     PreExpression returns Time
	 *     PreExpression.PreIncExpression_1_2 returns Time
	 *     PreExpression.PreDecExpression_2_2 returns Time
	 *     PostIncDecExpression returns Time
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns Time
	 *     PrimaryExpression returns Time
	 *     PrimaryExpression.Tuple_4_2_0 returns Time
	 *     Literal returns Time
	 *     Number returns Time
	 *     Time returns Time
	 *
	 * Constraint:
	 *     (value=INT time=TimeSubdenominationEnum)
	 */
	protected void sequence_Time(ISerializationContext context, Time semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getTime_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getTime_Value()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getTime_Time()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getTime_Time()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimeAccess().getValueINTTerminalRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTimeAccess().getTimeTimeSubdenominationEnumEnumRuleCall_1_0(), semanticObject.getTime());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TupleSeparator returns TupleSeparator
	 *     PrimaryExpression.Tuple_5_2_0 returns TupleSeparator
	 *
	 * Constraint:
	 *     {TupleSeparator}
	 */
	protected void sequence_TupleSeparator(ISerializationContext context, TupleSeparator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tuple returns Tuple
	 *
	 * Constraint:
	 *     (members+=Expression? (members+=TupleSeparator members+=Expression?)+)?
	 */
	protected void sequence_Tuple(ISerializationContext context, Tuple semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns TypeCast
	 *     Assignment returns TypeCast
	 *     Assignment.Assignment_1_0_0 returns TypeCast
	 *     Assignment.VariableDeclarationExpression_1_1_0 returns TypeCast
	 *     BinaryExpression returns TypeCast
	 *     Or returns TypeCast
	 *     Or.Or_1_0 returns TypeCast
	 *     And returns TypeCast
	 *     And.And_1_0 returns TypeCast
	 *     Equality returns TypeCast
	 *     Equality.Equality_1_0 returns TypeCast
	 *     Comparison returns TypeCast
	 *     Comparison.Comparison_1_0 returns TypeCast
	 *     BitOr returns TypeCast
	 *     BitOr.BitOr_1_0 returns TypeCast
	 *     BitXor returns TypeCast
	 *     BitXor.BitXor_1_0 returns TypeCast
	 *     BitAnd returns TypeCast
	 *     BitAnd.BitAnd_1_0 returns TypeCast
	 *     Shift returns TypeCast
	 *     Shift.Shift_1_0 returns TypeCast
	 *     AddSub returns TypeCast
	 *     AddSub.AddSub_1_0_0 returns TypeCast
	 *     MulDivMod returns TypeCast
	 *     MulDivMod.MulDivMod_1_0 returns TypeCast
	 *     Exponent returns TypeCast
	 *     Exponent.Exponent_1_0 returns TypeCast
	 *     UnaryExpression returns TypeCast
	 *     PreExpression returns TypeCast
	 *     PreExpression.PreIncExpression_1_2 returns TypeCast
	 *     PreExpression.PreDecExpression_2_2 returns TypeCast
	 *     PostIncDecExpression returns TypeCast
	 *     PostIncDecExpression.PostIncDecExpression_1_0 returns TypeCast
	 *     PrimaryExpression returns TypeCast
	 *     PrimaryExpression.Tuple_4_2_0 returns TypeCast
	 *     TypeCast returns TypeCast
	 *
	 * Constraint:
	 *     (value=ElementaryTypeNameEnum expression=Expression)
	 */
	protected void sequence_TypeCast(ISerializationContext context, TypeCast semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getTypeCast_Value()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getTypeCast_Value()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getTypeCast_Expression()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getTypeCast_Expression()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeCastAccess().getValueElementaryTypeNameEnumEnumRuleCall_0_0(), semanticObject.getValue());
		feeder.accept(grammarAccess.getTypeCastAccess().getExpressionExpressionParserRuleCall_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     isVarType?=VarType
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getType_IsVarType()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getType_IsVarType()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getIsVarTypeVarTypeParserRuleCall_1_0(), semanticObject.isIsVarType());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableDeclaration
	 *     VarVariableDeclaration returns VarVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType variable=Variable expression=Expression?)
	 */
	protected void sequence_VarVariableDeclaration(ISerializationContext context, VarVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VariableDeclaration returns VarVariableTupleVariableDeclaration
	 *     VarVariableTupleVariableDeclaration returns VarVariableTupleVariableDeclaration
	 *
	 * Constraint:
	 *     (varType=VarType tuple=Tuple expression=Expression?)
	 */
	protected void sequence_VarVariableTupleVariableDeclaration(ISerializationContext context, VarVariableTupleVariableDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Variable returns Variable
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Variable(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVariable_Name()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVariable_Name()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionDefinitionOptionalElement returns VisibilitySpecifier
	 *     VisibilitySpecifier returns VisibilitySpecifier
	 *     VariableDeclarationOptionalElement returns VisibilitySpecifier
	 *
	 * Constraint:
	 *     visibility=VisibilityEnum
	 */
	protected void sequence_VisibilitySpecifier(ISerializationContext context, VisibilitySpecifier semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getVisibilitySpecifier_Visibility()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getVisibilitySpecifier_Visibility()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVisibilitySpecifierAccess().getVisibilityVisibilityEnumEnumRuleCall_0(), semanticObject.getVisibility());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression body=Statement)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getWhileStatement_Condition()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getWhileStatement_Condition()));
			if (transientValues.isValueTransient(semanticObject, SolidityPackage.eINSTANCE.getWhileStatement_Body()) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SolidityPackage.eINSTANCE.getWhileStatement_Body()));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_2_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getBodyStatementParserRuleCall_4_0(), semanticObject.getBody());
		feeder.finish();
	}
	
	
}
